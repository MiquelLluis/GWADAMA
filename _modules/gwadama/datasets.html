
<!DOCTYPE html>


<html lang="en" data-content_root="../../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>gwadama.datasets &#8212; GWADAMA 0.2.0 documentation</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  <!--
    this give us a css class that will be invisible only if js is disabled
  -->
  <noscript>
    <style>
      .pst-js-only { display: none !important; }

    </style>
  </noscript>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../_static/styles/theme.css?digest=8878045cc6db502f8baf" rel="stylesheet" />
<link href="../../_static/styles/pydata-sphinx-theme.css?digest=8878045cc6db502f8baf" rel="stylesheet" />

    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=362ab14a" />
    <link rel="stylesheet" type="text/css" href="../../_static/custom.css?v=6e061ff1" />
  
  <!-- So that users can add custom icons -->
  <script src="../../_static/scripts/fontawesome.js?digest=8878045cc6db502f8baf"></script>
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../_static/scripts/bootstrap.js?digest=8878045cc6db502f8baf" />
<link rel="preload" as="script" href="../../_static/scripts/pydata-sphinx-theme.js?digest=8878045cc6db502f8baf" />

    <script src="../../_static/documentation_options.js?v=938c9ccc"></script>
    <script src="../../_static/doctools.js?v=888ff710"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = '_modules/gwadama/datasets';</script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  <meta name="docsearch:version" content="" />
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <dialog id="pst-search-dialog">
    
<form class="bd-search d-flex align-items-center"
      action="../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         placeholder="Search the docs ..."
         aria-label="Search the docs ..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form>
  </dialog>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
<div class="bd-header__inner bd-page-width">
  <button class="pst-navbar-icon sidebar-toggle primary-toggle" aria-label="Site navigation">
    <span class="fa-solid fa-bars"></span>
  </button>
  
  
  <div class="col-lg-3 navbar-header-items__start">
    
      <div class="navbar-item">

  
    
  

<a class="navbar-brand logo" href="../../index.html">
  
  
  
  
  
  
    <p class="title logo__title">GWADAMA 0.2.0 documentation</p>
  
</a></div>
    
  </div>
  
  <div class="col-lg-9 navbar-header-items">
    
    <div class="me-auto navbar-header-items__center">
      
        <div class="navbar-item">
<nav>
  <ul class="bd-navbar-elements navbar-nav">
    
  </ul>
</nav></div>
      
    </div>
    
    
    <div class="navbar-header-items__end">
      
        <div class="navbar-item navbar-persistent--container">
          

<button class="btn search-button-field search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
 <i class="fa-solid fa-magnifying-glass"></i>
 <span class="search-button__default-text">Search</span>
 <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
</button>
        </div>
      
      
        <div class="navbar-item">

<button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button pst-js-only" aria-label="Color mode" data-bs-title="Color mode"  data-bs-placement="bottom" data-bs-toggle="tooltip">
  <i class="theme-switch fa-solid fa-sun                fa-lg" data-mode="light" title="Light"></i>
  <i class="theme-switch fa-solid fa-moon               fa-lg" data-mode="dark"  title="Dark"></i>
  <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"  title="System Settings"></i>
</button></div>
      
    </div>
    
  </div>
  
  
    <div class="navbar-persistent--mobile">

<button class="btn search-button-field search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
 <i class="fa-solid fa-magnifying-glass"></i>
 <span class="search-button__default-text">Search</span>
 <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
</button>
    </div>
  

  
</div>

    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
        
      
      <dialog id="pst-primary-sidebar-modal"></dialog>
      <div id="pst-primary-sidebar" class="bd-sidebar-primary bd-sidebar hide-on-wide">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
      <div class="sidebar-header-items__center">
        
          
          
            <div class="navbar-item">
<nav>
  <ul class="bd-navbar-elements navbar-nav">
    
  </ul>
</nav></div>
          
        
      </div>
    
    
    
      <div class="sidebar-header-items__end">
        
          <div class="navbar-item">

<button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button pst-js-only" aria-label="Color mode" data-bs-title="Color mode"  data-bs-placement="bottom" data-bs-toggle="tooltip">
  <i class="theme-switch fa-solid fa-sun                fa-lg" data-mode="light" title="Light"></i>
  <i class="theme-switch fa-solid fa-moon               fa-lg" data-mode="dark"  title="Dark"></i>
  <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"  title="System Settings"></i>
</button></div>
        
      </div>
    
  </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
      <div class="sidebar-primary-item">
<div id="ethical-ad-placement"
      class="flat"
      data-ea-publisher="readthedocs"
      data-ea-type="readthedocs-sidebar"
      data-ea-manual="true">
</div></div>
  </div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        
          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item">

<nav aria-label="Breadcrumb" class="d-print-none">
  <ul class="bd-breadcrumbs">
    
    <li class="breadcrumb-item breadcrumb-home">
      <a href="../../index.html" class="nav-link" aria-label="Home">
        <i class="fa-solid fa-home"></i>
      </a>
    </li>
    
    <li class="breadcrumb-item"><a href="../index.html" class="nav-link">Module code</a></li>
    
    <li class="breadcrumb-item active" aria-current="page"><span class="ellipsis">gwadama.datasets</span></li>
  </ul>
</nav>
</div>
      
    </div>
  
  
</div>
</div>
              
              
              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <h1>Source code for gwadama.datasets</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;datasets.py</span>

<span class="sd">Main classes to manage GW datasets.</span>

<span class="sd">There are two basic type of datasets, clean and injected:</span>

<span class="sd">- Clean datasets&#39; classes inherit from the Base class, extending their properties</span>
<span class="sd">  as needed.</span>

<span class="sd">- Injected datasets&#39; classes inherit from the BaseInjected class, and</span>
<span class="sd">  optionally from other UserDefined(Base) classes.</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">deepcopy</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Callable</span>

<span class="c1"># from clawdia.estimators import find_merger  # Imported only when instancing CoReWaves.</span>
<span class="kn">from</span> <span class="nn">gwpy.timeseries</span> <span class="kn">import</span> <span class="n">TimeSeries</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">scipy</span> <span class="k">as</span> <span class="nn">sp</span>
<span class="kn">from</span> <span class="nn">scipy.interpolate</span> <span class="kn">import</span> <span class="n">make_interp_spline</span> <span class="k">as</span> <span class="n">sp_make_interp_spline</span>
<span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">train_test_split</span>
<span class="kn">from</span> <span class="nn">tqdm.auto</span> <span class="kn">import</span> <span class="n">tqdm</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">ioo</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">detectors</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">dictools</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">fat</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">synthetic</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">tat</span>
<span class="kn">from</span> <span class="nn">.units</span> <span class="kn">import</span> <span class="o">*</span>


<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Base&#39;</span><span class="p">,</span> <span class="s1">&#39;BaseInjected&#39;</span><span class="p">,</span> <span class="s1">&#39;SyntheticWaves&#39;</span><span class="p">,</span> <span class="s1">&#39;InjectedSyntheticWaves&#39;</span><span class="p">,</span>
           <span class="s1">&#39;CoReWaves&#39;</span><span class="p">,</span> <span class="s1">&#39;InjectedCoReWaves&#39;</span><span class="p">]</span>


<div class="viewcode-block" id="Base">
<a class="viewcode-back" href="../../gwadama.datasets.html#gwadama.datasets.Base">[docs]</a>
<span class="k">class</span> <span class="nc">Base</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Base class for all datasets.</span>

<span class="sd">    TODO: Update docstring.</span>

<span class="sd">    Any dataset made of &#39;clean&#39; (noiseless) GW must inherit this class.</span>
<span class="sd">    It is designed to store strains as nested dictionaries, with each level&#39;s</span>
<span class="sd">    key identifying a class/property of the strain. Each individual strain is a</span>
<span class="sd">    1D NDArray containing the features.</span>
<span class="sd">    </span>
<span class="sd">    By default there are two basic levels:</span>
<span class="sd">        </span>
<span class="sd">        - Class; to group up strains in categories.</span>
<span class="sd">        </span>
<span class="sd">        - Id; An unique identifier for each strain, which must exist in the</span>
<span class="sd">          metadata DataFrame as Index.</span>
<span class="sd">    </span>
<span class="sd">    Extra depths can be added, and will be thought of as modifications of the</span>
<span class="sd">    same original strains from the upper identifier level. If splitting the</span>
<span class="sd">    dataset into train and test susbsets, only combinations of (Class, Id) will</span>
<span class="sd">    be considered.</span>

<span class="sd">    NOTE: This class shall not be called directly. Use one of its subclasses.</span>
<span class="sd">    </span>
<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    classes : dict</span>
<span class="sd">        Dict of strings and their integer labels, one per class (category).</span>

<span class="sd">    metadata : pandas.DataFrame</span>
<span class="sd">        All parameters and data related to the strains.</span>
<span class="sd">        The order is the same as inside &#39;strains&#39; if unrolled to a flat list</span>
<span class="sd">        of strains up to the second depth level (the ID).</span>
<span class="sd">        The total number of different waves must be equal to `len(metadata)`;</span>
<span class="sd">        this does not include possible variations such polarizations or</span>
<span class="sd">        multiple scallings of the same waveform when performing injections.</span>
<span class="sd">    </span>
<span class="sd">    strains : dict[dict [...]]</span>
<span class="sd">        Strains stored as a nested dictionary, with each strain in an</span>
<span class="sd">        independent array to provide more flexibility with data of a wide</span>
<span class="sd">        range of lengths.</span>
<span class="sd">        </span>
<span class="sd">        - Shape: {class: {id: strain} }</span>
<span class="sd">        </span>
<span class="sd">        - The &#39;class&#39; key is the name of the class, a string which must exist</span>
<span class="sd">          in the &#39;classes&#39; list.</span>
<span class="sd">        </span>
<span class="sd">        - The &#39;id&#39; is a unique identifier for each strain, and must exist in</span>
<span class="sd">          the index of the &#39;metadata&#39; (DataFrame) attribute.</span>
<span class="sd">        </span>
<span class="sd">        - Extra depths can be added as variations of each strain, such as</span>
<span class="sd">          polarizations.</span>
<span class="sd">    </span>
<span class="sd">    labels : dict</span>
<span class="sd">        Class label of each wave ID, with shape {id: class_label}.</span>
<span class="sd">        Each ID points to the label of its class in the &#39;classes&#39; attribute.</span>
<span class="sd">        Can be automatically constructed by calling the &#39;_gen_labels()&#39; method.</span>
<span class="sd">    </span>
<span class="sd">    max_length : int</span>
<span class="sd">        Length of the longest strain in the dataset.</span>
<span class="sd">        Remember to update it if modifying the strains length.</span>
<span class="sd">    </span>
<span class="sd">    times : dict, optional</span>
<span class="sd">        Time samples associated with the strains, following the same structure</span>
<span class="sd">        up to the second depth level: {class: {id: time_points} }</span>
<span class="sd">        Useful when the sampling rate is variable or different between strains.</span>
<span class="sd">        If None, all strains are assumed to be constantly sampled to the</span>
<span class="sd">        sampling rate indicated by the &#39;sample_rate&#39; attribute.</span>
<span class="sd">    </span>
<span class="sd">    sample_rate : int, optional</span>
<span class="sd">        If the &#39;times&#39; attribute is present, this value is ignored. Otherwise</span>
<span class="sd">        it is assumed all strains are constantly sampled to this value.</span>
<span class="sd">        </span>
<span class="sd">        NOTE: If dealing with variable sampling rates, avoid setting this</span>
<span class="sd">        attribute to anything other than None.</span>
<span class="sd">    </span>
<span class="sd">    random_seed : int, optional</span>
<span class="sd">        Value passed to &#39;sklearn.model_selection.train_test_split&#39; to generate</span>
<span class="sd">        the Train and Test subsets. Saved for reproducibility purposes.</span>
<span class="sd">    </span>
<span class="sd">    Xtrain, Xtest : dict, optional</span>
<span class="sd">        Train and test subsets randomly split using SKLearn train_test_split</span>
<span class="sd">        function with stratified labels.</span>
<span class="sd">        Shape: {id: strain}.</span>
<span class="sd">        The &#39;id&#39; corresponds to the strain&#39;s index at &#39;self.metadata&#39;.</span>
<span class="sd">        They are just another views into the same data stored at &#39;self.strains&#39;,</span>
<span class="sd">        so no copies are performed.</span>
<span class="sd">    </span>
<span class="sd">    Ytrain, Ytest : NDArray[int], optional</span>
<span class="sd">        1D Array containing the labels in the same order as &#39;Xtrain&#39; and</span>
<span class="sd">        &#39;Xtest&#39; respectively.</span>
<span class="sd">        See the attribute &#39;labels&#39; for more info.</span>
<span class="sd">    </span>
<span class="sd">    Caveats</span>
<span class="sd">    -------</span>
<span class="sd">    - The additional depths in the strains nested dictionary can&#39;t be directly</span>
<span class="sd">      tracked by the metadata Dataframe.</span>
<span class="sd">    - If working with two polarizations, they can be stored with just an</span>
<span class="sd">      extra depth layer.</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="Base.__init__">
<a class="viewcode-back" href="../../gwadama.datasets.html#gwadama.datasets.Base.__init__">[docs]</a>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Overwrite when inheriting!&quot;&quot;&quot;</span>

        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Base class should not be called directly.&quot;</span><span class="p">)</span>

        <span class="c1">#----------------------------------------------------------------------</span>
        <span class="c1"># Attributes whose values must be set up during initialization.</span>
        <span class="c1">#----------------------------------------------------------------------</span>
    
        <span class="bp">self</span><span class="o">.</span><span class="n">strains</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">classes</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_classes_dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">classes</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gen_labels</span><span class="p">()</span>
        
        <span class="c1"># Number of nested layers in strains&#39; dictionary. Keep updated always:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dict_depth</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">dictools</span><span class="o">.</span><span class="n">get_depth</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">strains</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">max_length</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_max_length</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">random_seed</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># SKlearn train_test_split doesn&#39;t accept a Generator yet.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_track_times</span> <span class="o">=</span> <span class="kc">False</span>  <span class="c1"># If True, self.times must be not None.</span>

        <span class="c1">#----------------------------------------------------------------------</span>
        <span class="c1"># Attributes whose values can be set up or otherwise left as follows.</span>
        <span class="c1">#----------------------------------------------------------------------</span>

        <span class="c1"># Whitening related attributes.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">whitened</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">whiten_params</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nonwhiten_strains</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Time tracking related attributes.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sample_rate</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="kc">None</span>
        
        <span class="c1"># Train/Test subset splits (views into the same &#39;self.strains&#39;).</span>
        <span class="c1">#   Timeseries:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Xtrain</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Xtest</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1">#   Labels:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Ytrain</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Ytest</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span></div>


    <span class="k">def</span> <span class="nf">_check_classes_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">classes</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">]):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">classes</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;&#39;classes&#39; must be a dictionary&quot;</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">classes</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;&#39;classes&#39; keys must be strings&quot;</span><span class="p">)</span>
        
        <span class="n">labels</span> <span class="o">=</span> <span class="n">classes</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;&#39;classes&#39; values must be integers&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">labels</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">classes</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;classes&#39; values must be unique&quot;</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the total number of strains.&quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">dictools</span><span class="o">.</span><span class="n">get_number_of_elements</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">strains</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_gen_labels</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Constructs the labels&#39; dictionary.</span>

<span class="sd">        The labels attribute maps each ID to the integer value of its class,</span>
<span class="sd">        mapped in the &#39;classes&#39; attribute.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        labels : dict</span>
<span class="sd">            Shape {id: class_label} for each GW in the dataset.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">clas</span><span class="p">,</span> <span class="n">id_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">(</span><span class="n">max_depth</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
            <span class="n">labels</span><span class="p">[</span><span class="n">id_</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">classes</span><span class="p">[</span><span class="n">clas</span><span class="p">]</span>
        
        <span class="k">return</span> <span class="n">labels</span>

    <span class="k">def</span> <span class="nf">_init_strains_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">clas</span><span class="p">:</span> <span class="p">{}</span> <span class="k">for</span> <span class="n">clas</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">classes</span><span class="p">}</span>
    
    <span class="k">def</span> <span class="nf">_init_times_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">dictools</span><span class="o">.</span><span class="n">_replicate_structure_nested_dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">strains</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_find_max_length</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the length of the longest signal present in strains.&quot;&quot;&quot;</span>

        <span class="n">max_length</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="o">*</span><span class="n">_</span><span class="p">,</span> <span class="n">strain</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">l</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">strain</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">l</span> <span class="o">&gt;</span> <span class="n">max_length</span><span class="p">:</span>
                <span class="n">max_length</span> <span class="o">=</span> <span class="n">l</span>

        <span class="k">return</span> <span class="n">max_length</span>

    <span class="k">def</span> <span class="nf">_gen_times</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate the time arrays associated to the strains.</span>

<span class="sd">        Assumes a constant sampling rate.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        times : dict</span>
<span class="sd">            Nested dictionary with the same shape as &#39;self.strains&#39;.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_init_times_dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="o">*</span><span class="n">keys</span><span class="p">,</span> <span class="n">strain</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">strain</span><span class="p">)</span>
            <span class="n">t_end</span> <span class="o">=</span> <span class="p">(</span><span class="n">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_rate</span>
            <span class="n">time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">t_end</span><span class="p">,</span> <span class="n">length</span><span class="p">)</span>
            <span class="n">dictools</span><span class="o">.</span><span class="n">set_value_to_nested_dict</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">keys</span><span class="p">,</span> <span class="n">time</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">times</span>

<div class="viewcode-block" id="Base.keys">
<a class="viewcode-back" href="../../gwadama.datasets.html#gwadama.datasets.Base.keys">[docs]</a>
    <span class="k">def</span> <span class="nf">keys</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_depth</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the unrolled combinations of all strain identifiers.</span>

<span class="sd">        Return the unrolled combinations of all keys  of the nested dictionary</span>
<span class="sd">        of strains by a hierarchical recursive search.</span>
<span class="sd">        </span>
<span class="sd">        It can be thought of as the extended version of Python&#39;s</span>
<span class="sd">        &#39;dict().keys()&#39;, although this returns a plain list.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        max_depth : int, optional</span>
<span class="sd">            If specified, it is the number of layers to iterate to at most in</span>
<span class="sd">            the nested &#39;strains&#39; dictionary.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        keys : list</span>
<span class="sd">            The unrolled combination in a Python list.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">keys</span> <span class="o">=</span> <span class="n">dictools</span><span class="o">.</span><span class="n">unroll_nested_dictionary_keys</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">strains</span><span class="p">,</span> <span class="n">max_depth</span><span class="o">=</span><span class="n">max_depth</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">keys</span></div>


<div class="viewcode-block" id="Base.items">
<a class="viewcode-back" href="../../gwadama.datasets.html#gwadama.datasets.Base.items">[docs]</a>
    <span class="k">def</span> <span class="nf">items</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a new view of the dataset&#39;s items with unrolled indices.</span>

<span class="sd">        Each iteration consists on a tuple containing all the nested keys in</span>
<span class="sd">        &#39;self.strains&#39; along with the corresponding strain,</span>
<span class="sd">        (clas, id, *, strain).</span>
<span class="sd">        </span>
<span class="sd">        It can be thought of as an extension of Python&#39;s `dict.items()`.</span>
<span class="sd">        Useful to quickly iterate over all items in the dataset.</span>

<span class="sd">        Example of usage with an arbitrary number of keys in the nested</span>
<span class="sd">        dictionary of strains:</span>
<span class="sd">        </span>
<span class="sd">        ```</span>
<span class="sd">        for *keys, strain in self.items():</span>
<span class="sd">            print(f&quot;Number of identifiers: {len(keys)}&quot;)</span>
<span class="sd">            print(f&quot;Length of the strain: {len(strain)}&quot;)</span>
<span class="sd">            do_something(strain)</span>
<span class="sd">        ```</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">indices</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">yield</span> <span class="p">(</span><span class="o">*</span><span class="n">indices</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_strain</span><span class="p">(</span><span class="o">*</span><span class="n">indices</span><span class="p">))</span></div>


<div class="viewcode-block" id="Base.find_class">
<a class="viewcode-back" href="../../gwadama.datasets.html#gwadama.datasets.Base.find_class">[docs]</a>
    <span class="k">def</span> <span class="nf">find_class</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">id</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Find which &#39;class&#39; corresponds the strain &#39;id&#39;.</span>

<span class="sd">        Finds the &#39;class&#39; of the strain represented by the unique identifier</span>
<span class="sd">        &#39;id&#39;.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        id : str</span>
<span class="sd">            Unique identifier of the string, that which also appears in the</span>
<span class="sd">            `metadata.index` DataFrame.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        clas : int | str</span>
<span class="sd">            Class key associated to the strain &#39;id&#39;.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">dictools</span><span class="o">.</span><span class="n">_find_level0_of_level1</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">strains</span><span class="p">,</span> <span class="nb">id</span><span class="p">)</span></div>


<div class="viewcode-block" id="Base.get_strain">
<a class="viewcode-back" href="../../gwadama.datasets.html#gwadama.datasets.Base.get_strain">[docs]</a>
    <span class="k">def</span> <span class="nf">get_strain</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">indices</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get a single strain from the complete index coordinates.</span>
<span class="sd">        </span>
<span class="sd">        This is just a shortcut to avoid having to write several squared</span>
<span class="sd">        brackets.</span>

<span class="sd">        NOTE: The returned strain is not a copy; if its contents are modified,</span>
<span class="sd">        the changes will be reflected inside the &#39;strains&#39; attribute.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        *indices : str | int</span>
<span class="sd">            The indices of the strain to retrieve.</span>
<span class="sd">        </span>
<span class="sd">        normalize : bool</span>
<span class="sd">            If True, the returned strain will be normalized to its maximum</span>
<span class="sd">            amplitude.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        strain : np.ndarray</span>
<span class="sd">            The requested strain.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dict_depth</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;indices must match the depth of &#39;self.strains&#39;&quot;</span><span class="p">)</span>

        <span class="n">strain</span> <span class="o">=</span> <span class="n">dictools</span><span class="o">.</span><span class="n">get_value_from_nested_dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">strains</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">normalize</span><span class="p">:</span>
            <span class="n">strain</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">strain</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">strain</span></div>


<div class="viewcode-block" id="Base.get_strains_array">
<a class="viewcode-back" href="../../gwadama.datasets.html#gwadama.datasets.Base.get_strains_array">[docs]</a>
    <span class="k">def</span> <span class="nf">get_strains_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">length</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get all strains stacked in a zero-padded Numpy 2d-array.</span>

<span class="sd">        Stacks all signals into an homogeneous numpy array whose length</span>
<span class="sd">        (axis=1) is determined by either &#39;length&#39; or, if None, by the longest</span>
<span class="sd">        strain in the subset.</span>
<span class="sd">        The remaining space is zeroed.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        length : int, optional</span>
<span class="sd">            Target length of the &#39;strains_array&#39;. If None, the longest signal</span>
<span class="sd">            determines the length.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        strains_array : np.ndarray</span>
<span class="sd">            train subset.</span>
<span class="sd">        </span>
<span class="sd">        lengths : list</span>
<span class="sd">            Original length of each strain, following the same order as the</span>
<span class="sd">            first axis of &#39;train_array&#39;.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">strains_flat</span> <span class="o">=</span> <span class="n">dictools</span><span class="o">.</span><span class="n">flatten_nested_dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">strains</span><span class="p">)</span>
        <span class="n">strains_array</span><span class="p">,</span> <span class="n">lengths</span> <span class="o">=</span> <span class="n">dictools</span><span class="o">.</span><span class="n">dict_to_stacked_array</span><span class="p">(</span><span class="n">strains_flat</span><span class="p">,</span> <span class="n">target_length</span><span class="o">=</span><span class="n">length</span><span class="p">)</span> 

        <span class="k">return</span> <span class="n">strains_array</span><span class="p">,</span> <span class="n">lengths</span></div>


<div class="viewcode-block" id="Base.get_times">
<a class="viewcode-back" href="../../gwadama.datasets.html#gwadama.datasets.Base.get_times">[docs]</a>
    <span class="k">def</span> <span class="nf">get_times</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">indices</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get a single time array from the complete index coordinates.</span>
<span class="sd">        </span>
<span class="sd">        This is just a shortcut to avoid having to write several squared</span>
<span class="sd">        brackets.</span>

<span class="sd">        NOTE: The returned strain is not a copy; if its contents are modified,</span>
<span class="sd">        the changes will be reflected inside the &#39;times&#39; attribute.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>        
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dict_depth</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;indices must match the depth of &#39;self.strains&#39;&quot;</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">dictools</span><span class="o">.</span><span class="n">get_value_from_nested_dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span></div>


<div class="viewcode-block" id="Base.pad_strains">
<a class="viewcode-back" href="../../gwadama.datasets.html#gwadama.datasets.Base.pad_strains">[docs]</a>
    <span class="k">def</span> <span class="nf">pad_strains</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">padding</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">tuple</span> <span class="o">|</span> <span class="nb">dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Pad strains with zeros on both sides.</span>

<span class="sd">        This function pads each strain with a specific number of samples on both sides.</span>
<span class="sd">        It also updates the &#39;max_length&#39; attribute to reflect the new maximum length of the padded strains.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        padding : int | tuple | dict</span>
<span class="sd">            The padding to apply to each strain.</span>
<span class="sd">            If padding is an integer, it will be applied at both sides of all strains.</span>
<span class="sd">            If padding is a tuple, it must be of the form (left_pad, right_pad) in samples.</span>
<span class="sd">            If padding is a dictionary, it must be of the form {id: (left_pad, right_pad)},</span>
<span class="sd">            where id is the identifier of each strain.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - If time arrays are present, they are also padded accordingly.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">padding</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">padding_d</span> <span class="o">=</span> <span class="p">{</span><span class="nb">id</span><span class="p">:</span> <span class="p">(</span><span class="n">padding</span><span class="p">,</span> <span class="n">padding</span><span class="p">)</span> <span class="k">for</span> <span class="nb">id</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">index</span><span class="p">}</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">padding</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">padding_d</span> <span class="o">=</span> <span class="p">{</span><span class="nb">id</span><span class="p">:</span> <span class="n">padding</span> <span class="k">for</span> <span class="nb">id</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">index</span><span class="p">}</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">padding</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="n">padding_d</span> <span class="o">=</span> <span class="n">padding</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;padding must be an integer, a tuple or a dictionary&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">clas</span><span class="p">,</span> <span class="nb">id</span><span class="p">,</span> <span class="o">*</span><span class="n">keys</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">strain</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_strain</span><span class="p">(</span><span class="n">clas</span><span class="p">,</span> <span class="nb">id</span><span class="p">,</span> <span class="o">*</span><span class="n">keys</span><span class="p">)</span>
            <span class="n">left_pad</span><span class="p">,</span> <span class="n">right_pad</span> <span class="o">=</span> <span class="n">padding_d</span><span class="p">[</span><span class="nb">id</span><span class="p">]</span>
            
            <span class="c1"># Pad the strain</span>
            <span class="n">strain_padded</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">strain</span><span class="p">,</span> <span class="p">(</span><span class="n">left_pad</span><span class="p">,</span> <span class="n">right_pad</span><span class="p">),</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;constant&#39;</span><span class="p">)</span>
            <span class="n">dictools</span><span class="o">.</span><span class="n">set_value_to_nested_dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">strains</span><span class="p">,</span> <span class="p">[</span><span class="n">clas</span><span class="p">,</span> <span class="nb">id</span><span class="p">,</span> <span class="o">*</span><span class="n">keys</span><span class="p">],</span> <span class="n">strain_padded</span><span class="p">)</span>

            <span class="c1"># Pad the corresponding time array if time tracking is enabled</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_track_times</span><span class="p">:</span>
                <span class="n">times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_times</span><span class="p">(</span><span class="n">clas</span><span class="p">,</span> <span class="nb">id</span><span class="p">,</span> <span class="o">*</span><span class="n">keys</span><span class="p">)</span>
                <span class="n">time_step</span> <span class="o">=</span> <span class="p">(</span><span class="n">times</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">times</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">left_time_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">left_pad</span> <span class="o">*</span> <span class="n">time_step</span><span class="p">,</span> <span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">time_step</span><span class="p">)</span>
                <span class="n">right_time_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">times</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">time_step</span><span class="p">,</span> <span class="n">times</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">right_pad</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">time_step</span><span class="p">,</span> <span class="n">time_step</span><span class="p">)</span>
                <span class="n">times_padded</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">left_time_points</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> <span class="n">right_time_points</span><span class="p">])</span>
                <span class="n">dictools</span><span class="o">.</span><span class="n">set_value_to_nested_dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">,</span> <span class="p">[</span><span class="n">clas</span><span class="p">,</span> <span class="nb">id</span><span class="p">,</span> <span class="o">*</span><span class="n">keys</span><span class="p">],</span> <span class="n">times_padded</span><span class="p">)</span>

        <span class="c1"># Update the maximum strain length attribute</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_length</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_max_length</span><span class="p">()</span></div>


<div class="viewcode-block" id="Base.shrink_strains">
<a class="viewcode-back" href="../../gwadama.datasets.html#gwadama.datasets.Base.shrink_strains">[docs]</a>
    <span class="k">def</span> <span class="nf">shrink_strains</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">limits</span><span class="p">:</span> <span class="nb">tuple</span> <span class="o">|</span> <span class="nb">dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Shrink strains to a specific interval.</span>

<span class="sd">        Shrink strains (and their associated time arrays if present) to the</span>
<span class="sd">        interval given by &#39;limits&#39;.</span>
<span class="sd">        </span>
<span class="sd">        It also updates the &#39;max_length&#39; attribute.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        limits : tuple | dict</span>
<span class="sd">            The limits of the interval to shrink to.</span>
<span class="sd">            If limits is a tuple, it must be of the form (start, end) in</span>
<span class="sd">            samples.</span>
<span class="sd">            If limits is a dictionary, it must be of the form {id: (start, end)},</span>
<span class="sd">            where id is the identifier of each strain.</span>
<span class="sd">            </span>
<span class="sd">            NOTE: If extra layers below ID are present, they will be shrunk</span>
<span class="sd">            accordingly.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">limits</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">limits_d</span> <span class="o">=</span> <span class="p">{</span><span class="nb">id</span><span class="p">:</span> <span class="n">limits</span> <span class="k">for</span> <span class="nb">id</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">index</span><span class="p">}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">limits_d</span> <span class="o">=</span> <span class="n">limits</span>

        <span class="k">for</span> <span class="n">clas</span><span class="p">,</span> <span class="nb">id</span><span class="p">,</span> <span class="o">*</span><span class="n">keys</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">strain</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_strain</span><span class="p">(</span><span class="n">clas</span><span class="p">,</span> <span class="nb">id</span><span class="p">,</span> <span class="o">*</span><span class="n">keys</span><span class="p">)</span>
            <span class="c1"># Same shrinking limits for all possible strains below ID layer.</span>
            <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="n">limits_d</span><span class="p">[</span><span class="nb">id</span><span class="p">]</span>
            <span class="n">strain</span> <span class="o">=</span> <span class="n">strain</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">]</span>
            <span class="n">dictools</span><span class="o">.</span><span class="n">set_value_to_nested_dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">strains</span><span class="p">,</span> <span class="p">[</span><span class="n">clas</span><span class="p">,</span><span class="nb">id</span><span class="p">,</span><span class="o">*</span><span class="n">keys</span><span class="p">],</span> <span class="n">strain</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_track_times</span><span class="p">:</span>
                <span class="n">times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_times</span><span class="p">(</span><span class="n">clas</span><span class="p">,</span> <span class="nb">id</span><span class="p">,</span> <span class="o">*</span><span class="n">keys</span><span class="p">)</span>
                <span class="n">times</span> <span class="o">=</span> <span class="n">times</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">]</span>
                <span class="n">dictools</span><span class="o">.</span><span class="n">set_value_to_nested_dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">,</span> <span class="p">[</span><span class="n">clas</span><span class="p">,</span><span class="nb">id</span><span class="p">,</span><span class="o">*</span><span class="n">keys</span><span class="p">],</span> <span class="n">times</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">max_length</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_max_length</span><span class="p">()</span></div>


<div class="viewcode-block" id="Base.resample">
<a class="viewcode-back" href="../../gwadama.datasets.html#gwadama.datasets.Base.resample">[docs]</a>
    <span class="k">def</span> <span class="nf">resample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sample_rate</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Resample strain and time arrays to a constant rate.</span>

<span class="sd">        This assumes time tracking either with time arrays or with the</span>
<span class="sd">        sampling rate provided during initialization, which will be used to</span>
<span class="sd">        generate the time arrays previous to the resampling.</span>

<span class="sd">        This method updates the sample_rate and the max_length.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sample_rate : int</span>
<span class="sd">            The new sampling rate in Hz.</span>

<span class="sd">        verbose : bool</span>
<span class="sd">            If True, print information about the resampling.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Set up the time points associated to each strain in case it is not</span>
        <span class="c1"># provided.</span>
        <span class="c1">#</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_track_times</span><span class="p">:</span>
            <span class="n">times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">sample_rate</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_rate</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;trying to resample to the same sampling rate&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_rate</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;neither time samples nor a global sampling rate were defined&quot;</span><span class="p">)</span>
            
            <span class="bp">self</span><span class="o">.</span><span class="n">times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gen_times</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_track_times</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">for</span> <span class="o">*</span><span class="n">keys</span><span class="p">,</span> <span class="n">strain</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">time</span> <span class="o">=</span> <span class="n">dictools</span><span class="o">.</span><span class="n">get_value_from_nested_dict</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">keys</span><span class="p">)</span>
            <span class="n">strain_resampled</span><span class="p">,</span> <span class="n">time_resampled</span><span class="p">,</span> <span class="n">sf_up</span><span class="p">,</span> <span class="n">factor_down</span> <span class="o">=</span> <span class="n">tat</span><span class="o">.</span><span class="n">resample</span><span class="p">(</span>
                <span class="n">strain</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">sample_rate</span><span class="p">,</span> <span class="n">full_output</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span>
            <span class="n">dictools</span><span class="o">.</span><span class="n">set_value_to_nested_dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">strains</span><span class="p">,</span> <span class="n">keys</span><span class="p">,</span> <span class="n">strain_resampled</span><span class="p">)</span>
            <span class="n">dictools</span><span class="o">.</span><span class="n">set_value_to_nested_dict</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">keys</span><span class="p">,</span> <span class="n">time_resampled</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Strain </span><span class="si">{</span><span class="n">keys</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">::</span><span class="si">{</span><span class="n">keys</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2"> up. to </span><span class="si">{</span><span class="n">sf_up</span><span class="si">}</span><span class="s2"> Hz, down by factor </span><span class="si">{</span><span class="n">factor_down</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">sample_rate</span> <span class="o">=</span> <span class="n">sample_rate</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_length</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_max_length</span><span class="p">()</span></div>

    
<div class="viewcode-block" id="Base.whiten">
<a class="viewcode-back" href="../../gwadama.datasets.html#gwadama.datasets.Base.whiten">[docs]</a>
    <span class="k">def</span> <span class="nf">whiten</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
               <span class="n">asd_array</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
               <span class="n">pad</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
               <span class="n">highpass</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
               <span class="n">flength</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
               <span class="n">normed</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
               <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Whiten the strains.</span>
<span class="sd">        </span>
<span class="sd">        Calling this method performs the whitening of all strains.</span>
<span class="sd">        Optionally, strains are first zero-padded, whitened and then shrunk to</span>
<span class="sd">        their initial size. This is useful to remove the vignetting effect.</span>
<span class="sd">        </span>
<span class="sd">        NOTE: Original (non-whitened) strains will be stored in the</span>
<span class="sd">        &#39;nonwhiten_strains&#39; attribute.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">whitened</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;dataset already whitened&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">strains</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;no strains have been given or generated yet&quot;</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">nonwhiten_strains</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">strains</span><span class="p">)</span>
        
        <span class="n">loop_aux</span> <span class="o">=</span> <span class="n">tqdm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="n">total</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span> <span class="k">if</span> <span class="n">verbose</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="k">for</span> <span class="o">*</span><span class="n">keys</span><span class="p">,</span> <span class="n">strain</span> <span class="ow">in</span> <span class="n">loop_aux</span><span class="p">:</span>
            <span class="n">strain_w</span> <span class="o">=</span> <span class="n">fat</span><span class="o">.</span><span class="n">whiten</span><span class="p">(</span>
                <span class="n">strain</span><span class="p">,</span> <span class="n">asd</span><span class="o">=</span><span class="n">asd_array</span><span class="p">,</span> <span class="n">sample_rate</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_rate</span><span class="p">,</span> <span class="n">flength</span><span class="o">=</span><span class="n">flength</span><span class="p">,</span>
                <span class="n">highpass</span><span class="o">=</span><span class="n">highpass</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="n">pad</span><span class="p">,</span> <span class="n">normed</span><span class="o">=</span><span class="n">normed</span>
            <span class="p">)</span>
            <span class="c1"># Update strains attribute.</span>
            <span class="n">dictools</span><span class="o">.</span><span class="n">set_value_to_nested_dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">strains</span><span class="p">,</span> <span class="n">keys</span><span class="p">,</span> <span class="n">strain_w</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">whitened</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">whiten_params</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;asd_array&quot;</span><span class="p">:</span> <span class="n">asd_array</span><span class="p">,</span>
            <span class="s2">&quot;pad&quot;</span><span class="p">:</span> <span class="n">pad</span><span class="p">,</span>
            <span class="s2">&quot;highpass&quot;</span><span class="p">:</span> <span class="n">highpass</span><span class="p">,</span>
            <span class="s2">&quot;flength&quot;</span><span class="p">:</span> <span class="n">flength</span><span class="p">,</span>
            <span class="s2">&quot;normed&quot;</span><span class="p">:</span> <span class="n">normed</span>
        <span class="p">}</span>
        
        <span class="c1"># Update side-effect attributes.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">Xtrain</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_train_test_subsets</span><span class="p">()</span></div>


<div class="viewcode-block" id="Base.build_train_test_subsets">
<a class="viewcode-back" href="../../gwadama.datasets.html#gwadama.datasets.Base.build_train_test_subsets">[docs]</a>
    <span class="k">def</span> <span class="nf">build_train_test_subsets</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">train_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">float</span><span class="p">,</span> <span class="n">random_seed</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate a random Train and Test subsets.</span>

<span class="sd">        Only entries in the index of &#39;metadata&#39; DataFrame are considered</span>
<span class="sd">        independent waveforms, any extra key (layer) in the &#39;strains&#39; dict</span>
<span class="sd">        is treated monolithically during the shuffle.</span>
<span class="sd">        </span>
<span class="sd">        The strain values are just new views into the &#39;strains&#39; attribute.</span>
<span class="sd">        The shuffling is performed by Scikit-Learn&#39;s function</span>
<span class="sd">        &#39;train_test_split&#39;, with stratification enabled.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        train_size : int | float</span>
<span class="sd">            If float, should be between 0.0 and 1.0 and represent the proportion</span>
<span class="sd">            of the dataset to include in the train subset.</span>
<span class="sd">            If int, represents the absolute number of train waves.</span>
<span class="sd">            </span>
<span class="sd">            Ref: https://scikit-learn.org/stable/modules/generated/sklearn.model_selection.train_test_split.html</span>
<span class="sd">        </span>
<span class="sd">        random_seed : int, optional</span>
<span class="sd">            Passed directly to &#39;sklearn.model_selection.train_test_split&#39;.</span>
<span class="sd">            It is also saved in its homonymous attribute.</span>
<span class="sd">            </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
        <span class="n">i_train</span><span class="p">,</span> <span class="n">i_test</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span>
            <span class="n">indices</span><span class="p">,</span>
            <span class="n">train_size</span><span class="o">=</span><span class="n">train_size</span><span class="p">,</span>
            <span class="n">random_state</span><span class="o">=</span><span class="n">random_seed</span><span class="p">,</span>
            <span class="n">shuffle</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">stratify</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Xtrain</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Ytrain</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_build_subset_strains</span><span class="p">(</span><span class="n">i_train</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Xtest</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Ytest</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_build_subset_strains</span><span class="p">(</span><span class="n">i_test</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">random_seed</span> <span class="o">=</span> <span class="n">random_seed</span></div>

    
    <span class="k">def</span> <span class="nf">_build_subset_strains</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a subset of strains and their labels based on their ID.</span>

<span class="sd">        Return a new view into &#39;self.strains&#39; using the input indices (ID) as</span>
<span class="sd">        the first layer of the nested dictionary.</span>

<span class="sd">        This collapses the first layer, the class, leaving the unique</span>
<span class="sd">        identifier ID as first layer. Nevertheless, the rest of possible layers</span>
<span class="sd">        beneath &#39;ID&#39; are monolithically preserved.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        indices : array-like</span>
<span class="sd">            The indices are w.r.t. the Pandas &#39;self.metadata.index&#39;.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        strains : dict {id: strain}</span>
<span class="sd">            The id key is the strain&#39;s index at &#39;self.metadata&#39;.</span>
<span class="sd">        </span>
<span class="sd">        labels : NDArray</span>
<span class="sd">            1D Array containing the labels associated to &#39;strains&#39;.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">strains</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">id_</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">indices</span><span class="p">):</span>
            <span class="n">labels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">[</span><span class="n">id_</span><span class="p">]</span>
            <span class="n">clas</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_class</span><span class="p">(</span><span class="n">id_</span><span class="p">)</span>
            <span class="n">strains</span><span class="p">[</span><span class="n">id_</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">strains</span><span class="p">[</span><span class="n">clas</span><span class="p">][</span><span class="n">id_</span><span class="p">]</span>
        
        <span class="k">return</span> <span class="n">strains</span><span class="p">,</span> <span class="n">labels</span>

    <span class="k">def</span> <span class="nf">_update_train_test_subsets</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Builds again the Train/Test subsets from the main strains attribute.&quot;&quot;&quot;</span>

        <span class="n">id_train</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Xtrain</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="n">id_test</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Xtest</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Xtrain</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Ytrain</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_build_subset_strains</span><span class="p">(</span><span class="n">id_train</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Xtest</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Ytest</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_build_subset_strains</span><span class="p">(</span><span class="n">id_test</span><span class="p">)</span>
    
<div class="viewcode-block" id="Base.get_xtrain_array">
<a class="viewcode-back" href="../../gwadama.datasets.html#gwadama.datasets.Base.get_xtrain_array">[docs]</a>
    <span class="k">def</span> <span class="nf">get_xtrain_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">classes</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the train subset stacked in a zero-padded Numpy 2d-array.</span>

<span class="sd">        Stacks all signals in the train subset into an homogeneous numpy array</span>
<span class="sd">        whose length (axis=1) is determined by either &#39;length&#39; or, if None, by</span>
<span class="sd">        the longest strain in the subset. The remaining space is zeroed.</span>

<span class="sd">        Optionally, classes can be filtered by specifying which to include with</span>
<span class="sd">        the `classes` parameter.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        length : int, optional</span>
<span class="sd">            Target length of the &#39;train_array&#39;. If None, the longest signal</span>
<span class="sd">            determines the length.</span>

<span class="sd">        classes : str | List[str], optional</span>
<span class="sd">            Specify which classes to include. Include &#39;all&#39; by default.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        train_array : np.ndarray</span>
<span class="sd">            train subset.</span>
<span class="sd">        </span>
<span class="sd">        lengths : list</span>
<span class="sd">            Original length of each strain, following the same order as the</span>
<span class="sd">            first axis of &#39;train_array&#39;.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">train_subset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Xtrain</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">classes</span> <span class="o">!=</span> <span class="s1">&#39;all&#39;</span><span class="p">:</span>
            <span class="n">class_labels</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">classes</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">classes</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">class_int</span><span class="p">,</span> <span class="nb">id</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Ytrain</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">train_subset</span><span class="o">.</span><span class="n">keys</span><span class="p">())):</span>
                <span class="k">if</span> <span class="n">class_int</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">class_labels</span><span class="p">:</span>
                    <span class="k">del</span> <span class="n">train_subset</span><span class="p">[</span><span class="nb">id</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">dictools</span><span class="o">.</span><span class="n">dict_to_stacked_array</span><span class="p">(</span><span class="n">train_subset</span><span class="p">,</span> <span class="n">target_length</span><span class="o">=</span><span class="n">length</span><span class="p">)</span></div>

    
<div class="viewcode-block" id="Base.get_xtest_array">
<a class="viewcode-back" href="../../gwadama.datasets.html#gwadama.datasets.Base.get_xtest_array">[docs]</a>
    <span class="k">def</span> <span class="nf">get_xtest_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">classes</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the test subset stacked in a zero-padded Numpy 2d-array.</span>

<span class="sd">        Stacks all signals in the test subset into an homogeneous numpy array</span>
<span class="sd">        whose length (axis=1) is determined by either &#39;length&#39; or, if None, by</span>
<span class="sd">        the longest strain in the subset. The remaining space is zeroed.</span>

<span class="sd">        Optionally, classes can be filtered by specifying which to include with</span>
<span class="sd">        the `classes` parameter.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        length : int, optional</span>

<span class="sd">        classes : str | List[str], optional</span>
<span class="sd">            Specify which classes to include. Include &#39;all&#39; by default.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        test_array : np.ndarray</span>
<span class="sd">            test subset.</span>
<span class="sd">        </span>
<span class="sd">        lengths : list</span>
<span class="sd">            Original length of each strain, following the same order as the</span>
<span class="sd">            first axis of &#39;test_array&#39;.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">test_subset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Xtest</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">classes</span> <span class="o">!=</span> <span class="s1">&#39;all&#39;</span><span class="p">:</span>
            <span class="n">class_labels</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">classes</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">classes</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">class_int</span><span class="p">,</span> <span class="nb">id</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Ytest</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">test_subset</span><span class="o">.</span><span class="n">keys</span><span class="p">())):</span>
                <span class="k">if</span> <span class="n">class_int</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">class_labels</span><span class="p">:</span>
                    <span class="k">del</span> <span class="n">test_subset</span><span class="p">[</span><span class="nb">id</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">dictools</span><span class="o">.</span><span class="n">dict_to_stacked_array</span><span class="p">(</span><span class="n">test_subset</span><span class="p">,</span> <span class="n">target_length</span><span class="o">=</span><span class="n">length</span><span class="p">)</span></div>

    
<div class="viewcode-block" id="Base.get_ytrain_array">
<a class="viewcode-back" href="../../gwadama.datasets.html#gwadama.datasets.Base.get_ytrain_array">[docs]</a>
    <span class="k">def</span> <span class="nf">get_ytrain_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">classes</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">,</span> <span class="n">with_id</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">with_index</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the filtered training labels.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        classes : str | list[str] | &#39;all&#39;</span>
<span class="sd">            The classes to include in the labels.</span>
<span class="sd">            All classes are included by default.</span>

<span class="sd">        with_id : bool</span>
<span class="sd">            If True, return also the list of related IDs.</span>

<span class="sd">        with_index : bool</span>
<span class="sd">            If True, return also the related GLOBAL indices; w.r.t. the stacked</span>
<span class="sd">            arrays returned by &#39;get_xtrain_array&#39; WITHOUT filters.</span>
<span class="sd">            False by default.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        np.ndarray</span>
<span class="sd">            Filtered train labels.</span>

<span class="sd">        np.ndarray, optional</span>
<span class="sd">            IDs associated to the filtered train labels.</span>
<span class="sd">        </span>
<span class="sd">        np.ndarray, optional</span>
<span class="sd">            Indices associated to the filtered train labels.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filter_labels</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Ytrain</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Xtrain</span><span class="p">),</span> <span class="n">classes</span><span class="p">,</span>
            <span class="n">with_id</span><span class="o">=</span><span class="n">with_id</span><span class="p">,</span> <span class="n">with_index</span><span class="o">=</span><span class="n">with_index</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Base.get_ytest_array">
<a class="viewcode-back" href="../../gwadama.datasets.html#gwadama.datasets.Base.get_ytest_array">[docs]</a>
    <span class="k">def</span> <span class="nf">get_ytest_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">classes</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">,</span> <span class="n">with_id</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">with_index</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the filtered test labels.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        classes : str | list[str] | &#39;all&#39;</span>
<span class="sd">            The classes to include in the labels.</span>
<span class="sd">            All classes are included by default.</span>

<span class="sd">        with_id : bool</span>
<span class="sd">            If True, return also the list of related IDs.</span>

<span class="sd">        with_index : bool</span>
<span class="sd">            If True, return also the related GLOBAL indices; w.r.t. the stacked</span>
<span class="sd">            arrays returned by &#39;get_xtest_array&#39; WITHOUT filters.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        np.ndarray</span>
<span class="sd">            Filtered test labels.</span>

<span class="sd">        np.ndarray, optional</span>
<span class="sd">            IDs associated to the filtered test labels.</span>
<span class="sd">        </span>
<span class="sd">        np.ndarray, optional</span>
<span class="sd">            Indices associated to the filtered test labels.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filter_labels</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Ytest</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Xtest</span><span class="p">),</span> <span class="n">classes</span><span class="p">,</span>
            <span class="n">with_id</span><span class="o">=</span><span class="n">with_id</span><span class="p">,</span> <span class="n">with_index</span><span class="o">=</span><span class="n">with_index</span>
        <span class="p">)</span></div>

    
    <span class="k">def</span> <span class="nf">_filter_labels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">labels_id</span><span class="p">,</span> <span class="n">classes</span><span class="p">,</span> <span class="n">with_id</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">with_index</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Filter labels based on &#39;classes&#39;.</span>

<span class="sd">        This is a helper function for &#39;get_ytrain_array&#39; and &#39;get_ytest_array&#39;.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        labels : np.ndarray</span>
<span class="sd">            The array containing the labels.</span>
<span class="sd">        </span>
<span class="sd">        labels_id : list</span>
<span class="sd">            IDs associated to the labels.</span>
<span class="sd">        </span>
<span class="sd">        classes : str | list[str] | &#39;all&#39;</span>
<span class="sd">            The classes to include in the labels.</span>
<span class="sd">            All classes are included by default.</span>
<span class="sd">        </span>
<span class="sd">        with_id : bool</span>
<span class="sd">            If True, return also the related IDs.</span>
<span class="sd">            False by default.</span>

<span class="sd">        with_index : bool</span>
<span class="sd">            If True, return also the related indices w.r.t. the stacked array</span>
<span class="sd">            returned by &#39;_stack_subset&#39; given the strains related to &#39;labels&#39;</span>
<span class="sd">            WITHOUT filters.</span>
<span class="sd">            False by default.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        filtered_labels : np.ndarray</span>
<span class="sd">            Filtered labels.</span>

<span class="sd">        filtered_ids : np.ndarray, optional</span>
<span class="sd">            IDs associated to the filtered labels.</span>

<span class="sd">        filtered_indices : np.ndarray, optional</span>
<span class="sd">            Indices associated to the filtered labels.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">labels_id</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;labels&#39; and &#39;labels_id&#39; must have the same length.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">classes</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">classes</span> <span class="o">==</span> <span class="s1">&#39;all&#39;</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">labels</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">classes</span> <span class="o">=</span> <span class="p">[</span><span class="n">classes</span><span class="p">]</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">classes</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;&#39;classes&#39; must be a string or list of strings.&quot;</span><span class="p">)</span>
        
        <span class="n">filtered_labels</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">filtered_ids</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">filtered_indices</span> <span class="o">=</span> <span class="p">[]</span>
        
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">label</span><span class="p">,</span> <span class="nb">id</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">labels_id</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_class</span><span class="p">(</span><span class="nb">id</span><span class="p">)</span> <span class="ow">in</span> <span class="n">classes</span><span class="p">:</span>
                <span class="n">filtered_labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
                <span class="n">filtered_ids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">id</span><span class="p">)</span>
                <span class="n">filtered_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>  <span class="c1"># Indices w.r.t. the FILTERED set!!!</span>
        
        <span class="n">filtered_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">filtered_labels</span><span class="p">)</span>
        <span class="n">filtered_ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">filtered_ids</span><span class="p">)</span>
        <span class="n">filtered_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">filtered_indices</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">with_id</span> <span class="ow">and</span> <span class="n">with_index</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">filtered_labels</span><span class="p">,</span> <span class="n">filtered_ids</span><span class="p">,</span> <span class="n">filtered_indices</span>
        <span class="k">if</span> <span class="n">with_id</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">filtered_labels</span><span class="p">,</span> <span class="n">filtered_ids</span>
        <span class="k">if</span> <span class="n">with_index</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">filtered_labels</span><span class="p">,</span> <span class="n">filtered_indices</span>
        <span class="k">return</span> <span class="n">filtered_labels</span>
        
<div class="viewcode-block" id="Base.stack_by_id">
<a class="viewcode-back" href="../../gwadama.datasets.html#gwadama.datasets.Base.stack_by_id">[docs]</a>
    <span class="k">def</span> <span class="nf">stack_by_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">id_list</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">length</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Stack an subset of strains by their ID into a Numpy array.</span>

<span class="sd">        Stack an arbitrary selection of strains by their original ID into a</span>
<span class="sd">        zero-padded 2d-array. The resulting order is the same as the order of</span>
<span class="sd">        that in &#39;id_list&#39;.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        id_list : list</span>
<span class="sd">            The IDs of the strains to be stacked.</span>

<span class="sd">        length : int, optional</span>
<span class="sd">            The target length of the stacked array. If None, the longest signal</span>
<span class="sd">            determines the length.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        stacked_signals : np.ndarray</span>
<span class="sd">            The array containing the stacked strains.</span>

<span class="sd">        lengths : list</span>
<span class="sd">            The original lengths of each strain, following the same order as</span>
<span class="sd">            the first axis of &#39;stacked_signals&#39;.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - Unlike in &#39;get_xtrain_array&#39; and &#39;get_xtest_array&#39;, this method does</span>
<span class="sd">          not filter by &#39;classes&#39; since it would be redundant, as IDs are</span>
<span class="sd">          unique.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">id_list</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;&#39;id_list&#39; must be a list of IDs.&quot;</span><span class="p">)</span>

        <span class="c1"># Collapse the Class layer.</span>
        <span class="n">strains</span> <span class="o">=</span> <span class="p">{</span><span class="nb">id</span><span class="p">:</span> <span class="n">ds</span> <span class="k">for</span> <span class="n">sub_strains</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">strains</span><span class="o">.</span><span class="n">values</span><span class="p">()</span> <span class="k">for</span> <span class="nb">id</span><span class="p">,</span> <span class="n">ds</span> <span class="ow">in</span> <span class="n">sub_strains</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

        <span class="c1"># Filter out those not in the &#39;id_list&#39;.</span>
        <span class="n">strains</span> <span class="o">=</span> <span class="n">dictools</span><span class="o">.</span><span class="n">filter_nested_dict</span><span class="p">(</span><span class="n">strains</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">k</span><span class="p">:</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">id_list</span><span class="p">,</span> <span class="n">layer</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">strains</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">id_list</span><span class="p">)</span>

        <span class="c1"># Sort them to match the order in &#39;id_list&#39;.</span>
        <span class="n">strains</span> <span class="o">=</span> <span class="p">{</span><span class="nb">id</span><span class="p">:</span> <span class="n">strains</span><span class="p">[</span><span class="nb">id</span><span class="p">]</span> <span class="k">for</span> <span class="nb">id</span> <span class="ow">in</span> <span class="n">id_list</span><span class="p">}</span>

        <span class="n">strains</span> <span class="o">=</span> <span class="n">dictools</span><span class="o">.</span><span class="n">flatten_nested_dict</span><span class="p">(</span><span class="n">strains</span><span class="p">)</span>
        <span class="n">stacked_signals</span><span class="p">,</span> <span class="n">lengths</span> <span class="o">=</span> <span class="n">dictools</span><span class="o">.</span><span class="n">dict_to_stacked_array</span><span class="p">(</span><span class="n">strains</span><span class="p">,</span> <span class="n">target_length</span><span class="o">=</span><span class="n">length</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">stacked_signals</span><span class="p">,</span> <span class="n">lengths</span></div>
</div>


        


<div class="viewcode-block" id="BaseInjected">
<a class="viewcode-back" href="../../gwadama.datasets.html#gwadama.datasets.BaseInjected">[docs]</a>
<span class="k">class</span> <span class="nc">BaseInjected</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Manage an injected dataset with multiple SNR values.</span>

<span class="sd">    It is designed to store strains as nested dictionaries, with each level&#39;s</span>
<span class="sd">    key identifying a class/property of the strain. Each individual strain is a</span>
<span class="sd">    1D NDArray containing the features.</span>

<span class="sd">    NOTE: Instances of this class or any other Class(BaseInjected) are</span>
<span class="sd">    initialized from an instance of any Class(Base) instance (clean dataset).</span>
<span class="sd">    </span>
<span class="sd">    By default there are THREE basic levels:</span>
<span class="sd">        </span>
<span class="sd">        - Class; to group up strains in categories.</span>
<span class="sd">        </span>
<span class="sd">        - Id; An unique identifier for each strain, which must exist in the</span>
<span class="sd">          metadata DataFrame as Index.</span>
<span class="sd">        </span>
<span class="sd">        - SNR; the signal-to-noise ratio at which has been injected w.r.t. a</span>
<span class="sd">          power spectral density of reference (e.g. the sensitivity of a GW</span>
<span class="sd">          detector).</span>
<span class="sd">    </span>
<span class="sd">    An extra depth can be added below, and will be treated as multiple</span>
<span class="sd">    injections at the same SNR value. This is usfeul for example to make</span>
<span class="sd">    injections at multiple noise realizations.</span>


<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    classes : list[str]</span>
<span class="sd">        List of labels, one per class (category).</span>
<span class="sd">    </span>
<span class="sd">    metadata : pandas.DataFrame</span>
<span class="sd">        All parameters and data related to the original strains, inherited</span>
<span class="sd">        (copied) from a clean Class(Base) instance.</span>
<span class="sd">        The order is the same as inside &#39;strains&#39; if unrolled to a flat list</span>
<span class="sd">        of strains up to the second depth level (the ID).</span>
<span class="sd">        The total number of different waves must be equal to `len(metadata)`;</span>
<span class="sd">        this does not include possible variations such polarizations or</span>
<span class="sd">        multiple scallings of the same waveform when performing injections.</span>
<span class="sd">    </span>
<span class="sd">    strains_clean : dict[dict]</span>
<span class="sd">        Strains inherited (copied) from a clean Class(Base) instance.</span>
<span class="sd">        This copy is kept in order to perform new injections.</span>
<span class="sd">        </span>
<span class="sd">        - Shape: {class: {id: strain} }</span>
<span class="sd">        </span>
<span class="sd">        - The &#39;class&#39; key is the name of the class, a string which must exist</span>
<span class="sd">          in the &#39;classes&#39; list.</span>
<span class="sd">        </span>
<span class="sd">        - The &#39;id&#39; is a unique identifier for each strain, and must exist in</span>
<span class="sd">          the index of the &#39;metadata&#39; (DataFrame) attribute.</span>
<span class="sd">        </span>
<span class="sd">        NOTE: These strains should be not modified. If new clean strains are</span>
<span class="sd">        needed, create a new clean dataset instance first, and then initialise</span>
<span class="sd">        this class with it.</span>

<span class="sd">        TODO: Accept extra layers in the clean_strains dictionary.</span>
<span class="sd">    </span>
<span class="sd">    strains : dict[dict]</span>
<span class="sd">        Injected trains stored as a nested dictionary, with each strain in an</span>
<span class="sd">        independent array to provide more flexibility with data of a wide</span>
<span class="sd">        range of lengths.</span>
<span class="sd">        </span>
<span class="sd">        - Shape: {class: {id: {snr: strain} } }</span>
<span class="sd">        </span>
<span class="sd">        - The &#39;class&#39; key is the name of the class, a string which must exist</span>
<span class="sd">          in the &#39;classes&#39; list.</span>
<span class="sd">        </span>
<span class="sd">        - The &#39;id&#39; is a unique identifier for each strain, and must exist in</span>
<span class="sd">          the index of the &#39;metadata&#39; (DataFrame) attribute.</span>
<span class="sd">        </span>
<span class="sd">        - The &#39;snr&#39; key is an integer indicating the signal-to-noise ratio of</span>
<span class="sd">          the injection.</span>

<span class="sd">        - A fourth depth can be added below as additional injections per SNR.</span>
<span class="sd">        </span>
<span class="sd">    labels : dict</span>
<span class="sd">        Indices of the class of each wave ID, inherited from a clean</span>
<span class="sd">        Class(Base) instance, with shape {id: class_index}.</span>
<span class="sd">        Each ID points to the index of its class in the &#39;classes&#39; attribute.</span>
<span class="sd">    </span>
<span class="sd">    units : str</span>
<span class="sd">        Flag indicating whether the data is in &#39;geometrized&#39; or &#39;IS&#39; units.</span>

<span class="sd">    times : dict, optional</span>
<span class="sd">        Time samples associated with the strains, following the same structure.</span>
<span class="sd">        Useful when the sampling rate is variable or different between strains.</span>
<span class="sd">        If None, all strains are assumed to be constantly sampled to the</span>
<span class="sd">        sampling rate indicated by the &#39;sample_rate&#39; attribute.</span>
<span class="sd">    </span>
<span class="sd">    sample_rate : int</span>
<span class="sd">        Inherited from the parent Class(Base) instance.</span>
<span class="sd">    </span>
<span class="sd">    max_length : int</span>
<span class="sd">        Length of the longest strain in the dataset.</span>
<span class="sd">        Remember to update it if manually changing strains&#39; length.</span>
<span class="sd">    </span>
<span class="sd">    random_seed : int</span>
<span class="sd">        Value passed to &#39;sklearn.model_selection.train_test_split&#39; to generate</span>
<span class="sd">        the Train and Test subsets. Saved for reproducibility purposes.</span>
<span class="sd">        Also used to initialize Numpy&#39;s default RandomGenerator.</span>

<span class="sd">    rng : np.random.Generator</span>
<span class="sd">        Random number generator used for sampling the background noise.</span>
<span class="sd">        Initialized with `np.random.default_rng(random_seed)`.</span>

<span class="sd">    detector : str</span>
<span class="sd">        GW detector name.</span>

<span class="sd">    psd_ : NDArray</span>
<span class="sd">        Numerical representation of the Power Spectral Density (PSD) of the</span>
<span class="sd">        detector&#39;s sensitivity.</span>
<span class="sd">    </span>
<span class="sd">    asd_ : NDArray</span>
<span class="sd">        Numerical representation of the Amplitude Spectral Density (ASD) of the</span>
<span class="sd">        detector&#39;s sensitivity.</span>

<span class="sd">    noise : gwadama.synthetic.NonwhiteGaussianNoise</span>
<span class="sd">        Background noise instance from NonwhiteGaussianNoise.</span>

<span class="sd">    snr_list : list</span>
<span class="sd">        List of SNR values at which each signal has been injected.</span>

<span class="sd">    pad : dict</span>
<span class="sd">        Padding introduced at each SNR injection, used in case the strains will</span>
<span class="sd">        be whitened after, to remove the vigneting at edges.</span>
<span class="sd">        It is associated to SNR values because the only implemented way to</span>
<span class="sd">        pad the signals is during the signal injection.</span>

<span class="sd">    injections_per_snr : int</span>
<span class="sd">        Number of injections per SNR value.</span>
<span class="sd">    </span>
<span class="sd">    whitened : bool</span>
<span class="sd">        Flat indicating whether the dataset has been whitened. Initially will</span>
<span class="sd">        be set to False, and changed to True after calling the &#39;whiten&#39; method.</span>
<span class="sd">        Once whitened, this flag will remain True, since the whitening is</span>
<span class="sd">        implemented to be irreversible instance-wise.</span>
<span class="sd">    </span>
<span class="sd">    whiten_params : dict</span>
<span class="sd">        TODO</span>

<span class="sd">        freq_cutoff : int | float</span>
<span class="sd">            Frequency cutoff below which no noise bins will be generated in the</span>
<span class="sd">            frequency space, and also used for the high-pass filter applied to</span>
<span class="sd">            clean signals before injection.</span>

<span class="sd">        freq_butter_order : int</span>
<span class="sd">            Butterworth filter order.</span>
<span class="sd">            See (https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.butter.html)</span>
<span class="sd">            for more information.</span>

<span class="sd">    Xtrain, Xtest : dict, optional</span>
<span class="sd">        Train and test subsets randomly split using SKLearn train_test_split</span>
<span class="sd">        function with stratified labels.</span>
<span class="sd">        Shape adds the SNR layer: {id: {snr: strain}}.</span>
<span class="sd">        The &#39;id&#39; corresponds to the strain&#39;s index at &#39;self.metadata&#39;.</span>
<span class="sd">    </span>
<span class="sd">    Ytrain, Ytest : NDArray[int], optional</span>
<span class="sd">        1D Array containing the labels in the same order as &#39;Xtrain&#39; and</span>
<span class="sd">        &#39;Xtest&#39; respectively.</span>
<span class="sd">        </span>
<span class="sd">        NOTE: Does not include the SNR layer, therefore labels are not repeated.</span>

<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="BaseInjected.__init__">
<a class="viewcode-back" href="../../gwadama.datasets.html#gwadama.datasets.BaseInjected.__init__">[docs]</a>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">clean_dataset</span><span class="p">:</span> <span class="n">Base</span><span class="p">,</span>
                 <span class="o">*</span><span class="p">,</span>
                 <span class="n">psd</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="n">Callable</span><span class="p">,</span>
                 <span class="n">detector</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                 <span class="n">noise_length</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                 <span class="n">freq_cutoff</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">float</span><span class="p">,</span>
                 <span class="n">freq_butter_order</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">float</span><span class="p">,</span>
                 <span class="n">whiten_params</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">random_seed</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Base constructor for injected datasets.</span>

<span class="sd">        TODO: Update docstring.</span>

<span class="sd">        When inheriting from this class, it is recommended to run this method</span>
<span class="sd">        first in your __init__ function.</span>

<span class="sd">        Relevant attributes are inherited from the &#39;clean_dataset&#39; instance,</span>
<span class="sd">        which can be any inherited from BaseDataset whose strains have not</span>
<span class="sd">        been injected yet.</span>

<span class="sd">        If train/test subsets are present, they too are updated when performing</span>
<span class="sd">        injections or changing units, but only through re-building them from</span>
<span class="sd">        the main &#39;strains&#39; attribute using the already generated indices.</span>
<span class="sd">        Original train/test subsets from the clean dataset are not inherited.</span>
<span class="sd">        </span>
<span class="sd">        WARNING: Initializing this class does not perform the injections! For</span>
<span class="sd">        that use the method &#39;gen_injections&#39;.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        clean_dataset : Base</span>
<span class="sd">            Instance of a Class(Base) with noiseless signals.</span>

<span class="sd">        psd : np.ndarray | Callable</span>
<span class="sd">            Power Spectral Density of the detector&#39;s sensitivity in the range</span>
<span class="sd">            of frequencies of interest. Can be given as a callable function</span>
<span class="sd">            whose argument is expected to be an array of frequencies, or as a</span>
<span class="sd">            2d-array with shape (2, psd_length) so that</span>
<span class="sd">            </span>
<span class="sd">            ```</span>
<span class="sd">            psd[0] = frequency_samples</span>
<span class="sd">            psd[1] = psd_samples</span>
<span class="sd">            ```.</span>
<span class="sd">            </span>
<span class="sd">            NOTE: It is also used to compute the &#39;asd&#39; attribute (ASD).</span>

<span class="sd">        detector : str</span>
<span class="sd">            GW detector name.</span>
<span class="sd">            Not used, just for identification.</span>

<span class="sd">        noise_length : int</span>
<span class="sd">            Length of the background noise array to be generated for later use.</span>
<span class="sd">            It should be at least longer than the longest signal expected to be</span>
<span class="sd">            injected.</span>

<span class="sd">        freq_cutoff : int | float</span>
<span class="sd">            Frequency cutoff below which no noise bins will be generated in the</span>
<span class="sd">            frequency space, and also used for the high-pass filter applied to</span>
<span class="sd">            clean signals before injection.</span>

<span class="sd">        freq_butter_order : int | float</span>
<span class="sd">            Butterworth filter order.</span>
<span class="sd">            See (https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.butter.html)</span>
<span class="sd">            for more information.</span>
<span class="sd">        </span>
<span class="sd">        flength : int</span>
<span class="sd">            Length (in samples) of the time-domain FIR whitening filter.</span>

<span class="sd">        whiten_params : dict, optional</span>
<span class="sd">            Parameters of the whitening filter, with the following entries:</span>
<span class="sd">            </span>
<span class="sd">            - &#39;flength&#39; : int</span>
<span class="sd">                Length (in samples) of the time-domain FIR whitening.</span>
<span class="sd">            </span>
<span class="sd">            - &#39;highpass&#39; : float</span>
<span class="sd">                Frequency cutoff.</span>
<span class="sd">            </span>
<span class="sd">            - &#39;normed&#39; : bool</span>
<span class="sd">                Normalization applied after the whitening filter.</span>

<span class="sd">        random_seed : int, optional</span>
<span class="sd">            Value passed to &#39;sklearn.model_selection.train_test_split&#39; to</span>
<span class="sd">            generate the Train and Test subsets.</span>
<span class="sd">            Saved for reproducibility purposes, and also used to initialize</span>
<span class="sd">            Numpy&#39;s default RandomGenerator.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Inherit clean strain instance attributes.</span>
        <span class="c1">#----------------------------------------------------------------------</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">classes</span> <span class="o">=</span> <span class="n">clean_dataset</span><span class="o">.</span><span class="n">classes</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_classes_dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">classes</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">labels</span> <span class="o">=</span> <span class="n">clean_dataset</span><span class="o">.</span><span class="n">labels</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">clean_dataset</span><span class="o">.</span><span class="n">metadata</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">strains_clean</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">clean_dataset</span><span class="o">.</span><span class="n">strains</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_track_times</span> <span class="o">=</span> <span class="n">clean_dataset</span><span class="o">.</span><span class="n">_track_times</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_track_times</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">times</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">clean_dataset</span><span class="o">.</span><span class="n">times</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sample_rate</span> <span class="o">=</span> <span class="n">clean_dataset</span><span class="o">.</span><span class="n">sample_rate</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_length</span> <span class="o">=</span> <span class="n">clean_dataset</span><span class="o">.</span><span class="n">max_length</span>

        <span class="c1"># Noise instance and related attributes.</span>
        <span class="c1">#----------------------------------------------------------------------</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">random_seed</span> <span class="o">=</span> <span class="n">random_seed</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">default_rng</span><span class="p">(</span><span class="n">random_seed</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">detector</span> <span class="o">=</span> <span class="n">detector</span>
        <span class="c1"># Highpass parameters applied when generating the noise array.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">freq_cutoff</span> <span class="o">=</span> <span class="n">freq_cutoff</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">freq_butter_order</span> <span class="o">=</span> <span class="n">freq_butter_order</span>
    
        <span class="bp">self</span><span class="o">.</span><span class="n">_psd</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">psd_array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_setup_psd</span><span class="p">(</span><span class="n">psd</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_asd</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">asd_array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_setup_asd_from_psd</span><span class="p">(</span><span class="n">psd</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">noise</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_generate_background_noise</span><span class="p">(</span><span class="n">noise_length</span><span class="p">)</span>

        <span class="c1"># Injection related:</span>
        <span class="c1">#----------------------------------------------------------------------</span>

        <span class="c1"># TODO: Implement the case when clean_dataset is already whitened?</span>
        <span class="c1"># It should mark it and use the clean copy of nonwhitened data instead.</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">strains</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dict_depth</span> <span class="o">=</span> <span class="n">clean_dataset</span><span class="o">.</span><span class="n">_dict_depth</span> <span class="o">+</span> <span class="mi">1</span>  <span class="c1"># Depth of the strains dict.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">snr_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pad</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># {snr: pad}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">injections_per_snr</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># Default value.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">whitened</span> <span class="o">=</span> <span class="kc">False</span>  <span class="c1"># Switched to True after calling self.whiten().</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">whiten_params</span> <span class="o">=</span> <span class="n">whiten_params</span>
        <span class="c1"># NOTE: I designed this while building the InjectedCoReWaves class, so</span>
        <span class="c1"># chances are this is not general enough.</span>
        <span class="k">if</span> <span class="n">whiten_params</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">whiten_params</span><span class="o">.</span><span class="n">update</span><span class="p">({</span>
                <span class="s1">&#39;asd_array&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">asd_array</span><span class="p">,</span>  <span class="c1"># Referenced here again for consistency.</span>
                <span class="s1">&#39;pad&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>  <span class="c1"># Signals are expected to be already padded.</span>
                <span class="s1">&#39;unpad&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">pad</span><span class="p">,</span>  <span class="c1"># Referenced here again for consistency.</span>
                <span class="s1">&#39;highpass&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">freq_cutoff</span>  <span class="c1"># Referenced here again for consistency.</span>
            <span class="p">})</span>

        <span class="c1"># Train/Test subset views:</span>
        <span class="c1">#----------------------------------------------------------------------</span>

        <span class="k">if</span> <span class="n">clean_dataset</span><span class="o">.</span><span class="n">Xtrain</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Xtrain</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">clean_dataset</span><span class="o">.</span><span class="n">Xtrain</span><span class="o">.</span><span class="n">keys</span><span class="p">()}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Xtest</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">clean_dataset</span><span class="o">.</span><span class="n">Xtest</span><span class="o">.</span><span class="n">keys</span><span class="p">()}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Ytrain</span> <span class="o">=</span> <span class="n">clean_dataset</span><span class="o">.</span><span class="n">Ytrain</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Ytest</span> <span class="o">=</span> <span class="n">clean_dataset</span><span class="o">.</span><span class="n">Ytest</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Xtrain</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Xtest</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Ytrain</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Ytest</span> <span class="o">=</span> <span class="kc">None</span></div>

    
    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Avoid error when trying to pickle PSD and ASD interpolants.</span>
<span class="sd">        </span>
<span class="sd">        Turns out Pickle tries to serialize the PSD and ASD interpolants,</span>
<span class="sd">        however Pickle is not able to serialize encapsulated functions.</span>
<span class="sd">        This is solved by removing said functions and computing the</span>
<span class="sd">        interpolants from their array representations when unpickling.</span>

<span class="sd">        NOTE: The loss of accuracy over repeated (de)serialization using this</span>
<span class="sd">        method has not been studied, use at your own discretion.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">del</span> <span class="n">state</span><span class="p">[</span><span class="s1">&#39;_psd&#39;</span><span class="p">]</span>
        <span class="k">del</span> <span class="n">state</span><span class="p">[</span><span class="s1">&#39;_asd&#39;</span><span class="p">]</span>
        
        <span class="k">return</span> <span class="n">state</span>
    
    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Avoid error when trying to unpickle PSD and ASD interpolants.</span>
<span class="sd">        </span>
<span class="sd">        Turns out Pickle tries to serialize the PSD and ASD interpolants,</span>
<span class="sd">        however Pickle is not able to serialize encapsulated functions.</span>
<span class="sd">        This is solved by removing said functions and computing the</span>
<span class="sd">        interpolants from their array representations when unpickling.</span>
<span class="sd">        </span>
<span class="sd">        NOTE: The loss of accuracy over repeated (de)serialization using this</span>
<span class="sd">        method has not been studied, use at your own discretion.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_psd</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_setup_psd</span><span class="p">(</span><span class="n">state</span><span class="p">[</span><span class="s1">&#39;psd_array&#39;</span><span class="p">])</span>
        <span class="n">_asd</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_setup_asd_from_psd</span><span class="p">(</span><span class="n">state</span><span class="p">[</span><span class="s1">&#39;psd_array&#39;</span><span class="p">])</span>
        <span class="n">state</span><span class="p">[</span><span class="s1">&#39;_psd&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_psd</span>
        <span class="n">state</span><span class="p">[</span><span class="s1">&#39;_asd&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_asd</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">_setup_psd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">psd</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="n">Callable</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Callable</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Setup the PSD function or array depending on the input.</span>
<span class="sd">        </span>
<span class="sd">        Setup the power spectral density function and array from any of those.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">callable</span><span class="p">(</span><span class="n">psd</span><span class="p">):</span>
            <span class="n">psd_fun</span> <span class="o">=</span> <span class="n">psd</span>
            <span class="c1"># Compute a realization of the PSD function with 16 bins per</span>
            <span class="c1"># integer frequency to ensure the numerical representation has</span>
            <span class="c1"># enough precision.</span>
            <span class="n">freqs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_rate</span><span class="o">//</span><span class="mi">2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_rate</span><span class="o">*</span><span class="mi">8</span><span class="p">)</span>
            <span class="n">psd_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">freqs</span><span class="p">,</span> <span class="n">psd</span><span class="p">(</span><span class="n">freqs</span><span class="p">)])</span>
        
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">psd</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="c1"># Build a spline quadratic interpolant for the input PSD array.</span>
            <span class="n">psd_fun</span> <span class="o">=</span> <span class="n">sp_make_interp_spline</span><span class="p">(</span><span class="n">psd</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">psd</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">k</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">psd_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">psd</span><span class="p">)</span>
        
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;&#39;psd&#39; type not recognized&quot;</span><span class="p">)</span>
            
        <span class="k">return</span> <span class="n">psd_fun</span><span class="p">,</span> <span class="n">psd_array</span>

    <span class="k">def</span> <span class="nf">_setup_asd_from_psd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">psd</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Setup the ASD function or array depending on the input.</span>
<span class="sd">        </span>
<span class="sd">        Setup the amplitude spectral density function and array from any of</span>
<span class="sd">        those.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">callable</span><span class="p">(</span><span class="n">psd</span><span class="p">):</span>
            <span class="n">asd_fun</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">f</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">psd</span><span class="p">)</span>
            <span class="c1"># Compute a realization of the ASD function with 16 bins per</span>
            <span class="c1"># integer frequency to ensure the numerical representation has</span>
            <span class="c1"># enough precision.</span>
            <span class="n">freqs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_rate</span><span class="o">//</span><span class="mi">2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_rate</span><span class="o">*</span><span class="mi">8</span><span class="p">)</span>
            <span class="n">asd_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">freqs</span><span class="p">,</span> <span class="n">asd_fun</span><span class="p">(</span><span class="n">freqs</span><span class="p">)])</span>
        
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">psd</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="c1"># Build a spline quadratic interpolant for the input ASD array.</span>
            <span class="n">asd_array</span> <span class="o">=</span> <span class="n">psd</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">asd_array</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">psd</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">asd_fun</span> <span class="o">=</span> <span class="n">sp_make_interp_spline</span><span class="p">(</span><span class="n">asd_array</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">asd_array</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">k</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;&#39;psd&#39; type not recognized&quot;</span><span class="p">)</span>
            
        <span class="k">return</span> <span class="n">asd_fun</span><span class="p">,</span> <span class="n">asd_array</span>

<div class="viewcode-block" id="BaseInjected.psd">
<a class="viewcode-back" href="../../gwadama.datasets.html#gwadama.datasets.BaseInjected.psd">[docs]</a>
    <span class="k">def</span> <span class="nf">psd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">frequencies</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">[</span><span class="nb">float</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">[</span><span class="nb">float</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Power spectral density (PSD) of the detector at given frequencies.</span>

<span class="sd">        Interpolates the PSD at the given frequencies from their array</span>
<span class="sd">        representation. If during initialization the PSD was given as its</span>
<span class="sd">        array representation, the interpolant is computed using SciPy&#39;s</span>
<span class="sd">        quadratic spline interpolant function.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_psd</span><span class="p">(</span><span class="n">frequencies</span><span class="p">)</span></div>


<div class="viewcode-block" id="BaseInjected.asd">
<a class="viewcode-back" href="../../gwadama.datasets.html#gwadama.datasets.BaseInjected.asd">[docs]</a>
    <span class="k">def</span> <span class="nf">asd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">frequencies</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">[</span><span class="nb">float</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">[</span><span class="nb">float</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Amplitude spectral density (ASD) of the detector at given frequencies.</span>

<span class="sd">        Interpolates the ASD at the given frequencies from their array</span>
<span class="sd">        representation. If during initialization the ASD was given as its</span>
<span class="sd">        array representation, the interpolant is computed using SciPy&#39;s</span>
<span class="sd">        quadratic spline interpolant function.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_asd</span><span class="p">(</span><span class="n">frequencies</span><span class="p">)</span></div>

    
    <span class="k">def</span> <span class="nf">_generate_background_noise</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">noise_length</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">synthetic</span><span class="o">.</span><span class="n">NonwhiteGaussianNoise</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The noise realization is generated by NonwhiteGaussianNoise.&quot;&quot;&quot;</span>

        <span class="n">d</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">noise_length</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_rate</span>
        <span class="n">noise</span> <span class="o">=</span> <span class="n">synthetic</span><span class="o">.</span><span class="n">NonwhiteGaussianNoise</span><span class="p">(</span>
            <span class="n">duration</span><span class="o">=</span><span class="n">d</span><span class="p">,</span> <span class="n">psd</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">psd</span><span class="p">,</span> <span class="n">sample_rate</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_rate</span><span class="p">,</span>
            <span class="n">rng</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">rng</span><span class="p">,</span> <span class="n">freq_cutoff</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">freq_cutoff</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">noise</span>
    
    <span class="k">def</span> <span class="nf">_init_strains_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="nb">dict</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initializes the nested dictionary of strains.</span>
<span class="sd">        </span>
<span class="sd">        Initializes the nested dictionary of strains following the hierarchy</span>
<span class="sd">        in the clean strains attribute, and adding the SNR layer.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">strains_dict</span> <span class="o">=</span> <span class="n">dictools</span><span class="o">.</span><span class="n">_replicate_structure_nested_dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">strains_clean</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">indices</span> <span class="ow">in</span> <span class="n">dictools</span><span class="o">.</span><span class="n">unroll_nested_dictionary_keys</span><span class="p">(</span><span class="n">strains_dict</span><span class="p">):</span>
            <span class="n">dictools</span><span class="o">.</span><span class="n">set_value_to_nested_dict</span><span class="p">(</span><span class="n">strains_dict</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="p">{})</span>

        <span class="k">return</span> <span class="n">strains_dict</span>
    
<div class="viewcode-block" id="BaseInjected.get_times">
<a class="viewcode-back" href="../../gwadama.datasets.html#gwadama.datasets.BaseInjected.get_times">[docs]</a>
    <span class="k">def</span> <span class="nf">get_times</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">indices</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get a single time array from the complete index coordinates.</span>
<span class="sd">        </span>
<span class="sd">        This is just a shortcut to avoid having to write several squared</span>
<span class="sd">        brackets.</span>

<span class="sd">        NOTE: The returned strain is not a copy; if its contents are modified,</span>
<span class="sd">        the changes will be reflected inside the &#39;times&#39; attribute.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">dictools</span><span class="o">.</span><span class="n">get_value_from_nested_dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span></div>

    
<div class="viewcode-block" id="BaseInjected.gen_injections">
<a class="viewcode-back" href="../../gwadama.datasets.html#gwadama.datasets.BaseInjected.gen_injections">[docs]</a>
    <span class="k">def</span> <span class="nf">gen_injections</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                       <span class="n">snr</span><span class="p">:</span> <span class="nb">int</span><span class="o">|</span><span class="nb">float</span><span class="o">|</span><span class="nb">list</span><span class="p">,</span>
                       <span class="n">pad</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
                       <span class="n">randomize_noise</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                       <span class="n">random_seed</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                       <span class="n">injections_per_snr</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
                       <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Inject all strains in simulated noise with the given SNR values.</span>

<span class="sd">        </span>
<span class="sd">        - The SNR is computed using a matched filter against the noise PSD.</span>
<span class="sd">        </span>
<span class="sd">        - If `pad &gt; 0`, it also updates the time arrays.</span>
<span class="sd">        </span>
<span class="sd">        - If strain units are in geometrized, they will be converted first to</span>
<span class="sd">          IS, injected, and converted back to geometrized.</span>
<span class="sd">        </span>
<span class="sd">        - After each injection, applies a highpass filter at the low-cut</span>
<span class="sd">          frequency specified at __init__.</span>
<span class="sd">        </span>
<span class="sd">        - If the method &#39;whiten&#39; has been already called, all further</span>
<span class="sd">          injections will automatically be whitened and their pad removed.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        snr : int | float | list</span>
<span class="sd">        </span>
<span class="sd">        pad : int</span>
<span class="sd">            Number of zeros to pad the signal at both ends before the</span>
<span class="sd">            injection.</span>

<span class="sd">        randomize_noise : bool</span>
<span class="sd">            If True, the noise segment is randomly chosen before the injection.</span>
<span class="sd">            This can be used to avoid having the same noise injected for all</span>
<span class="sd">            clean strains.</span>
<span class="sd">            False by default.</span>
<span class="sd">            </span>
<span class="sd">            NOTE: To avoid the possibility of repeating the same noise section</span>
<span class="sd">            in different injections, the noise realization must be reasonably</span>
<span class="sd">            large, e.g:</span>
<span class="sd">                </span>
<span class="sd">                `noise_length &gt; n_clean_strains * self.max_length * len(snr)`</span>
<span class="sd">        </span>
<span class="sd">        random_seed : int, optional</span>
<span class="sd">            Random seed for the noise realization.</span>
<span class="sd">            Only used when randomize_noise is True.</span>

<span class="sd">        injections_per_snr : int</span>
<span class="sd">            Number of injections per SNR value. Defaults to 1.</span>

<span class="sd">            This is useful to minimize the statistical impact of the noise</span>
<span class="sd">            when performing injections at a sensitive (low) SNR.</span>
<span class="sd">        </span>
<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - If whitening is intended to be applied afterwards it is useful to</span>
<span class="sd">          pad the signal in order to avoid the window vignetting produced by</span>
<span class="sd">          the whitening itself. This pad will be cropped afterwards.</span>
<span class="sd">        </span>
<span class="sd">        - New injections are stored in the &#39;strains&#39; atrribute, with the pad</span>
<span class="sd">          associated to all the injections performed at once. Even when</span>
<span class="sd">          whitening is also performed right after the injections.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            Once injections have been performed at a certain SNR value, there</span>
<span class="sd">            cannot be injected again at the same value. Trying it will trigger</span>
<span class="sd">            this exception.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">snr</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
            <span class="n">snr_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">snr</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">snr</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">snr_list</span> <span class="o">=</span> <span class="n">snr</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;&#39;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">snr</span><span class="p">)</span><span class="si">}</span><span class="s2">&#39; is not a valid &#39;snr&#39; type&quot;</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="n">snr_list</span><span class="p">)</span> <span class="o">&amp;</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">snr_list</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;one or more SNR values are already present in the dataset&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_track_times</span><span class="p">:</span>
            <span class="c1"># Replaced temporarily because when injecting for the first time</span>
            <span class="c1"># we need to keep the original time arrays.</span>
            <span class="n">times_new</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span>

        <span class="c1"># 1st time making injections.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">strains</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">strains</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_init_strains_dict</span><span class="p">()</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_track_times</span><span class="p">:</span>
                <span class="c1"># Redo the dictionary structure to include the SNR layer.</span>
                <span class="n">times_new</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_init_strains_dict</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">randomize_noise</span><span class="p">:</span>
            <span class="n">rng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">default_rng</span><span class="p">(</span><span class="n">random_seed</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="n">n_injections</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">dictools</span><span class="o">.</span><span class="n">get_number_of_elements</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">strains_clean</span><span class="p">)</span>
                <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">snr_list</span><span class="p">)</span>
                <span class="o">*</span> <span class="n">injections_per_snr</span>
            <span class="p">)</span>
            <span class="n">pbar</span> <span class="o">=</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">total</span><span class="o">=</span><span class="n">n_injections</span><span class="p">)</span>



        <span class="k">for</span> <span class="n">clas</span><span class="p">,</span> <span class="n">id_</span> <span class="ow">in</span> <span class="n">dictools</span><span class="o">.</span><span class="n">unroll_nested_dictionary_keys</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">strains_clean</span><span class="p">):</span>
            <span class="n">gw_clean</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">strains_clean</span><span class="p">[</span><span class="n">clas</span><span class="p">][</span><span class="n">id_</span><span class="p">]</span>
            <span class="n">strain_clean_padded</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">gw_clean</span><span class="p">,</span> <span class="n">pad</span><span class="p">)</span>
            <span class="c1"># NOTE: Do not update the metadata nor times with this pad in case</span>
            <span class="c1"># the whitening is applied immediately after the injections.</span>

            <span class="c1"># Highpass filter to the clean signal.</span>
            <span class="c1"># NOTE: The noise realization is already generated without</span>
            <span class="c1"># frequency components lower than the cutoff (they are set to</span>
            <span class="c1"># 0 during the random sampling).</span>
            <span class="n">strain_clean_padded</span> <span class="o">=</span> <span class="n">fat</span><span class="o">.</span><span class="n">highpass_filter</span><span class="p">(</span>
                <span class="n">strain_clean_padded</span><span class="p">,</span> <span class="n">f_cut</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">freq_cutoff</span><span class="p">,</span> <span class="n">f_order</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">freq_butter_order</span><span class="p">,</span>
                <span class="n">sample_rate</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_rate</span>
            <span class="p">)</span>

            <span class="c1"># Strain injections</span>
            <span class="k">for</span> <span class="n">snr_</span><span class="p">,</span> <span class="n">rep</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">snr_list</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="n">injections_per_snr</span><span class="p">)):</span>
                
                <span class="k">if</span> <span class="n">randomize_noise</span><span class="p">:</span>
                    <span class="n">pos0</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">integers</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">noise</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">strain_clean_padded</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">pos0</span> <span class="o">=</span> <span class="mi">0</span>

                <span class="c1"># &#39;pad&#39; is added to &#39;snr_offset&#39; to compensate for the padding</span>
                <span class="c1"># which has not been updated in the &#39;metadata&#39; yet.</span>
                <span class="n">injected</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inject</span><span class="p">(</span>
                    <span class="n">strain_clean_padded</span><span class="p">,</span> <span class="n">snr_</span><span class="p">,</span> <span class="nb">id</span><span class="o">=</span><span class="n">id_</span><span class="p">,</span> <span class="n">snr_offset</span><span class="o">=</span><span class="n">pad</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="n">pos0</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">whitened</span><span class="p">:</span>
                    <span class="n">injected</span> <span class="o">=</span> <span class="n">fat</span><span class="o">.</span><span class="n">whiten</span><span class="p">(</span>
                        <span class="n">injected</span><span class="p">,</span> <span class="n">asd</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">asd_array</span><span class="p">,</span> <span class="n">unpad</span><span class="o">=</span><span class="n">pad</span><span class="p">,</span> <span class="n">sample_rate</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_rate</span><span class="p">,</span>
                        <span class="c1"># Parameters for GWpy&#39;s whiten() function:</span>
                        <span class="n">highpass</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">freq_cutoff</span><span class="p">,</span> <span class="n">flength</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">flength</span>
                    <span class="p">)</span>
                <span class="k">if</span> <span class="n">injections_per_snr</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">strains</span><span class="p">[</span><span class="n">clas</span><span class="p">][</span><span class="n">id_</span><span class="p">][</span><span class="n">snr_</span><span class="p">]</span> <span class="o">=</span> <span class="n">injected</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">dictools</span><span class="o">.</span><span class="n">set_value_to_nested_dict</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">strains</span><span class="p">,</span> <span class="p">[</span><span class="n">clas</span><span class="p">,</span> <span class="n">id_</span><span class="p">,</span> <span class="n">snr_</span><span class="p">,</span> <span class="n">rep</span><span class="p">],</span> <span class="n">injected</span><span class="p">,</span>
                        <span class="n">add_missing_keys</span><span class="o">=</span><span class="kc">True</span>
                    <span class="p">)</span>

                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="n">pbar</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>
            
            <span class="c1"># Time arrays:</span>
            <span class="c1"># - All SNR entries pointing to the SAME time array.</span>
            <span class="c1"># - Enlarge if the strains were padded and no whitening followed.</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_track_times</span><span class="p">:</span>
                <span class="n">times_i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_times</span><span class="p">(</span><span class="n">clas</span><span class="p">,</span> <span class="n">id_</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">pad</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">whitened</span><span class="p">:</span>
                    <span class="n">times_i</span> <span class="o">=</span> <span class="n">tat</span><span class="o">.</span><span class="n">pad_time_array</span><span class="p">(</span><span class="n">times_i</span><span class="p">,</span> <span class="n">pad</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">snr_</span><span class="p">,</span> <span class="n">rep</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">snr_list</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="n">injections_per_snr</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="n">injections_per_snr</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">times_new</span><span class="p">[</span><span class="n">clas</span><span class="p">][</span><span class="n">id_</span><span class="p">][</span><span class="n">snr_</span><span class="p">]</span> <span class="o">=</span> <span class="n">times_i</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">dictools</span><span class="o">.</span><span class="n">set_value_to_nested_dict</span><span class="p">(</span>
                            <span class="n">times_new</span><span class="p">,</span> <span class="p">[</span><span class="n">clas</span><span class="p">,</span> <span class="n">id_</span><span class="p">,</span> <span class="n">snr_</span><span class="p">,</span> <span class="n">rep</span><span class="p">],</span> <span class="n">times_i</span><span class="p">,</span>
                            <span class="n">add_missing_keys</span><span class="o">=</span><span class="kc">True</span>
                        <span class="p">)</span>
        


        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="n">pbar</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_track_times</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">times</span> <span class="o">=</span> <span class="n">times_new</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">snr_list</span> <span class="o">+=</span> <span class="n">snr_list</span>

        <span class="k">for</span> <span class="n">snr_</span> <span class="ow">in</span> <span class="n">snr_list</span><span class="p">:</span>
            <span class="c1"># NOTE: Even if whitening is applied (and hence the length unaltered)</span>
            <span class="c1"># pad values are still registered, just in case.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pad</span><span class="p">[</span><span class="n">snr_</span><span class="p">]</span> <span class="o">=</span> <span class="n">pad</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">injections_per_snr</span> <span class="o">=</span> <span class="n">injections_per_snr</span>
        <span class="k">if</span> <span class="n">injections_per_snr</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># Make sure the depth attribute is updated.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_dict_depth</span> <span class="o">=</span> <span class="n">dictools</span><span class="o">.</span><span class="n">get_depth</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">strains</span><span class="p">)</span>
        
        <span class="c1"># Side-effect attributes updated.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_length</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_max_length</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">Xtrain</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_train_test_subsets</span><span class="p">()</span></div>

    
    <span class="k">def</span> <span class="nf">_inject</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                <span class="n">strain</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                <span class="n">snr</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">float</span><span class="p">,</span>
                <span class="n">pos</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
                <span class="o">**</span><span class="n">_</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Inject &#39;strain&#39; at &#39;snr&#39; into noise using the &#39;self.noise&#39; instance.</span>

<span class="sd">        NOTE: This is writen as an independent method to allow for other</span>
<span class="sd">        classes inheriting this to modify its behaviour without having to</span>
<span class="sd">        rewrite the entire &#39;gen_injections&#39; method.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        strain : NDArray</span>
<span class="sd">            Signal to be injected into noise.</span>
<span class="sd">        </span>
<span class="sd">        snr : int | float</span>
<span class="sd">            Signal to noise ratio.</span>

<span class="sd">        pos : int, optional</span>
<span class="sd">            Index position in the noise array where to inject the signal.</span>
<span class="sd">            0 by default.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        injected : NDArray</span>
<span class="sd">            Injected signal.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">injected</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">noise</span><span class="o">.</span><span class="n">inject</span><span class="p">(</span><span class="n">strain</span><span class="p">,</span> <span class="n">snr</span><span class="o">=</span><span class="n">snr</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="n">pos</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">injected</span>
    
<div class="viewcode-block" id="BaseInjected.export_strains_to_gwf">
<a class="viewcode-back" href="../../gwadama.datasets.html#gwadama.datasets.BaseInjected.export_strains_to_gwf">[docs]</a>
    <span class="k">def</span> <span class="nf">export_strains_to_gwf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                              <span class="n">path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                              <span class="n">channel</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>  <span class="c1"># Name of the channel in which to save strains in the GWFs.</span>
                              <span class="n">t0_gps</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
                              <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Export all strains to GWF format, one file per strain.&quot;&quot;&quot;</span>

        <span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>

        <span class="k">for</span> <span class="n">indices</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">strain</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_strain</span><span class="p">(</span><span class="o">*</span><span class="n">indices</span><span class="p">)</span>
            <span class="n">times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_times</span><span class="p">(</span><span class="o">*</span><span class="n">indices</span><span class="p">)</span>
            <span class="n">ts</span> <span class="o">=</span> <span class="n">TimeSeries</span><span class="p">(</span>
                <span class="n">data</span><span class="o">=</span><span class="n">strain</span><span class="p">,</span>
                <span class="n">times</span><span class="o">=</span><span class="n">t0_gps</span> <span class="o">+</span> <span class="n">times</span><span class="p">,</span>
                <span class="n">channel</span><span class="o">=</span><span class="n">channel</span>
            <span class="p">)</span>
            <span class="n">key</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;:&#39;</span><span class="p">,</span> <span class="s1">&#39;_&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;_snr&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">indices</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
            <span class="n">fields</span> <span class="o">=</span> <span class="p">[</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">detector</span><span class="p">,</span>
                <span class="n">key</span><span class="p">,</span>
                <span class="nb">str</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">t0_gps</span><span class="p">)),</span>
                <span class="nb">str</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">duration</span><span class="o">.</span><span class="n">value</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">))</span>  <span class="c1"># In milliseconds</span>
            <span class="p">]</span>
            <span class="n">file</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="s1">&#39;-&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">fields</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;.gwf&#39;</span><span class="p">)</span>
            <span class="n">ts</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Strain exported to&quot;</span><span class="p">,</span> <span class="n">file</span><span class="p">)</span></div>

    
<div class="viewcode-block" id="BaseInjected.whiten">
<a class="viewcode-back" href="../../gwadama.datasets.html#gwadama.datasets.BaseInjected.whiten">[docs]</a>
    <span class="k">def</span> <span class="nf">whiten</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Whiten injected strains.</span>
<span class="sd">        </span>
<span class="sd">        Calling this method performs the whitening of all injected strains.</span>
<span class="sd">        Strains are later cut to their original size before adding the pad,</span>
<span class="sd">        to remove the vigneting.</span>
<span class="sd">        </span>
<span class="sd">        NOTE: This is an irreversible action; if the original injections need</span>
<span class="sd">        to be preserved it is advised to make a copy of the instance before</span>
<span class="sd">        performing the whitening.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">whitened</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;dataset already whitened&quot;</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">whiten_params</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;missing whitening parameters&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">strains</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;no injections have been performed yet&quot;</span><span class="p">)</span>

        <span class="n">flength</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">whiten_params</span><span class="p">[</span><span class="s1">&#39;flength&#39;</span><span class="p">]</span>
        <span class="n">asd_array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">whiten_params</span><span class="p">[</span><span class="s1">&#39;asd_array&#39;</span><span class="p">]</span>
        <span class="n">pad</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">whiten_params</span><span class="p">[</span><span class="s1">&#39;pad&#39;</span><span class="p">]</span>
        <span class="n">unpad</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">whiten_params</span><span class="p">[</span><span class="s1">&#39;unpad&#39;</span><span class="p">]</span>
        <span class="n">highpass</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">whiten_params</span><span class="p">[</span><span class="s1">&#39;highpass&#39;</span><span class="p">]</span>
        
        <span class="n">loop_aux</span> <span class="o">=</span> <span class="n">tqdm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="n">total</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span> <span class="k">if</span> <span class="n">verbose</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="k">for</span> <span class="o">*</span><span class="n">keys</span><span class="p">,</span> <span class="n">strain</span> <span class="ow">in</span> <span class="n">loop_aux</span><span class="p">:</span>
            <span class="n">snr</span> <span class="o">=</span> <span class="n">keys</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>  <span class="c1"># Shape of self.strains dict-&gt; (class, id, snr[, rep])</span>

            <span class="n">strain_w</span> <span class="o">=</span> <span class="n">fat</span><span class="o">.</span><span class="n">whiten</span><span class="p">(</span>
                <span class="n">strain</span><span class="p">,</span> <span class="n">asd</span><span class="o">=</span><span class="n">asd_array</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="n">pad</span><span class="p">,</span> <span class="n">unpad</span><span class="o">=</span><span class="n">unpad</span><span class="p">[</span><span class="n">snr</span><span class="p">],</span> <span class="n">sample_rate</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_rate</span><span class="p">,</span>
                <span class="n">highpass</span><span class="o">=</span><span class="n">highpass</span><span class="p">,</span> <span class="n">flength</span><span class="o">=</span><span class="n">flength</span>
            <span class="p">)</span>
            <span class="c1"># Update strains attribute.</span>
            <span class="n">dictools</span><span class="o">.</span><span class="n">set_value_to_nested_dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">strains</span><span class="p">,</span> <span class="n">keys</span><span class="p">,</span> <span class="n">strain_w</span><span class="p">)</span>
        
        <span class="c1"># Shrink time arrays accordingly.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_track_times</span><span class="p">:</span>
            <span class="n">clas_id_snr_layers</span> <span class="o">=</span> <span class="n">dictools</span><span class="o">.</span><span class="n">unroll_nested_dictionary_keys</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">,</span>
                <span class="n">max_depth</span><span class="o">=</span><span class="mi">3</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">clas_id_snr</span> <span class="ow">in</span> <span class="n">clas_id_snr_layers</span><span class="p">:</span>
                <span class="c1"># Since all time arrays below SNR layer are the same,</span>
                <span class="c1"># get the first one, shrink it to its corresponding SNR-unpad,</span>
                <span class="c1"># and set it to all subsequent layers.</span>
                <span class="n">snr</span> <span class="o">=</span> <span class="n">clas_id_snr</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                <span class="n">times_sublayer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_times</span><span class="p">(</span><span class="o">*</span><span class="n">clas_id_snr</span><span class="p">)</span>
                <span class="n">time</span> <span class="o">=</span> <span class="n">dictools</span><span class="o">.</span><span class="n">get_next_item</span><span class="p">(</span><span class="n">times_sublayer</span><span class="p">)</span>
                <span class="n">time</span> <span class="o">=</span> <span class="n">tat</span><span class="o">.</span><span class="n">shrink_time_array</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">unpad</span><span class="p">[</span><span class="n">snr</span><span class="p">])</span>
                <span class="n">dictools</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">times_sublayer</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">deepcopy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        
        <span class="bp">self</span><span class="o">.</span><span class="n">whitened</span> <span class="o">=</span> <span class="kc">True</span>
        
        <span class="c1"># Side-effect attributes updated.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_length</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_max_length</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">Xtrain</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_train_test_subsets</span><span class="p">()</span></div>


<div class="viewcode-block" id="BaseInjected.get_xtrain_array">
<a class="viewcode-back" href="../../gwadama.datasets.html#gwadama.datasets.BaseInjected.get_xtrain_array">[docs]</a>
    <span class="k">def</span> <span class="nf">get_xtrain_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                         <span class="n">length</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                         <span class="n">classes</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="nb">list</span> <span class="o">=</span> <span class="s1">&#39;all&#39;</span><span class="p">,</span>
                         <span class="n">snr</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">list</span> <span class="o">|</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;all&#39;</span><span class="p">,</span>
                         <span class="n">with_metadata</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the train subset stacked in a zero-padded Numpy 2d-array.</span>

<span class="sd">        Stacks all signals in the train subset into an homogeneous numpy array</span>
<span class="sd">        whose length (axis=1) is determined by either &#39;length&#39; or, if None, by</span>
<span class="sd">        the longest strain in the subset. The remaining space is zeroed.</span>

<span class="sd">        Allows the possibility to filter by class and SNR.</span>

<span class="sd">        NOTE: Same signals injected at different SNR are stacked continuously.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        length : int, optional</span>
<span class="sd">            Target length of the &#39;train_array&#39;. If None, the longest signal</span>
<span class="sd">            determines the length.</span>

<span class="sd">        classes : str | list[str]</span>
<span class="sd">            Whitelist of classes to include in the stack.</span>
<span class="sd">            All classes are included by default.</span>

<span class="sd">        snr : int | list[int] | str</span>
<span class="sd">            Whitelist of SNR injections to include in the stack. If more than</span>
<span class="sd">            one are selected, they are stacked zipped as follows:</span>
<span class="sd">            </span>
<span class="sd">            ```</span>
<span class="sd">            eos0 id0 snr0</span>
<span class="sd">            eos0 id0 snr1</span>
<span class="sd">                ...</span>
<span class="sd">            ```</span>
<span class="sd">            </span>
<span class="sd">            All injections are included by default.</span>
<span class="sd">        </span>
<span class="sd">        with_metadata : bool</span>
<span class="sd">            If True, the associated metadata is returned in addition to the</span>
<span class="sd">            train array in a Pandas DataFrame instance.</span>
<span class="sd">            This metadata is obtained from the original &#39;metadata&#39; attribute,</span>
<span class="sd">            with the former index inserted as the first column, &#39;id&#39;, and with an</span>
<span class="sd">            additional column for the SNR values.</span>
<span class="sd">            False by default.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        train_array : np.ndarray</span>
<span class="sd">            Train subset.</span>
<span class="sd">        </span>
<span class="sd">        lengths : list</span>
<span class="sd">            Original length of each strain, following the same order as the</span>
<span class="sd">            first axis of &#39;train_array&#39;.</span>
<span class="sd">        </span>
<span class="sd">        metadata : pd.DataFrame, optional</span>
<span class="sd">            If &#39;with_metadata&#39; is True, the associated metadata is returned</span>
<span class="sd">            with its entries in the same order as the &#39;train_array&#39;.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stack_subset</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Xtrain</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">classes</span><span class="p">,</span> <span class="n">snr</span><span class="p">,</span> <span class="n">with_metadata</span><span class="p">)</span></div>

    
<div class="viewcode-block" id="BaseInjected.get_xtest_array">
<a class="viewcode-back" href="../../gwadama.datasets.html#gwadama.datasets.BaseInjected.get_xtest_array">[docs]</a>
    <span class="k">def</span> <span class="nf">get_xtest_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                        <span class="n">length</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                        <span class="n">classes</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="nb">list</span> <span class="o">=</span> <span class="s1">&#39;all&#39;</span><span class="p">,</span>
                        <span class="n">snr</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">list</span> <span class="o">|</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;all&#39;</span><span class="p">,</span>
                        <span class="n">with_metadata</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the test subset stacked in a zero-padded Numpy 2d-array.</span>

<span class="sd">        Stacks all signals in the test subset into an homogeneous numpy array</span>
<span class="sd">        whose length (axis=1) is determined by either &#39;length&#39; or, if None, by</span>
<span class="sd">        the longest strain in the subset. The remaining space is zeroed.</span>

<span class="sd">        Allows the possibility to filter by class and SNR.</span>

<span class="sd">        NOTE: Same signals injected at different SNR are stacked continuously.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        length : int, optional</span>
<span class="sd">            Target length of the &#39;test_array&#39;. If None, the longest signal</span>
<span class="sd">            determines the length.</span>

<span class="sd">        classes : str | list[str]</span>
<span class="sd">            Whitelist of classes to include in the stack.</span>
<span class="sd">            All classes are included by default.</span>

<span class="sd">        snr : int | list[int] | str</span>
<span class="sd">            Whitelist of SNR injections to include in the stack. If more than</span>
<span class="sd">            one are selected, they are stacked zipped as follows:</span>
<span class="sd">            </span>
<span class="sd">            ```</span>
<span class="sd">            eos0 id0 snr0</span>
<span class="sd">            eos0 id0 snr1</span>
<span class="sd">                ...</span>
<span class="sd">            ```</span>
<span class="sd">            </span>
<span class="sd">            All injections are included by default.</span>

<span class="sd">        with_metadata : bool</span>
<span class="sd">            If True, the associated metadata is returned in addition to the</span>
<span class="sd">            test array in a Pandas DataFrame instance.</span>
<span class="sd">            This metadata is obtained from the original &#39;metadata&#39; attribute,</span>
<span class="sd">            with the former index inserted as the first column, &#39;id&#39;, and with an</span>
<span class="sd">            additional column for the SNR values.</span>
<span class="sd">            False by default.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        test_array : np.ndarray</span>
<span class="sd">            Test subset.</span>

<span class="sd">        lengths : list</span>
<span class="sd">            Original length of each strain, following the same order as the</span>
<span class="sd">            first axis of &#39;test_array&#39;.</span>

<span class="sd">        metadata : pd.DataFrame, optional</span>
<span class="sd">            If &#39;with_metadata&#39; is True, the associated metadata is returned</span>
<span class="sd">            with its entries in the same order as the &#39;test_array&#39;.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stack_subset</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Xtest</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="n">length</span><span class="p">,</span> <span class="n">classes</span><span class="o">=</span><span class="n">classes</span><span class="p">,</span>
                                  <span class="n">snr</span><span class="o">=</span><span class="n">snr</span><span class="p">,</span> <span class="n">with_metadata</span><span class="o">=</span><span class="n">with_metadata</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">_stack_subset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                      <span class="n">strains</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span>
                      <span class="n">length</span><span class="p">:</span>  <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                      <span class="n">classes</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="nb">list</span> <span class="o">=</span> <span class="s1">&#39;all&#39;</span><span class="p">,</span>
                      <span class="n">snr</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">list</span> <span class="o">|</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;all&#39;</span><span class="p">,</span>
                      <span class="n">with_metadata</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Stack &#39;strains&#39; into a zero-padded 2d-array.</span>

<span class="sd">        This is a helper function for &#39;get_xtrain_array&#39; and &#39;get_xtest_array&#39;.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        strains : dict</span>
<span class="sd">            A dictionary containing the strains to be stacked.</span>
<span class="sd">            The keys of the first layer are the IDs of the strains.</span>

<span class="sd">        length : int, optional</span>
<span class="sd">            The target length of the stacked array. If None, the longest signal</span>
<span class="sd">            determines the length.</span>

<span class="sd">        classes : str | list[str]</span>
<span class="sd">            Whitelist of classes to include in the stack.</span>
<span class="sd">            All classes are included by default.</span>

<span class="sd">        snr : int | list[int] | str</span>
<span class="sd">            Whitelist of SNR injections to include in the stack. If more than</span>
<span class="sd">            one are selected, they are stacked zipped as follows:</span>
<span class="sd">            </span>
<span class="sd">            ```</span>
<span class="sd">            eos0 id0 snr0</span>
<span class="sd">            eos0 id0 snr1</span>
<span class="sd">                ...</span>
<span class="sd">            ```</span>
<span class="sd">            </span>
<span class="sd">            All injections are included by default.</span>

<span class="sd">        with_metadata : bool</span>
<span class="sd">            If True, the associated metadata is returned in addition to the</span>
<span class="sd">            stacked array in a Pandas DataFrame instance.</span>
<span class="sd">            This metadata is obtained from the original &#39;metadata&#39; attribute,</span>
<span class="sd">            with the former index inserted as the first column, &#39;id&#39;, and with</span>
<span class="sd">            an additional column for the SNR values.</span>
<span class="sd">            False by default.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        stacked_signals : np.ndarray</span>
<span class="sd">            The array containing the stacked strains.</span>

<span class="sd">        lengths : list</span>
<span class="sd">            The original lengths of each strain, following the same order as</span>
<span class="sd">            the first axis of &#39;stacked_signals&#39;.</span>

<span class="sd">        metadata : pd.DataFrame, optional</span>
<span class="sd">            If &#39;with_metadata&#39; is True, the associated metadata is returned</span>
<span class="sd">            with its entries in the same order as the &#39;stacked_signals&#39;.</span>
<span class="sd">            This metadata is obtained from the original &#39;metadata&#39; attribute,</span>
<span class="sd">            with the former index inserted as the first column, &#39;id&#39;, and with</span>
<span class="sd">            an additional column for the SNR values.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the value of &#39;classes&#39; or &#39;snr&#39; is not valid.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">classes</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">))</span> <span class="ow">and</span> <span class="n">classes</span> <span class="o">!=</span> <span class="s1">&#39;all&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">classes</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">classes</span> <span class="o">=</span> <span class="p">[</span><span class="n">classes</span><span class="p">]</span>

            <span class="c1"># NOTE: Here there is no &#39;class&#39; layer, therefore it must be</span>
            <span class="c1"># traced back from the ID, and filtered over this same layer.</span>
            <span class="k">def</span> <span class="nf">filter_class</span><span class="p">(</span><span class="nb">id</span><span class="p">):</span>
                <span class="n">clas</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_class</span><span class="p">(</span><span class="nb">id</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">clas</span> <span class="ow">in</span> <span class="n">classes</span>
            <span class="n">strains</span> <span class="o">=</span> <span class="n">dictools</span><span class="o">.</span><span class="n">filter_nested_dict</span><span class="p">(</span><span class="n">strains</span><span class="p">,</span> <span class="n">filter_class</span><span class="p">,</span> <span class="n">layer</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">classes</span> <span class="o">!=</span> <span class="s1">&#39;all&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;the type of &#39;classes&#39; is not valid&quot;</span><span class="p">)</span>


        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">snr</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">snr</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="n">snr</span> <span class="o">=</span> <span class="p">[</span><span class="n">snr</span><span class="p">]</span>

            <span class="c1"># NOTE: Here SNR is in Layer 1 because the Train/Test subset</span>
            <span class="c1"># dictionaries do not have the &#39;class&#39; first layer.</span>
            <span class="n">strains</span> <span class="o">=</span> <span class="n">dictools</span><span class="o">.</span><span class="n">filter_nested_dict</span><span class="p">(</span><span class="n">strains</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">k</span><span class="p">:</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">snr</span><span class="p">,</span> <span class="n">layer</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># If `snr == &#39;all&#39;`, no filter is applied over &#39;strains&#39;.</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">snr</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">snr</span> <span class="o">!=</span> <span class="s1">&#39;all&#39;</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;the value of &#39;snr&#39; is not valid&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">pass</span>
        
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;the type of &#39;snr&#39; is not valid&quot;</span><span class="p">)</span>
        

        <span class="n">strains</span> <span class="o">=</span> <span class="n">dictools</span><span class="o">.</span><span class="n">flatten_nested_dict</span><span class="p">(</span><span class="n">strains</span><span class="p">)</span>

        <span class="n">stacked_signals</span><span class="p">,</span> <span class="n">lengths</span> <span class="o">=</span> <span class="n">dictools</span><span class="o">.</span><span class="n">dict_to_stacked_array</span><span class="p">(</span><span class="n">strains</span><span class="p">,</span> <span class="n">target_length</span><span class="o">=</span><span class="n">length</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">with_metadata</span><span class="p">:</span>
            <span class="n">id_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">strains</span><span class="p">]</span>
            <span class="n">snr_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">strains</span><span class="p">]</span>
            <span class="n">rep_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">strains</span><span class="p">]</span>
            <span class="n">metadata</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">id_list</span><span class="p">]</span>  <span class="c1"># sorts and makes all necessary copies.</span>
            <span class="n">metadata</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="s1">&#39;id&#39;</span><span class="p">)</span>
            <span class="n">metadata</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;snr&#39;</span><span class="p">,</span> <span class="n">snr_list</span><span class="p">)</span>  <span class="c1"># after &#39;id&#39;.</span>
            <span class="n">metadata</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;rep&#39;</span><span class="p">,</span> <span class="n">rep_list</span><span class="p">)</span>  <span class="c1"># after &#39;snr&#39;.</span>
            
            <span class="k">return</span> <span class="n">stacked_signals</span><span class="p">,</span> <span class="n">lengths</span><span class="p">,</span> <span class="n">metadata</span>
        <span class="k">return</span> <span class="n">stacked_signals</span><span class="p">,</span> <span class="n">lengths</span>

<div class="viewcode-block" id="BaseInjected.get_ytrain_array">
<a class="viewcode-back" href="../../gwadama.datasets.html#gwadama.datasets.BaseInjected.get_ytrain_array">[docs]</a>
    <span class="k">def</span> <span class="nf">get_ytrain_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">classes</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">,</span> <span class="n">snr</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">,</span> <span class="n">with_id</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">with_index</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the filtered training labels.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        classes : str | list[str] | &#39;all&#39;</span>
<span class="sd">            Whitelist of classes to include in the labels.</span>
<span class="sd">            All classes are included by default.</span>
<span class="sd">        </span>
<span class="sd">        snr : int | list[int] | str</span>
<span class="sd">            Whitelist of SNR injections to include in the labels.</span>
<span class="sd">            All injections are included by default.</span>

<span class="sd">        with_id : bool</span>
<span class="sd">            If True, return also the related IDs.</span>
<span class="sd">            False by default.</span>

<span class="sd">        with_index : bool</span>
<span class="sd">            If True, return also the related GLOBAL indices w.r.t. the stacked</span>
<span class="sd">            arrays returned by &#39;get_xtrain_array&#39; WITHOUT filters.</span>
<span class="sd">            False by default.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        np.ndarray</span>
<span class="sd">            Filtered train labels.</span>

<span class="sd">        np.ndarray, optional</span>
<span class="sd">            IDs associated to the filtered train labels.</span>
<span class="sd">        </span>
<span class="sd">        np.ndarray, optional</span>
<span class="sd">            Indices associated to the filtered train labels.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filter_labels</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Ytrain</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Xtrain</span><span class="p">),</span> <span class="n">classes</span><span class="p">,</span> <span class="n">snr</span><span class="p">,</span>
            <span class="n">with_id</span><span class="o">=</span><span class="n">with_id</span><span class="p">,</span> <span class="n">with_index</span><span class="o">=</span><span class="n">with_index</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="BaseInjected.get_ytest_array">
<a class="viewcode-back" href="../../gwadama.datasets.html#gwadama.datasets.BaseInjected.get_ytest_array">[docs]</a>
    <span class="k">def</span> <span class="nf">get_ytest_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">classes</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">,</span> <span class="n">snr</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">,</span> <span class="n">with_id</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">with_index</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the filtered test labels.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        classes : str | list[str] | &#39;all&#39;</span>
<span class="sd">            Whitelist of classes to include in the labels.</span>
<span class="sd">            All classes are included by default.</span>
<span class="sd">        </span>
<span class="sd">        snr : int | list[int] | str</span>
<span class="sd">            Whitelist of SNR injections to include in the labels.</span>
<span class="sd">            All injections are included by default.</span>

<span class="sd">        with_id : bool</span>
<span class="sd">            If True, return also the related IDs.</span>
<span class="sd">            False by default.</span>

<span class="sd">        with_index : bool</span>
<span class="sd">            If True, return also the related GLOBAL indices w.r.t. the stacked</span>
<span class="sd">            arrays returned by &#39;get_xtest_array&#39; WITHOUT filters.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        np.ndarray</span>
<span class="sd">            Filtered test labels.</span>

<span class="sd">        np.ndarray, optional</span>
<span class="sd">            IDs associated to the filtered test labels.</span>
<span class="sd">        </span>
<span class="sd">        np.ndarray, optional</span>
<span class="sd">            Indices associated to the filtered test labels.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filter_labels</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Ytest</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Xtest</span><span class="p">),</span> <span class="n">classes</span><span class="p">,</span> <span class="n">snr</span><span class="p">,</span>
            <span class="n">with_id</span><span class="o">=</span><span class="n">with_id</span><span class="p">,</span> <span class="n">with_index</span><span class="o">=</span><span class="n">with_index</span>
        <span class="p">)</span></div>

    
    <span class="k">def</span> <span class="nf">_filter_labels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">labels_id</span><span class="p">,</span> <span class="n">classes</span><span class="p">,</span> <span class="n">snr</span><span class="p">,</span> <span class="n">with_id</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">with_index</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Filter &#39;labels&#39; based on &#39;classes&#39; and &#39;snr&#39;.</span>

<span class="sd">        This is a helper function for &#39;get_ytrain_array&#39; and &#39;get_ytest_array&#39;.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        labels : np.ndarray</span>
<span class="sd">            The array containing the labels.</span>

<span class="sd">        labels_id : list</span>
<span class="sd">            IDs associated to the labels.</span>
<span class="sd">        </span>
<span class="sd">        classes : str | list[str] | &#39;all&#39;</span>
<span class="sd">            Whitelist of classes to include in the labels.</span>
<span class="sd">            All classes are included by default.</span>
<span class="sd">        </span>
<span class="sd">        snr : int | list[int] | str</span>
<span class="sd">            Whitelist of SNR injections to include in the labels.</span>
<span class="sd">            All injections are included by default.</span>

<span class="sd">        with_id : bool</span>
<span class="sd">            If True, return also the related IDs.</span>
<span class="sd">            False by default.</span>

<span class="sd">        with_index : bool</span>
<span class="sd">            If True, return also the related indices w.r.t. the stacked array</span>
<span class="sd">            returned by &#39;_stack_subset&#39; given the strains related to &#39;labels&#39;</span>
<span class="sd">            WITHOUT filters.</span>
<span class="sd">            False by default.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        filtered_labels : np.ndarray</span>
<span class="sd">            Filtered labels.</span>

<span class="sd">        filtered_ids : np.ndarray, optional</span>
<span class="sd">            IDs associated to the filtered labels.</span>

<span class="sd">        filtered_indices : np.ndarray, optional</span>
<span class="sd">            Indices associated to the filtered labels.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get labels and IDs filtered by &#39;classes&#39;.</span>
        <span class="n">filtered_labels</span><span class="p">,</span> <span class="n">filtered_ids</span><span class="p">,</span> <span class="n">filtered_indices</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_filter_labels</span><span class="p">(</span>
            <span class="n">labels</span><span class="p">,</span> <span class="n">labels_id</span><span class="p">,</span> <span class="n">classes</span><span class="p">,</span> <span class="n">with_id</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">with_index</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">snr</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">snr</span> <span class="o">!=</span> <span class="s1">&#39;all&#39;</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;only the str &#39;all&#39; is allowed for &#39;snr&#39;.&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">snr</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">snr</span> <span class="o">=</span> <span class="p">[</span><span class="n">snr</span><span class="p">]</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">snr</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;the type of &#39;snr&#39; is not valid&quot;</span><span class="p">)</span>
        
        <span class="n">n_snr_total</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">snr_list</span><span class="p">)</span>

        <span class="c1"># Repeat all by the total number of SNR values.</span>
        <span class="n">filtered_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">filtered_labels</span><span class="p">,</span> <span class="n">n_snr_total</span><span class="p">)</span>
        <span class="n">filtered_ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">filtered_ids</span><span class="p">,</span> <span class="n">n_snr_total</span><span class="p">)</span>
        <span class="n">filtered_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">filtered_indices</span><span class="p">,</span> <span class="n">n_snr_total</span><span class="p">)</span>

        <span class="n">n_filtered</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">filtered_labels</span><span class="p">)</span>

        <span class="c1"># Convert the indices to include the TOTAL number of SNR repetitions.</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n_filtered</span><span class="p">,</span> <span class="n">n_snr_total</span><span class="p">):</span>
            <span class="n">i_old</span> <span class="o">=</span> <span class="n">filtered_indices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">i_new0</span> <span class="o">=</span> <span class="n">i_old</span> <span class="o">*</span> <span class="n">n_snr_total</span>
            <span class="n">i_new1</span> <span class="o">=</span> <span class="n">i_new0</span> <span class="o">+</span> <span class="n">n_snr_total</span>
            <span class="n">filtered_indices</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="n">n_snr_total</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">i_new0</span><span class="p">,</span> <span class="n">i_new1</span><span class="p">)</span>

        <span class="c1"># Filter out those not present in the &#39;snr&#39; list.</span>
        <span class="k">if</span> <span class="n">snr</span> <span class="o">!=</span> <span class="s1">&#39;all&#39;</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">snr_list</span><span class="p">,</span> <span class="n">snr</span><span class="p">)</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">n_filtered</span><span class="o">//</span><span class="n">n_snr_total</span><span class="p">)</span>
            <span class="n">filtered_labels</span> <span class="o">=</span> <span class="n">filtered_labels</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
            <span class="n">filtered_ids</span> <span class="o">=</span> <span class="n">filtered_ids</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
            <span class="n">filtered_indices</span> <span class="o">=</span> <span class="n">filtered_indices</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>

        <span class="c1"># Repeat labels and IDs by &#39;injections_per_snr&#39;, and extend the indices</span>
        <span class="c1"># accordingly.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">injections_per_snr</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">n_reps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">injections_per_snr</span>
            <span class="n">filtered_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">filtered_labels</span><span class="p">,</span> <span class="n">n_reps</span><span class="p">)</span>
            <span class="n">filtered_ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">filtered_ids</span><span class="p">,</span> <span class="n">n_reps</span><span class="p">)</span>
            <span class="n">filtered_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">filtered_indices</span><span class="p">,</span> <span class="n">n_reps</span><span class="p">)</span>
            <span class="c1"># Convert the indices to also include the TOTAL number of</span>
            <span class="c1"># repetitions per SNR.</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">filtered_indices</span><span class="p">),</span> <span class="n">n_reps</span><span class="p">):</span>
                <span class="n">i_old</span> <span class="o">=</span> <span class="n">filtered_indices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">i_new0</span> <span class="o">=</span> <span class="n">i_old</span> <span class="o">*</span> <span class="n">n_reps</span>
                <span class="n">i_new1</span> <span class="o">=</span> <span class="n">i_new0</span> <span class="o">+</span> <span class="n">n_reps</span>
                <span class="n">filtered_indices</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="n">n_reps</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">i_new0</span><span class="p">,</span> <span class="n">i_new1</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">with_id</span> <span class="ow">and</span> <span class="n">with_index</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">filtered_labels</span><span class="p">,</span> <span class="n">filtered_ids</span><span class="p">,</span> <span class="n">filtered_indices</span>
        <span class="k">if</span> <span class="n">with_id</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">filtered_labels</span><span class="p">,</span> <span class="n">filtered_ids</span>
        <span class="k">if</span> <span class="n">with_index</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">filtered_labels</span><span class="p">,</span> <span class="n">filtered_indices</span>
        <span class="k">return</span> <span class="n">filtered_labels</span>

<div class="viewcode-block" id="BaseInjected.stack_by_id">
<a class="viewcode-back" href="../../gwadama.datasets.html#gwadama.datasets.BaseInjected.stack_by_id">[docs]</a>
    <span class="k">def</span> <span class="nf">stack_by_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                    <span class="n">id_list</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span>
                    <span class="n">length</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                    <span class="n">snr_included</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;all&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Stack a subset of strains by ID into a zero-padded 2d-array.</span>

<span class="sd">        This may allow (for example) to group up strains by their original ID</span>
<span class="sd">        without leaking differnet injections (SNR) of the same strain into</span>
<span class="sd">        different splits.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        id_list : array-like</span>
<span class="sd">            The IDs of the strains to be stacked.</span>

<span class="sd">        length : int, optional</span>
<span class="sd">            The target length of the stacked array. If None, the longest signal</span>
<span class="sd">            determines the length.</span>

<span class="sd">        snr_included : int | list[int] | str, optional</span>
<span class="sd">            The SNR injections to include in the stack. If more than one are</span>
<span class="sd">            selected, they are stacked zipped as follows:</span>
<span class="sd">            </span>
<span class="sd">            ```</span>
<span class="sd">            id0 snr0</span>
<span class="sd">            id0 snr1</span>
<span class="sd">              ...</span>
<span class="sd">            ```</span>
<span class="sd">            </span>
<span class="sd">            All injections are included by default.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        stacked_signals : np.ndarray</span>
<span class="sd">            The array containing the stacked strains.</span>

<span class="sd">        lengths : list</span>
<span class="sd">            The original lengths of each strain, following the same order as</span>
<span class="sd">            the first axis of &#39;stacked_signals&#39;.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - Unlike in &#39;get_xtrain_array&#39; and &#39;get_xtest_array&#39;, this method does</span>
<span class="sd">          not filter by &#39;classes&#39; since it would be redundant, as IDs are</span>
<span class="sd">          unique.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the value of &#39;snr&#39; is not valid.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">id_list</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;&#39;id_list&#39; must be a list of IDs.&quot;</span><span class="p">)</span>
        
        <span class="c1"># Collapse the Class layer.</span>
        <span class="n">strains</span> <span class="o">=</span> <span class="p">{</span><span class="nb">id</span><span class="p">:</span> <span class="n">ds</span> <span class="k">for</span> <span class="n">sub_strains</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">strains</span><span class="o">.</span><span class="n">values</span><span class="p">()</span> <span class="k">for</span> <span class="nb">id</span><span class="p">,</span> <span class="n">ds</span> <span class="ow">in</span> <span class="n">sub_strains</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

        <span class="c1"># Filter out those not in the &#39;id_list&#39;.</span>
        <span class="n">strains</span> <span class="o">=</span> <span class="n">dictools</span><span class="o">.</span><span class="n">filter_nested_dict</span><span class="p">(</span><span class="n">strains</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">k</span><span class="p">:</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">id_list</span><span class="p">,</span> <span class="n">layer</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># Filter out those injections whose SNR isnot in the &#39;snr&#39; list.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">snr_included</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">snr_included</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="n">snr_included</span> <span class="o">=</span> <span class="p">[</span><span class="n">snr_included</span><span class="p">]</span>
            <span class="c1"># NOTE: Here SNR is in Layer 1 because we collapsed the Class layer.</span>
            <span class="n">strains</span> <span class="o">=</span> <span class="n">dictools</span><span class="o">.</span><span class="n">filter_nested_dict</span><span class="p">(</span><span class="n">strains</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">k</span><span class="p">:</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">snr_included</span><span class="p">,</span> <span class="n">layer</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">snr_included</span> <span class="o">!=</span> <span class="s1">&#39;all&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;the value of &#39;snr&#39; is not valid&quot;</span><span class="p">)</span>

        <span class="n">strains</span> <span class="o">=</span> <span class="n">dictools</span><span class="o">.</span><span class="n">flatten_nested_dict</span><span class="p">(</span><span class="n">strains</span><span class="p">)</span>  <span class="c1"># keys: &quot;(id, snr)&quot;</span>
        <span class="n">stacked_signals</span><span class="p">,</span> <span class="n">lengths</span> <span class="o">=</span> <span class="n">dictools</span><span class="o">.</span><span class="n">dict_to_stacked_array</span><span class="p">(</span><span class="n">strains</span><span class="p">,</span> <span class="n">target_length</span><span class="o">=</span><span class="n">length</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">stacked_signals</span><span class="p">,</span> <span class="n">lengths</span></div>
</div>

        


<div class="viewcode-block" id="SyntheticWaves">
<a class="viewcode-back" href="../../gwadama.datasets.html#gwadama.datasets.SyntheticWaves">[docs]</a>
<span class="k">class</span> <span class="nc">SyntheticWaves</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Class for building synthetically generated wavforms and background noise.</span>

<span class="sd">    Part of the datasets for the CLAWDIA main paper.</span>
<span class="sd">    </span>
<span class="sd">    The classes are hardcoded:</span>
<span class="sd">        </span>
<span class="sd">        SG: Sine Gaussian,</span>
<span class="sd">        </span>
<span class="sd">        G:  Gaussian,</span>
<span class="sd">        </span>
<span class="sd">        RD: Ring-Down.</span>


<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    classes : dict</span>
<span class="sd">        Dict of strings and their integer labels, one per class (category).</span>
<span class="sd">    </span>
<span class="sd">    strains : dict {class: {key: gw_strains} }</span>
<span class="sd">        Strains stored as a nested dictionary, with each strain in an</span>
<span class="sd">        independent array to provide more flexibility with data of a wide</span>
<span class="sd">        range of lengths.</span>
<span class="sd">        The class key is the name of the class, a string which must exist in</span>
<span class="sd">        the &#39;classes&#39; attribute.</span>
<span class="sd">        The &#39;key&#39; is an identifier of each strain.</span>
<span class="sd">        In this case it&#39;s just the global index ranging from 0 to &#39;self.n_samples&#39;.</span>
<span class="sd">    </span>
<span class="sd">    labels : NDArray[int]</span>
<span class="sd">        Indices of the classes, one per waveform.</span>
<span class="sd">        Each one points its respective waveform inside &#39;strains&#39; to its class</span>
<span class="sd">        in &#39;classes&#39;. The order is that of the index of &#39;self.metadata&#39;, and</span>
<span class="sd">        coincides with the order of the strains inside &#39;self.strains&#39; if</span>
<span class="sd">        unrolled to a flat list of arrays.</span>
<span class="sd">    </span>
<span class="sd">    metadata : pandas.DataFrame</span>
<span class="sd">        All parameters and data related to the strains.</span>
<span class="sd">        The order is the same as inside &#39;strains&#39; if unrolled to a flat list</span>
<span class="sd">        of strains.</span>

<span class="sd">    train_size : int | float</span>
<span class="sd">            If int, total number of samples to include in the train dataset.</span>
<span class="sd">            If float, fraction of the total samples to include in the train</span>
<span class="sd">            dataset.</span>
<span class="sd">            For more details see &#39;sklearn.model_selection.train_test_split&#39;</span>
<span class="sd">            with the flag `stratified=True`.</span>
<span class="sd">    </span>
<span class="sd">    units : str</span>
<span class="sd">        Flag indicating whether the data is in &#39;geometrized&#39; or &#39;IS&#39; units.</span>
<span class="sd">    </span>
<span class="sd">    Xtrain, Xtest : dict {key: strain}</span>
<span class="sd">        Train and test subsets randomly split using SKLearn train_test_split</span>
<span class="sd">        function with stratified labels.</span>
<span class="sd">        The key corresponds to the strain&#39;s index at &#39;self.metadata&#39;.</span>
<span class="sd">    </span>
<span class="sd">    Ytrain, Ytest : NDArray[int]</span>
<span class="sd">        1D Array containing the labels in the same order as &#39;Xtrain&#39; and</span>
<span class="sd">        &#39;Xtest&#39; respectively.</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="SyntheticWaves.__init__">
<a class="viewcode-back" href="../../gwadama.datasets.html#gwadama.datasets.SyntheticWaves.__init__">[docs]</a>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="o">*</span><span class="p">,</span>
                 <span class="n">classes</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span>
                 <span class="n">n_waves_per_class</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                 <span class="n">wave_parameters_limits</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span>
                 <span class="n">max_length</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                 <span class="n">peak_time_max_length</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
                 <span class="n">amp_threshold</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
                 <span class="n">tukey_alpha</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
                 <span class="n">sample_rate</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                 <span class="n">random_seed</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        n_waves_per_class : int</span>
<span class="sd">            Number of waves per class to produce.</span>

<span class="sd">        wave_parameters_limits : dict</span>
<span class="sd">            Min/Max limits of the waveforms&#39; parameters, 9 in total.</span>
<span class="sd">            Keys:</span>
<span class="sd">            </span>
<span class="sd">            - mf0,   Mf0:   min/Max central frequency (SG and RD).</span>
<span class="sd">            </span>
<span class="sd">            - mQ,    MQ:    min/Max quality factor (SG and RD).</span>
<span class="sd">            </span>
<span class="sd">            - mhrss, Mhrss: min/Max sum squared amplitude of the wave.</span>
<span class="sd">            </span>
<span class="sd">            - mT,    MT:    min/Max duration (only G).</span>
<span class="sd">        </span>
<span class="sd">        max_length : int</span>
<span class="sd">            Maximum length of the waves. This parameter is used to generate the</span>
<span class="sd">            initial time array with which the waveforms are computed.</span>
<span class="sd">        </span>
<span class="sd">        peak_time_max_length : float</span>
<span class="sd">            Time of the peak of the envelope of the waves in the initial time</span>
<span class="sd">            array (built with &#39;max_length&#39;).</span>
<span class="sd">        </span>
<span class="sd">        amp_threshold : float</span>
<span class="sd">            Fraction w.r.t. the maximum absolute amplitude of the wave envelope</span>
<span class="sd">            below which to end the wave by shrinking the array and applying a</span>
<span class="sd">            windowing to the edges.</span>
<span class="sd">        </span>
<span class="sd">        tukey_alpha : float</span>
<span class="sd">            Alpha parameter (width) of the Tukey window applied to each wave to</span>
<span class="sd">            make sure their values end at the exact duration determined by either</span>
<span class="sd">            the duration parameter or the amplitude threshold.</span>
<span class="sd">        </span>
<span class="sd">        sample_rate : int</span>
<span class="sd">        </span>
<span class="sd">        random_seed : int, optional.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_classes_dict</span><span class="p">(</span><span class="n">classes</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">classes</span> <span class="o">=</span> <span class="n">classes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_waves_per_class</span> <span class="o">=</span> <span class="n">n_waves_per_class</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sample_rate</span> <span class="o">=</span> <span class="n">sample_rate</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wave_parameters_limits</span> <span class="o">=</span> <span class="n">wave_parameters_limits</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_length</span> <span class="o">=</span> <span class="n">max_length</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">peak_time_max_length</span> <span class="o">=</span> <span class="n">peak_time_max_length</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tukey_alpha</span> <span class="o">=</span> <span class="n">tukey_alpha</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">amp_threshold</span> <span class="o">=</span> <span class="n">amp_threshold</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">random_seed</span> <span class="o">=</span> <span class="n">random_seed</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">default_rng</span><span class="p">(</span><span class="n">random_seed</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_gen_metadata</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_track_times</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_gen_dataset</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gen_labels</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">Xtrain</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Xtest</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Ytrain</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Ytest</span> <span class="o">=</span> <span class="kc">None</span></div>


    <span class="k">def</span> <span class="nf">_gen_metadata</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate random metadata associated with each waveform.&quot;&quot;&quot;</span>

        <span class="n">classes_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">f0s_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">Q_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">hrss_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">duration_list</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># Will be modified afterwards to take into account</span>
                            <span class="c1"># the amplitude threshold.</span>
        <span class="k">for</span> <span class="n">clas</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">classes</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_waves_per_class</span><span class="p">):</span>
                <span class="c1"># Need to pass &#39;self&#39; explicitely since I&#39;m calling the methods</span>
                <span class="c1"># inside a dictionary attribute. Python doesn&#39;t seem to</span>
                <span class="c1"># recognise them as the same class methods this way.</span>
                <span class="n">f0</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">hrss</span><span class="p">,</span> <span class="n">duration</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gen_parameters</span><span class="p">[</span><span class="n">clas</span><span class="p">](</span><span class="bp">self</span><span class="p">)</span>
                <span class="n">classes_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">clas</span><span class="p">)</span>
                <span class="n">f0s_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">f0</span><span class="p">)</span>
                <span class="n">Q_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span>
                <span class="n">hrss_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">hrss</span><span class="p">)</span>
                <span class="n">duration_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">duration</span><span class="p">)</span>  

        <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span>
            <span class="s1">&#39;Class&#39;</span><span class="p">:</span> <span class="n">classes_list</span><span class="p">,</span>  <span class="c1"># strings</span>
            <span class="s1">&#39;f0&#39;</span><span class="p">:</span> <span class="n">f0s_list</span><span class="p">,</span>
            <span class="s1">&#39;Q&#39;</span><span class="p">:</span> <span class="n">Q_list</span><span class="p">,</span>
            <span class="s1">&#39;hrss&#39;</span><span class="p">:</span> <span class="n">hrss_list</span><span class="p">,</span>
            <span class="s1">&#39;duration&#39;</span><span class="p">:</span> <span class="n">duration_list</span>
        <span class="p">})</span>

    <span class="k">def</span> <span class="nf">_gen_dataset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate the dataset from the previously generated metadata.</span>

<span class="sd">        After generating the waveforms with the analytical expressions it</span>
<span class="sd">        shrinks them to the specified duration in the metadata. This is</span>
<span class="sd">        necessary because the analytical expressions are infinite, so we apply</span>
<span class="sd">        a window to get perfect edges. However this does not necessary align</span>
<span class="sd">        with the exact duration provided by the metadata due to the signals</span>
<span class="sd">        being sampled at discrete values. Therefore after the windowing the</span>
<span class="sd">        final duration is computed again and updated in the metadata attribute.</span>
<span class="sd">        </span>
<span class="sd">        Attributes</span>
<span class="sd">        ----------</span>
<span class="sd">        strains : dict[dict]</span>
<span class="sd">            Creates the strains attribute with the properties stated at the</span>
<span class="sd">            class&#39; docstring.</span>
<span class="sd">        </span>
<span class="sd">        _dict_depth : int</span>
<span class="sd">            Number of nested layers in strains&#39; dictionary.</span>
<span class="sd">        </span>
<span class="sd">        metadata : pd.DataFrame</span>
<span class="sd">            Updates the duration of the waveforms after shrinking them.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;&#39;metadata&#39; needs to be generated first!&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">strains</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_init_strains_dict</span><span class="p">()</span>

        <span class="n">t_max</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_rate</span>
        <span class="n">times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">t_max</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_length</span><span class="p">)</span>
        
        <span class="k">for</span> <span class="nb">id</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">)):</span>
            <span class="n">params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="nb">id</span><span class="p">]</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()</span>
            <span class="n">clas</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;Class&#39;</span><span class="p">]</span>
            <span class="k">match</span> <span class="n">clas</span><span class="p">:</span>
                <span class="k">case</span> <span class="s1">&#39;SG&#39;</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">strains</span><span class="p">[</span><span class="n">clas</span><span class="p">][</span><span class="nb">id</span><span class="p">]</span> <span class="o">=</span> <span class="n">synthetic</span><span class="o">.</span><span class="n">sine_gaussian_waveform</span><span class="p">(</span>
                        <span class="n">times</span><span class="p">,</span>
                        <span class="n">t0</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">peak_time_max_length</span><span class="p">,</span>
                        <span class="n">f0</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="nb">id</span><span class="p">,</span><span class="s1">&#39;f0&#39;</span><span class="p">],</span>
                        <span class="n">Q</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="nb">id</span><span class="p">,</span><span class="s1">&#39;Q&#39;</span><span class="p">],</span>
                        <span class="n">hrss</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="nb">id</span><span class="p">,</span><span class="s1">&#39;hrss&#39;</span><span class="p">]</span>
                    <span class="p">)</span>
                <span class="k">case</span> <span class="s1">&#39;G&#39;</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">strains</span><span class="p">[</span><span class="n">clas</span><span class="p">][</span><span class="nb">id</span><span class="p">]</span> <span class="o">=</span> <span class="n">synthetic</span><span class="o">.</span><span class="n">gaussian_waveform</span><span class="p">(</span>
                        <span class="n">times</span><span class="p">,</span>
                        <span class="n">t0</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">peak_time_max_length</span><span class="p">,</span>
                        <span class="n">hrss</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="nb">id</span><span class="p">,</span><span class="s1">&#39;hrss&#39;</span><span class="p">],</span>
                        <span class="n">duration</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="nb">id</span><span class="p">,</span><span class="s1">&#39;duration&#39;</span><span class="p">],</span>
                        <span class="n">amp_threshold</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">amp_threshold</span>
                    <span class="p">)</span>
                <span class="k">case</span> <span class="s1">&#39;RD&#39;</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">strains</span><span class="p">[</span><span class="n">clas</span><span class="p">][</span><span class="nb">id</span><span class="p">]</span> <span class="o">=</span> <span class="n">synthetic</span><span class="o">.</span><span class="n">ring_down_waveform</span><span class="p">(</span>
                        <span class="n">times</span><span class="p">,</span>
                        <span class="n">t0</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">peak_time_max_length</span><span class="p">,</span>
                        <span class="n">f0</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="nb">id</span><span class="p">,</span><span class="s1">&#39;f0&#39;</span><span class="p">],</span>
                        <span class="n">Q</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="nb">id</span><span class="p">,</span><span class="s1">&#39;Q&#39;</span><span class="p">],</span>
                        <span class="n">hrss</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="nb">id</span><span class="p">,</span><span class="s1">&#39;hrss&#39;</span><span class="p">]</span>
                    <span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">_dict_depth</span> <span class="o">=</span> <span class="n">dictools</span><span class="o">.</span><span class="n">get_depth</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">strains</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_apply_threshold_windowing</span><span class="p">()</span>
    
    <span class="k">def</span> <span class="nf">_random_log_uniform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">min</span><span class="p">,</span> <span class="nb">max</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a random number between [min, max] spaced logarithmically.&quot;&quot;&quot;</span>

        <span class="n">exponent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rng</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="nb">min</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="nb">max</span><span class="p">))</span>
        <span class="n">random</span> <span class="o">=</span> <span class="mi">10</span><span class="o">**</span><span class="n">exponent</span>

        <span class="k">return</span> <span class="n">random</span>
    
    <span class="k">def</span> <span class="nf">_random_log_int</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">min</span><span class="p">,</span> <span class="nb">max</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a random integer between [min, max] spaced logarithmically.&quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_random_log_uniform</span><span class="p">(</span><span class="nb">min</span><span class="p">,</span> <span class="nb">max</span><span class="p">))</span>

    
    <span class="k">def</span> <span class="nf">_gen_parameters_sine_gaussian</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate random parameters for a single Sine Gaussian.&quot;&quot;&quot;</span>

        <span class="n">limits</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wave_parameters_limits</span>
        <span class="n">thres</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">amp_threshold</span>
        <span class="n">f0</span>   <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_random_log_int</span><span class="p">(</span><span class="n">limits</span><span class="p">[</span><span class="s1">&#39;mf0&#39;</span><span class="p">],</span> <span class="n">limits</span><span class="p">[</span><span class="s1">&#39;Mf0&#39;</span><span class="p">])</span>  <span class="c1"># Central frequency</span>
        <span class="n">Q</span>    <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_random_log_int</span><span class="p">(</span><span class="n">limits</span><span class="p">[</span><span class="s1">&#39;mQ&#39;</span><span class="p">],</span> <span class="n">limits</span><span class="p">[</span><span class="s1">&#39;MQ&#39;</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># Quality factor</span>
        <span class="n">hrss</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_random_log_uniform</span><span class="p">(</span><span class="n">limits</span><span class="p">[</span><span class="s1">&#39;mhrss&#39;</span><span class="p">],</span> <span class="n">limits</span><span class="p">[</span><span class="s1">&#39;Mhrss&#39;</span><span class="p">])</span>
        <span class="n">duration</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">Q</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">f0</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">thres</span><span class="p">))</span>
        
        <span class="k">return</span> <span class="p">(</span><span class="n">f0</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">hrss</span><span class="p">,</span> <span class="n">duration</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_gen_parameters_gaussian</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate random parameters for a single Gaussian.&quot;&quot;&quot;</span>

        <span class="n">lims</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wave_parameters_limits</span>
        <span class="n">f0</span>   <span class="o">=</span> <span class="kc">None</span>  <span class="c1">#  Casted to np.nan afterwards.</span>
        <span class="n">Q</span>    <span class="o">=</span> <span class="kc">None</span>  <span class="c1">#-/</span>
        <span class="n">hrss</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_random_log_uniform</span><span class="p">(</span><span class="n">lims</span><span class="p">[</span><span class="s1">&#39;mhrss&#39;</span><span class="p">],</span> <span class="n">lims</span><span class="p">[</span><span class="s1">&#39;Mhrss&#39;</span><span class="p">])</span>
        <span class="n">duration</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_random_log_uniform</span><span class="p">(</span><span class="n">lims</span><span class="p">[</span><span class="s1">&#39;mT&#39;</span><span class="p">],</span> <span class="n">lims</span><span class="p">[</span><span class="s1">&#39;MT&#39;</span><span class="p">])</span>  <span class="c1"># Duration</span>
        
        <span class="k">return</span> <span class="p">(</span><span class="n">f0</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">hrss</span><span class="p">,</span> <span class="n">duration</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_gen_parameters_ring_down</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate random parameters for a single Ring-Down.&quot;&quot;&quot;</span>

        <span class="n">lims</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wave_parameters_limits</span>
        <span class="n">thres</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">amp_threshold</span>
        <span class="n">f0</span>   <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_random_log_int</span><span class="p">(</span><span class="n">lims</span><span class="p">[</span><span class="s1">&#39;mf0&#39;</span><span class="p">],</span> <span class="n">lims</span><span class="p">[</span><span class="s1">&#39;Mf0&#39;</span><span class="p">])</span>  <span class="c1"># Central frequency</span>
        <span class="n">Q</span>    <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_random_log_int</span><span class="p">(</span><span class="n">lims</span><span class="p">[</span><span class="s1">&#39;mQ&#39;</span><span class="p">],</span> <span class="n">lims</span><span class="p">[</span><span class="s1">&#39;MQ&#39;</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># Quality factor</span>
        <span class="n">hrss</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_random_log_uniform</span><span class="p">(</span><span class="n">lims</span><span class="p">[</span><span class="s1">&#39;mhrss&#39;</span><span class="p">],</span> <span class="n">lims</span><span class="p">[</span><span class="s1">&#39;Mhrss&#39;</span><span class="p">])</span>
        <span class="n">duration</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">Q</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">f0</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">thres</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="p">(</span><span class="n">f0</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">hrss</span><span class="p">,</span> <span class="n">duration</span><span class="p">)</span>

    <span class="n">_gen_parameters</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;SG&#39;</span><span class="p">:</span> <span class="n">_gen_parameters_sine_gaussian</span><span class="p">,</span>
        <span class="s1">&#39;G&#39;</span><span class="p">:</span> <span class="n">_gen_parameters_gaussian</span><span class="p">,</span>
        <span class="s1">&#39;RD&#39;</span><span class="p">:</span> <span class="n">_gen_parameters_ring_down</span>
    <span class="p">}</span>

    <span class="k">def</span> <span class="nf">_apply_threshold_windowing</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Shrink waves in the dataset and update its duration in the metadata.</span>

<span class="sd">        Shrink them according to their pre-computed duration in the metadata to</span>
<span class="sd">        avoid almost-but-not-zero edges, and correct those marginal durations</span>
<span class="sd">        longer than the window.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)):</span>
            <span class="n">clas</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="s1">&#39;Class&#39;</span><span class="p">]</span>
            <span class="n">duration</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="s1">&#39;duration&#39;</span><span class="p">]</span>
            <span class="n">ref_length</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">duration</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_rate</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="n">clas</span> <span class="o">==</span> <span class="s1">&#39;RD&#39;</span><span class="p">:</span>
                <span class="c1"># Ring-Down waves begin at the center. However we want to</span>
                <span class="c1"># emphasize their energetic beginning, therefore we will leave</span>
                <span class="c1"># a symmetric part before their start with zeros.</span>
                <span class="n">i0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_length</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">ref_length</span>
                <span class="n">i1</span> <span class="o">=</span> <span class="n">i0</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">ref_length</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># SG and G are both centered.</span>
                <span class="n">i0</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_length</span> <span class="o">-</span> <span class="n">ref_length</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
                <span class="n">i1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_length</span> <span class="o">-</span> <span class="n">i0</span>

            <span class="n">new_lenght</span> <span class="o">=</span> <span class="n">i1</span> <span class="o">-</span> <span class="n">i0</span>
            <span class="k">if</span> <span class="n">i0</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">new_lenght</span> <span class="o">+=</span> <span class="n">i0</span>
                <span class="n">i0</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="n">i1</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_length</span><span class="p">:</span>
                <span class="n">new_lenght</span> <span class="o">-=</span> <span class="n">i1</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_length</span>
                <span class="n">i1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_length</span>

            <span class="n">window</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">signal</span><span class="o">.</span><span class="n">windows</span><span class="o">.</span><span class="n">tukey</span><span class="p">(</span><span class="n">new_lenght</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tukey_alpha</span><span class="p">)</span>
            <span class="c1"># Shrink and window</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">strains</span><span class="p">[</span><span class="n">clas</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">strains</span><span class="p">[</span><span class="n">clas</span><span class="p">][</span><span class="n">i</span><span class="p">][</span><span class="n">i0</span><span class="p">:</span><span class="n">i1</span><span class="p">]</span> <span class="o">*</span> <span class="n">window</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="s1">&#39;duration&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_lenght</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_rate</span></div>



<div class="viewcode-block" id="InjectedSyntheticWaves">
<a class="viewcode-back" href="../../gwadama.datasets.html#gwadama.datasets.InjectedSyntheticWaves">[docs]</a>
<span class="k">class</span> <span class="nc">InjectedSyntheticWaves</span><span class="p">(</span><span class="n">BaseInjected</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;TODO</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="InjectedSyntheticWaves.__init__">
<a class="viewcode-back" href="../../gwadama.datasets.html#gwadama.datasets.InjectedSyntheticWaves.__init__">[docs]</a>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">clean_dataset</span><span class="p">:</span> <span class="n">SyntheticWaves</span><span class="p">,</span>
                 <span class="o">*</span><span class="p">,</span>
                 <span class="n">psd</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="n">Callable</span><span class="p">,</span>
                 <span class="n">detector</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                 <span class="n">noise_length</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                 <span class="n">freq_cutoff</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">float</span><span class="p">,</span>
                 <span class="n">freq_butter_order</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">float</span><span class="p">,</span>
                 <span class="n">random_seed</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">clean_dataset</span><span class="p">,</span> <span class="n">psd</span><span class="o">=</span><span class="n">psd</span><span class="p">,</span> <span class="n">detector</span><span class="o">=</span><span class="n">detector</span><span class="p">,</span> <span class="n">noise_length</span><span class="o">=</span><span class="n">noise_length</span><span class="p">,</span>
            <span class="n">freq_cutoff</span><span class="o">=</span><span class="n">freq_cutoff</span><span class="p">,</span> <span class="n">freq_butter_order</span><span class="o">=</span><span class="n">freq_butter_order</span><span class="p">,</span> <span class="n">random_seed</span><span class="o">=</span><span class="n">random_seed</span>
        <span class="p">)</span>

        <span class="c1"># Initialize the Train/Test subsets inheriting the indices of the input</span>
        <span class="c1"># clean dataset instance.</span>
        <span class="k">if</span> <span class="n">clean_dataset</span><span class="o">.</span><span class="n">Xtrain</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Xtrain</span> <span class="o">=</span> <span class="n">dictools</span><span class="o">.</span><span class="n">_replicate_structure_nested_dict</span><span class="p">(</span><span class="n">clean_dataset</span><span class="o">.</span><span class="n">Xtrain</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Xtest</span> <span class="o">=</span> <span class="n">dictools</span><span class="o">.</span><span class="n">_replicate_structure_nested_dict</span><span class="p">(</span><span class="n">clean_dataset</span><span class="o">.</span><span class="n">Xtest</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Ytrain</span> <span class="o">=</span> <span class="n">dictools</span><span class="o">.</span><span class="n">_replicate_structure_nested_dict</span><span class="p">(</span><span class="n">clean_dataset</span><span class="o">.</span><span class="n">Ytrain</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Ytest</span> <span class="o">=</span> <span class="n">dictools</span><span class="o">.</span><span class="n">_replicate_structure_nested_dict</span><span class="p">(</span><span class="n">clean_dataset</span><span class="o">.</span><span class="n">Ytest</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Xtrain</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Xtest</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Ytrain</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Ytest</span> <span class="o">=</span> <span class="kc">None</span></div>
</div>



<div class="viewcode-block" id="CoReWaves">
<a class="viewcode-back" href="../../gwadama.datasets.html#gwadama.datasets.CoReWaves">[docs]</a>
<span class="k">class</span> <span class="nc">CoReWaves</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Manage all operations needed to perform over a noiseless CoRe dataset.</span>

<span class="sd">    Initial strains and metadata are obtained from a CoReManager instance.</span>

<span class="sd">    NOTE: This class treats as different classes (categories) each equation of</span>
<span class="sd">    state (EOS) present in the CoReManager instance.</span>

<span class="sd">    NOTE^2: This class adds a time attribute with time samples related to each</span>
<span class="sd">    GW.</span>

<span class="sd">    Workflow:</span>
<span class="sd">    </span>
<span class="sd">    - Load the strains from a CoreWaEasy instance, discarding or cropping those</span>
<span class="sd">      indicated with their respective arguments.</span>
<span class="sd">    </span>
<span class="sd">    - Resample.</span>
<span class="sd">    </span>
<span class="sd">    - Project onto the ET detector arms.</span>
<span class="sd">    </span>
<span class="sd">    - Change units and scale from geometrized to IS and vice versa.</span>
<span class="sd">    </span>
<span class="sd">    - Export the (latest version of) dataset to a HDF5.</span>
<span class="sd">    </span>
<span class="sd">    - Export the (latest version of) dataset to a GWF.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    classes : dict</span>
<span class="sd">        Dict of strings and their integer labels, one per class (category).</span>
<span class="sd">        The keys are the name of the Equation of State (EOS) used to describe</span>
<span class="sd">        the physics behind the simulation which produced each strain.</span>
<span class="sd">    </span>
<span class="sd">    strains : dict {class: {id: gw_strain} }</span>
<span class="sd">        Strains stored as a nested dictionary, with each strain in an</span>
<span class="sd">        independent array to provide more flexibility with data of a wide</span>
<span class="sd">        range of lengths.</span>
<span class="sd">        The class key is the name of the class, a string which must exist in</span>
<span class="sd">        the &#39;classes&#39; list.</span>
<span class="sd">        The &#39;id&#39; is an unique identifier for each strain, and must exist in the</span>
<span class="sd">        `self.metadata.index` column of the metadata DataFrame.</span>
<span class="sd">        Initially, an extra depth layer is defined to store the polarizations</span>
<span class="sd">        of the CoRe GW simulated data. After the projection this layer will be</span>
<span class="sd">        collapsed to a single strain.</span>
<span class="sd">    </span>
<span class="sd">    times : dict {class: {id: gw_time_points} }</span>
<span class="sd">        Time samples associated with the strains, following the same structure.</span>
<span class="sd">        Useful when the sampling rate is variable or different between strains.</span>
<span class="sd">    </span>
<span class="sd">    metadata : pandas.DataFrame</span>
<span class="sd">        All parameters and data related to the strains.</span>
<span class="sd">        The order is the same as inside &#39;strains&#39; if unrolled to a flat list</span>
<span class="sd">        of strains up to the second depth level (the id.).</span>
<span class="sd">        Example:</span>
<span class="sd">        </span>
<span class="sd">        ```</span>
<span class="sd">        metadata[eos][key] = {</span>
<span class="sd">            &#39;id&#39;: str,</span>
<span class="sd">            &#39;mass&#39;: float,</span>
<span class="sd">            &#39;mass_ratio&#39;: float,</span>
<span class="sd">            &#39;eccentricity&#39;: float,</span>
<span class="sd">            &#39;mass_starA&#39;: float,</span>
<span class="sd">            &#39;mass_starB&#39;: float,</span>
<span class="sd">            &#39;spin_starA&#39;: float,</span>
<span class="sd">            &#39;spin_starB&#39;: float</span>
<span class="sd">        }</span>
<span class="sd">        ```</span>
<span class="sd">    </span>
<span class="sd">    units : str</span>
<span class="sd">        Flag indicating whether the data is in &#39;geometrized&#39; or &#39;IS&#39; units.</span>
<span class="sd">    </span>
<span class="sd">    sample_rate : int, optional</span>
<span class="sd">        Initially this attribute is None because the initial GW from CoRe are</span>
<span class="sd">        sampled at different and non-constant sampling rates. After the</span>
<span class="sd">        resampling, this attribute will be set to the new global sampling rate.</span>

<span class="sd">        Caveat: If the &#39;times&#39; attribute is present, this value is ignored.</span>
<span class="sd">        Otherwise it is assumed all strains are constantly sampled to this.</span>

<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="CoReWaves.__init__">
<a class="viewcode-back" href="../../gwadama.datasets.html#gwadama.datasets.CoReWaves.__init__">[docs]</a>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="o">*</span><span class="p">,</span>
                 <span class="n">coredb</span><span class="p">:</span> <span class="n">ioo</span><span class="o">.</span><span class="n">CoReManager</span><span class="p">,</span>
                 <span class="n">classes</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
                 <span class="n">discarded</span><span class="p">:</span> <span class="nb">set</span><span class="p">,</span>
                 <span class="n">cropped</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span>
                 <span class="c1"># Source:</span>
                 <span class="n">distance</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
                 <span class="n">inclination</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
                 <span class="n">phi</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize a CoReWaves dataset.</span>

<span class="sd">        TODO</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        coredb : ioo.CoReManager</span>
<span class="sd">            Instance of CoReManager with the actual data.</span>
<span class="sd">        </span>
<span class="sd">        classes : dict[str]</span>
<span class="sd">            Dictionary with the Equation of State (class) name as key and the</span>
<span class="sd">            corresponding label index as value.</span>
<span class="sd">        </span>
<span class="sd">        discarded : set[str]</span>
<span class="sd">            Set of GW IDs to discard from the dataset.</span>
<span class="sd">        </span>
<span class="sd">        cropped : dict[str]</span>
<span class="sd">            Dictionary with the class name as key and the corresponding</span>
<span class="sd">            cropping range as value. The range is given as a tuple of the form</span>
<span class="sd">            (start_index, stop_index).</span>
<span class="sd">        </span>
<span class="sd">        distance : float</span>
<span class="sd">            Distance to the source in Mpc.</span>
<span class="sd">        </span>
<span class="sd">        inclination : float</span>
<span class="sd">            Inclination of the source in radians.</span>
<span class="sd">        </span>
<span class="sd">        phi : float</span>
<span class="sd">            Azimuthal angle of the source in radians.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_classes_dict</span><span class="p">(</span><span class="n">classes</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">classes</span> <span class="o">=</span> <span class="n">classes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">discarded</span> <span class="o">=</span> <span class="n">discarded</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cropped</span> <span class="o">=</span> <span class="n">cropped</span>
        <span class="c1"># Source parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">distance</span> <span class="o">=</span> <span class="n">distance</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">inclination</span> <span class="o">=</span> <span class="n">inclination</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">phi</span> <span class="o">=</span> <span class="n">phi</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">units</span> <span class="o">=</span> <span class="s1">&#39;IS&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">strains</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_strain_and_metadata</span><span class="p">(</span><span class="n">coredb</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_track_times</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dict_depth</span> <span class="o">=</span> <span class="n">dictools</span><span class="o">.</span><span class="n">get_depth</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">strains</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gen_labels</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_length</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_max_length</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">sample_rate</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># Set up after resampling</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">random_seed</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># Set if calling the &#39;build_train_test_subsets&#39; method.</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">whitened</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">whiten_params</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nonwhiten_strains</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Train/Test subset splits (views into the same &#39;self.strains&#39;).</span>
        <span class="c1">#   Timeseries:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Xtrain</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Xtest</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1">#   Labels:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Ytrain</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Ytest</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span></div>

    
    <span class="k">def</span> <span class="nf">_get_strain_and_metadata</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coredb</span><span class="p">:</span> <span class="n">ioo</span><span class="o">.</span><span class="n">CoReManager</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">dict</span><span class="p">,</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Obtain the strain and metadata from a CoReManager instance.</span>

<span class="sd">        The strains are the Pluss and Cross polarizations obtained from the</span>
<span class="sd">        direct output of numerical relativistic simulations. They are expected</span>
<span class="sd">        to be projected at the detector afterwards, collapsing the polarization</span>
<span class="sd">        layer to a single strain per GW.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        strains : dict{eos: {id: {pol: strain} } }</span>
<span class="sd">        </span>
<span class="sd">        times : dict{&#39;eos&#39;: {&#39;id&#39;: {pol: time_samples}} }</span>
<span class="sd">            Time samples associated to each GW.</span>
<span class="sd">            Since it has to follow the same nested structure as &#39;strains&#39;, but</span>
<span class="sd">            the time samples are the same among polarizations, for each GW both</span>
<span class="sd">            polarizations point to the same array in memory.</span>
<span class="sd">        </span>
<span class="sd">        metadata : pandas.DataFrame</span>
<span class="sd">            All parameters and data related to the strains.</span>
<span class="sd">            The order is the same as inside &#39;strains&#39; if unrolled to a flat list</span>
<span class="sd">            of strains up to the second depth level (the id.).</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">strains</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_init_strains_dict</span><span class="p">()</span>
        <span class="n">times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_init_strains_dict</span><span class="p">()</span>
        <span class="c1"># Metadata columns/keys:</span>
        <span class="n">index</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">mass</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">mass_ratio</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">eccentricity</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">lambda_tidal</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># Tidal deformability</span>
        <span class="n">mass_starA</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">mass_starB</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">spin_starA</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">spin_starB</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">merger_pos</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># Index position of the merger inside the array.</span>

        <span class="k">for</span> <span class="n">eos</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">classes</span><span class="p">:</span>
            <span class="c1"># Get and filter out GW simulations.</span>
            <span class="n">ids</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">coredb</span><span class="o">.</span><span class="n">filter_by</span><span class="p">(</span><span class="s1">&#39;id_eos&#39;</span><span class="p">,</span> <span class="n">eos</span><span class="p">)</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">ids</span> <span class="o">-=</span> <span class="bp">self</span><span class="o">.</span><span class="n">discarded</span><span class="p">[</span><span class="n">eos</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="k">pass</span>  <span class="c1"># No discards.</span>
            <span class="n">ids</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">ids</span><span class="p">)</span>  <span class="c1"># IMPORTANT!!! Keep order to be able to trace back simulations.</span>
            
            <span class="k">for</span> <span class="n">id_</span> <span class="ow">in</span> <span class="n">ids</span><span class="p">:</span>
                <span class="c1"># CoRe Rh data (in IS units):</span>
                <span class="n">times_</span><span class="p">,</span> <span class="n">h_plus</span><span class="p">,</span> <span class="n">h_cros</span> <span class="o">=</span> <span class="n">coredb</span><span class="o">.</span><span class="n">gen_strain</span><span class="p">(</span>
                    <span class="n">id_</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">distance</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">inclination</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">phi</span>
                <span class="p">)</span>

                <span class="c1"># Crop those indicated at the parameter file, and leave whole</span>
                <span class="c1"># the rest.</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">t0</span><span class="p">,</span> <span class="n">t1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cropped</span><span class="p">[</span><span class="n">eos</span><span class="p">][</span><span class="n">id_</span><span class="p">]</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="n">crop</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">crop</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">times_</span><span class="o">-</span><span class="n">t0</span><span class="p">)),</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">times_</span><span class="o">-</span><span class="n">t1</span><span class="p">))</span>
                    <span class="p">)</span>
                <span class="n">strains</span><span class="p">[</span><span class="n">eos</span><span class="p">][</span><span class="n">id_</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="s1">&#39;plus&#39;</span><span class="p">:</span> <span class="n">h_plus</span><span class="p">[</span><span class="n">crop</span><span class="p">],</span>
                    <span class="s1">&#39;cross&#39;</span><span class="p">:</span> <span class="n">h_cros</span><span class="p">[</span><span class="n">crop</span><span class="p">]</span>
                <span class="p">}</span>
                <span class="c1"># Both polarizations have the same sampling times, hence we</span>
                <span class="c1"># point each time polarization to the same array in memory.</span>
                <span class="n">times</span><span class="p">[</span><span class="n">eos</span><span class="p">][</span><span class="n">id_</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="n">times</span><span class="p">[</span><span class="n">eos</span><span class="p">][</span><span class="n">id_</span><span class="p">][</span><span class="s1">&#39;plus&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">times</span><span class="p">[</span><span class="n">eos</span><span class="p">][</span><span class="n">id_</span><span class="p">][</span><span class="s1">&#39;cross&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">times_</span><span class="p">[</span><span class="n">crop</span><span class="p">]</span>
                
                <span class="c1"># The time is centered at the merger.</span>
                <span class="n">i_merger</span> <span class="o">=</span> <span class="n">tat</span><span class="o">.</span><span class="n">find_time_origin</span><span class="p">(</span><span class="n">times_</span><span class="p">[</span><span class="n">crop</span><span class="p">])</span>

                <span class="c1"># Associated metadata:</span>
                <span class="n">md</span> <span class="o">=</span> <span class="n">coredb</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">id_</span><span class="p">]</span>
                <span class="n">index</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">md</span><span class="p">[</span><span class="s1">&#39;database_key&#39;</span><span class="p">])</span>
                <span class="n">mass</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">md</span><span class="p">[</span><span class="s1">&#39;id_mass&#39;</span><span class="p">])</span>
                <span class="n">mass_ratio</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">md</span><span class="p">[</span><span class="s1">&#39;id_mass_ratio&#39;</span><span class="p">])</span>
                <span class="n">eccentricity</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">md</span><span class="p">[</span><span class="s1">&#39;id_eccentricity&#39;</span><span class="p">])</span>
                <span class="n">lambda_tidal</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">md</span><span class="p">[</span><span class="s1">&#39;id_Lambda&#39;</span><span class="p">])</span>
                <span class="n">mass_starA</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">md</span><span class="p">[</span><span class="s1">&#39;id_mass_starA&#39;</span><span class="p">])</span>
                <span class="n">mass_starB</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">md</span><span class="p">[</span><span class="s1">&#39;id_mass_starB&#39;</span><span class="p">])</span>
                <span class="n">spin_starA</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">md</span><span class="p">[</span><span class="s1">&#39;id_spin_starA&#39;</span><span class="p">])</span>
                <span class="n">spin_starB</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">md</span><span class="p">[</span><span class="s1">&#39;id_spin_starB&#39;</span><span class="p">])</span>
                <span class="n">merger_pos</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i_merger</span><span class="p">)</span>
        
        <span class="n">metadata</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
            <span class="n">data</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
                <span class="n">mass</span><span class="o">=</span><span class="n">mass</span><span class="p">,</span> <span class="n">mass_ratio</span><span class="o">=</span><span class="n">mass_ratio</span><span class="p">,</span>
                <span class="n">eccentricity</span><span class="o">=</span><span class="n">eccentricity</span><span class="p">,</span> <span class="n">lambda_tidal</span><span class="o">=</span><span class="n">lambda_tidal</span><span class="p">,</span>
                <span class="n">mass_starA</span><span class="o">=</span><span class="n">mass_starA</span><span class="p">,</span> <span class="n">mass_starB</span><span class="o">=</span><span class="n">mass_starB</span><span class="p">,</span>
                <span class="n">spin_starA</span><span class="o">=</span><span class="n">spin_starA</span><span class="p">,</span> <span class="n">spin_starB</span><span class="o">=</span><span class="n">spin_starB</span><span class="p">,</span>
                <span class="n">merger_pos</span><span class="o">=</span><span class="n">merger_pos</span>
            <span class="p">),</span>
            <span class="n">index</span><span class="o">=</span><span class="n">index</span>
        <span class="p">)</span>
        
        <span class="k">return</span> <span class="n">strains</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> <span class="n">metadata</span>
    
<div class="viewcode-block" id="CoReWaves.find_merger">
<a class="viewcode-back" href="../../gwadama.datasets.html#gwadama.datasets.CoReWaves.find_merger">[docs]</a>
    <span class="k">def</span> <span class="nf">find_merger</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">strain</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">clawdia.estimators</span> <span class="kn">import</span> <span class="n">find_merger</span>
        <span class="k">return</span> <span class="n">find_merger</span><span class="p">(</span><span class="n">strain</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">_update_merger_positions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Update all &#39;merger_pos&#39; tags inside the metadata attribute.</span>
<span class="sd">        </span>
<span class="sd">        Time arrays are defined with the origin at the merger. When the length</span>
<span class="sd">        of the strain arrays is modified, the index position of the merger</span>
<span class="sd">        must be updated.</span>

<span class="sd">        NOTE: This method updates ALL the merger positions.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">clas</span><span class="p">,</span> <span class="n">id_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">(</span><span class="n">max_depth</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
            <span class="n">times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="n">clas</span><span class="p">][</span><span class="n">id_</span><span class="p">]</span>
            <span class="c1"># If more layers are present, only get the first instance of times</span>
            <span class="c1"># since all will be the same.</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="n">times</span> <span class="o">=</span> <span class="n">dictools</span><span class="o">.</span><span class="n">get_next_item</span><span class="p">(</span><span class="n">times</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">id_</span><span class="p">,</span><span class="s1">&#39;merger_pos&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tat</span><span class="o">.</span><span class="n">find_time_origin</span><span class="p">(</span><span class="n">times</span><span class="p">)</span>
    
<div class="viewcode-block" id="CoReWaves.resample">
<a class="viewcode-back" href="../../gwadama.datasets.html#gwadama.datasets.CoReWaves.resample">[docs]</a>
    <span class="k">def</span> <span class="nf">resample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sample_rate</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Resample strain and time arrays to a constant rate.</span>

<span class="sd">        Resample CoRe strains (from NR simulations) to a constant rate.</span>

<span class="sd">        This method updates the sample_rate, the max_length and the merger_pos</span>
<span class="sd">        inside the metadata attribute.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sample_rate : int</span>
<span class="sd">            The new sampling rate in Hz.</span>

<span class="sd">        verbose : bool</span>
<span class="sd">            If True, print information about the resampling.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">resample</span><span class="p">(</span><span class="n">sample_rate</span><span class="p">,</span> <span class="n">verbose</span><span class="p">)</span>

        <span class="c1"># Update side-effect attributes.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_merger_positions</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">Xtrain</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_train_test_subsets</span><span class="p">()</span></div>


<div class="viewcode-block" id="CoReWaves.project">
<a class="viewcode-back" href="../../gwadama.datasets.html#gwadama.datasets.CoReWaves.project">[docs]</a>
    <span class="k">def</span> <span class="nf">project</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">detector</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">ra</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">dec</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">geo_time</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">psi</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Project strains into the chosen detector at specified coordinates.</span>

<span class="sd">        Project strains into the chosen detector at specified coordinates,</span>
<span class="sd">        using Bilby.</span>

<span class="sd">        This collapses the polarization layer in &#39;strains&#39; and &#39;times&#39; to a</span>
<span class="sd">        single strain.</span>
<span class="sd">        The times are rebuilt taking as a reference point the merger (t = 0).</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        detector : str</span>
<span class="sd">            Name of the ET arm in Bilby for InterferometerList().</span>
<span class="sd">        </span>
<span class="sd">        ra, dec : float</span>
<span class="sd">            Sky position in equatorial coordinates.</span>
<span class="sd">        </span>
<span class="sd">        geo_time : int | float</span>
<span class="sd">            Time of injection in GPS.</span>
<span class="sd">        </span>
<span class="sd">        psi : float</span>
<span class="sd">            Polarization angle.</span>

<span class="sd">        Caveats</span>
<span class="sd">        -------</span>
<span class="sd">        - The detector&#39;s name must exist in Bilby&#39;s InterferometerList().</span>
<span class="sd">        - Only one arm can be chosen.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">project_pars</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">ra</span><span class="o">=</span><span class="n">ra</span><span class="p">,</span> <span class="n">dec</span><span class="o">=</span><span class="n">dec</span><span class="p">,</span> <span class="n">geocent_time</span><span class="o">=</span><span class="n">geo_time</span><span class="p">,</span> <span class="n">psi</span><span class="o">=</span><span class="n">psi</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">clas</span><span class="p">,</span> <span class="n">id_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">(</span><span class="n">max_depth</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
            <span class="n">hp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">strains</span><span class="p">[</span><span class="n">clas</span><span class="p">][</span><span class="n">id_</span><span class="p">][</span><span class="s1">&#39;plus&#39;</span><span class="p">]</span>
            <span class="n">hc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">strains</span><span class="p">[</span><span class="n">clas</span><span class="p">][</span><span class="n">id_</span><span class="p">][</span><span class="s1">&#39;cross&#39;</span><span class="p">]</span>
            
            <span class="c1"># Drop the polarization layer.</span>
            <span class="n">strain</span> <span class="o">=</span> <span class="n">detectors</span><span class="o">.</span><span class="n">project</span><span class="p">(</span>
                <span class="n">hp</span><span class="p">,</span> <span class="n">hc</span><span class="p">,</span> <span class="n">parameters</span><span class="o">=</span><span class="n">project_pars</span><span class="p">,</span> <span class="n">sf</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_rate</span><span class="p">,</span> 
                <span class="n">nfft</span><span class="o">=</span><span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_rate</span><span class="p">,</span> <span class="n">detector</span><span class="o">=</span><span class="n">detector</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">strains</span><span class="p">[</span><span class="n">clas</span><span class="p">][</span><span class="n">id_</span><span class="p">]</span> <span class="o">=</span> <span class="n">strain</span>
            
            <span class="c1"># Regenerate the time array with the merger located at the origin.</span>
            <span class="n">duration</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">strain</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_rate</span>
            <span class="n">t_merger</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_merger</span><span class="p">(</span><span class="n">strain</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_rate</span>
            <span class="n">t0</span> <span class="o">=</span> <span class="o">-</span><span class="n">t_merger</span>
            <span class="n">t1</span> <span class="o">=</span> <span class="n">duration</span> <span class="o">-</span> <span class="n">t_merger</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="n">clas</span><span class="p">][</span><span class="n">id_</span><span class="p">]</span> <span class="o">=</span> <span class="n">tat</span><span class="o">.</span><span class="n">gen_time_array</span><span class="p">(</span><span class="n">t0</span><span class="p">,</span> <span class="n">t1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_rate</span><span class="p">)</span>
        
        <span class="c1"># Update side-effect attributes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dict_depth</span> <span class="o">=</span> <span class="n">dictools</span><span class="o">.</span><span class="n">get_depth</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">strains</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_merger_positions</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_length</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_max_length</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">Xtrain</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_train_test_subsets</span><span class="p">()</span></div>

    
<div class="viewcode-block" id="CoReWaves.shrink_to_merger">
<a class="viewcode-back" href="../../gwadama.datasets.html#gwadama.datasets.CoReWaves.shrink_to_merger">[docs]</a>
    <span class="k">def</span> <span class="nf">shrink_to_merger</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">offset</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Shrink strains and time arrays w.r.t. the merger.</span>

<span class="sd">        Shrink strains (and their associated time arrays) discarding the left</span>
<span class="sd">        side of the merger (inspiral), with a given offset in samples.</span>

<span class="sd">        This also updates the metadata column &#39;merger_pos&#39;.</span>

<span class="sd">        NOTE: This is an irreversible action.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        offset : int</span>
<span class="sd">            Offset in samples relative to the merger position.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">limits</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">clas</span><span class="p">,</span> <span class="nb">id</span><span class="p">,</span> <span class="o">*</span><span class="n">keys</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">i_merger</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="nb">id</span><span class="p">,</span> <span class="s1">&#39;merger_pos&#39;</span><span class="p">]</span>
            <span class="c1"># Same shrinking limits for all possible strains below ID layer.</span>
            <span class="n">limits</span><span class="p">[</span><span class="nb">id</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">i_merger</span><span class="o">+</span><span class="n">offset</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">shrink_strains</span><span class="p">(</span><span class="n">limits</span><span class="p">)</span>

        <span class="c1"># Update side-effect attributes.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_merger_positions</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">Xtrain</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_train_test_subsets</span><span class="p">()</span></div>


<div class="viewcode-block" id="CoReWaves.convert_to_IS_units">
<a class="viewcode-back" href="../../gwadama.datasets.html#gwadama.datasets.CoReWaves.convert_to_IS_units">[docs]</a>
    <span class="k">def</span> <span class="nf">convert_to_IS_units</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Convert data from scaled geometrized units to IS units.</span>

<span class="sd">        Convert strains and times from geometrized units (scaled to the mass</span>
<span class="sd">        of the system and the source distance) to IS units.</span>
<span class="sd">        </span>
<span class="sd">        Will raise an error if the data is already in IS units.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">units</span> <span class="o">==</span> <span class="s1">&#39;IS&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;data already in IS units&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">keys</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">id_</span> <span class="o">=</span> <span class="n">keys</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">mass</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">id_</span><span class="p">,</span><span class="s1">&#39;mass&#39;</span><span class="p">]</span>
            <span class="n">strain</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_strain</span><span class="p">(</span><span class="o">*</span><span class="n">keys</span><span class="p">)</span>
            <span class="n">times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_times</span><span class="p">(</span><span class="o">*</span><span class="n">keys</span><span class="p">)</span>

            <span class="n">strain</span> <span class="o">*=</span>  <span class="n">mass</span> <span class="o">*</span> <span class="n">MSUN_MET</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">distance</span> <span class="o">*</span> <span class="n">MPC_MET</span><span class="p">)</span>
            <span class="n">times</span> <span class="o">*=</span> <span class="n">mass</span> <span class="o">*</span> <span class="n">MSUN_SEC</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">units</span> <span class="o">=</span> <span class="s1">&#39;IS&#39;</span>

        <span class="c1"># Update side-effect attributes.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">Xtrain</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_train_test_subsets</span><span class="p">()</span></div>

    
<div class="viewcode-block" id="CoReWaves.convert_to_scaled_geometrized_units">
<a class="viewcode-back" href="../../gwadama.datasets.html#gwadama.datasets.CoReWaves.convert_to_scaled_geometrized_units">[docs]</a>
    <span class="k">def</span> <span class="nf">convert_to_scaled_geometrized_units</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Convert data from IS to scaled geometrized units.</span>
<span class="sd">        </span>
<span class="sd">        Convert strains and times from IS to geometrized units, and scaled to the mass</span>
<span class="sd">        of the system and the source distance.</span>

<span class="sd">        Will raise an error if the data is already in geometrized units.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">units</span> <span class="o">==</span> <span class="s1">&#39;geometrized&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;data already in geometrized units&quot;</span><span class="p">)</span>
        
        <span class="k">for</span> <span class="n">keys</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">id_</span> <span class="o">=</span> <span class="n">keys</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">mass</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">id_</span><span class="p">,</span><span class="s1">&#39;mass&#39;</span><span class="p">]</span>
            <span class="n">strain</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_strain</span><span class="p">(</span><span class="o">*</span><span class="n">keys</span><span class="p">)</span>
            <span class="n">times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_times</span><span class="p">(</span><span class="o">*</span><span class="n">keys</span><span class="p">)</span>
            
            <span class="n">strain</span> <span class="o">/=</span>  <span class="n">mass</span> <span class="o">*</span> <span class="n">MSUN_MET</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">distance</span> <span class="o">*</span> <span class="n">MPC_MET</span><span class="p">)</span>
            <span class="n">times</span> <span class="o">/=</span> <span class="n">mass</span> <span class="o">*</span> <span class="n">MSUN_SEC</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">units</span> <span class="o">=</span> <span class="s1">&#39;geometrized&#39;</span>

        <span class="c1"># Update side-effect attributes.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">Xtrain</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_train_test_subsets</span><span class="p">()</span></div>
</div>



<div class="viewcode-block" id="InjectedCoReWaves">
<a class="viewcode-back" href="../../gwadama.datasets.html#gwadama.datasets.InjectedCoReWaves">[docs]</a>
<span class="k">class</span> <span class="nc">InjectedCoReWaves</span><span class="p">(</span><span class="n">BaseInjected</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Manage injections of GW data from CoRe dataset.</span>
<span class="sd">    </span>
<span class="sd">    - Tracks index position of the merger.</span>
<span class="sd">    </span>
<span class="sd">    - Computes the SNR only at the ring-down starting from the merger.</span>
<span class="sd">    </span>
<span class="sd">    - Computes also the usual SNR over the whole signal and stores it for</span>
<span class="sd">      later reference (attr. &#39;whole_snr_list&#39;).</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    snr_list : list</span>
<span class="sd">        Partial SNR values at which each signal is injected.</span>
<span class="sd">        This SNR is computed ONLY over the Ring-Down section of the waveform</span>
<span class="sd">        starting from the merger, hence the name &#39;partial SNR&#39;.</span>

<span class="sd">    whole_snr : dict</span>
<span class="sd">        Nested dictionary storing for each injection the equivalent SNR value</span>
<span class="sd">        computed over the whole signal, hence the name &#39;whole SNR&#39;.</span>
<span class="sd">        Structure: {id_: {partial_snr: whole_snr}}</span>

<span class="sd">    TODO</span>

<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="InjectedCoReWaves.__init__">
<a class="viewcode-back" href="../../gwadama.datasets.html#gwadama.datasets.InjectedCoReWaves.__init__">[docs]</a>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">clean_dataset</span><span class="p">:</span> <span class="n">Base</span><span class="p">,</span>
                 <span class="o">*</span><span class="p">,</span>
                 <span class="n">psd</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="n">Callable</span><span class="p">,</span>
                 <span class="n">detector</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                 <span class="n">noise_length</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                 <span class="n">whiten_params</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span>
                 <span class="n">freq_cutoff</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">float</span><span class="p">,</span>
                 <span class="n">freq_butter_order</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">float</span><span class="p">,</span>
                 <span class="n">random_seed</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initializes an instance of the InjectedCoReWaves class.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        clean_dataset : Base</span>
<span class="sd">            An instance of a BaseDataset class with noiseless signals.</span>
<span class="sd">        </span>
<span class="sd">        psd : np.ndarray | Callable</span>
<span class="sd">            Power Spectral Density of the detector&#39;s sensitivity in the</span>
<span class="sd">            range of frequencies of interest.</span>
<span class="sd">            Can be given as a callable function whose argument is</span>
<span class="sd">            expected to be an array of frequencies, or as a 2d-array</span>
<span class="sd">            with shape (2, psd_length) so that</span>

<span class="sd">            ```</span>
<span class="sd">                psd[0] = frequency_samples</span>
<span class="sd">                psd[1] = psd_samples.</span>
<span class="sd">            ```</span>
<span class="sd">            </span>
<span class="sd">            NOTE: It is also used to compute the &#39;asd&#39; attribute (ASD).</span>
<span class="sd">        </span>
<span class="sd">        detector : str</span>
<span class="sd">            GW detector name.</span>
<span class="sd">        </span>
<span class="sd">        noise_length : int</span>
<span class="sd">            Length of the background noise array to be generated for</span>
<span class="sd">            later use.</span>
<span class="sd">            It should be at least longer than the longest signal</span>
<span class="sd">            expected to be injected.</span>
<span class="sd">        </span>
<span class="sd">        whiten_params : dict</span>
<span class="sd">            Parameters to be passed to the &#39;whiten&#39; method of the</span>
<span class="sd">            &#39;BaseInjected&#39; class.</span>
<span class="sd">        </span>
<span class="sd">        freq_cutoff : int | float</span>
<span class="sd">            Frequency cutoff for the filter applied to the signal.</span>
<span class="sd">        </span>
<span class="sd">        freq_butter_order : int | float</span>
<span class="sd">            Order of the Butterworth filter applied to the signal.</span>
<span class="sd">        </span>
<span class="sd">        random_seed : int</span>
<span class="sd">            Random seed for generating random numbers.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">clean_dataset</span><span class="p">,</span> <span class="n">psd</span><span class="o">=</span><span class="n">psd</span><span class="p">,</span> <span class="n">detector</span><span class="o">=</span><span class="n">detector</span><span class="p">,</span> <span class="n">noise_length</span><span class="o">=</span><span class="n">noise_length</span><span class="p">,</span>
            <span class="n">whiten_params</span><span class="o">=</span><span class="n">whiten_params</span><span class="p">,</span> <span class="n">freq_cutoff</span><span class="o">=</span><span class="n">freq_cutoff</span><span class="p">,</span>
            <span class="n">freq_butter_order</span><span class="o">=</span><span class="n">freq_butter_order</span><span class="p">,</span> <span class="n">random_seed</span><span class="o">=</span><span class="n">random_seed</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">whole_snr</span> <span class="o">=</span> <span class="p">{</span><span class="n">id_</span><span class="p">:</span> <span class="p">{}</span> <span class="k">for</span> <span class="n">id_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">index</span><span class="p">}</span></div>


    <span class="k">def</span> <span class="nf">_update_merger_positions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Update all &#39;merger_pos&#39; tags inside the metadata attribute.</span>
<span class="sd">        </span>
<span class="sd">        Time arrays are defined with the origin at the merger. When the length</span>
<span class="sd">        of the strain arrays is modified, the index position of the merger</span>
<span class="sd">        must be updated.</span>

<span class="sd">        NOTE: This method updates ALL the merger positions.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">clas</span><span class="p">,</span> <span class="n">id_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">(</span><span class="n">max_depth</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
            <span class="c1"># Same time array for all SNR variations.</span>
            <span class="n">times</span> <span class="o">=</span> <span class="n">dictools</span><span class="o">.</span><span class="n">get_next_item</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="n">clas</span><span class="p">][</span><span class="n">id_</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">id_</span><span class="p">,</span><span class="s1">&#39;merger_pos&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tat</span><span class="o">.</span><span class="n">find_time_origin</span><span class="p">(</span><span class="n">times</span><span class="p">)</span>
    
<div class="viewcode-block" id="InjectedCoReWaves.gen_injections">
<a class="viewcode-back" href="../../gwadama.datasets.html#gwadama.datasets.InjectedCoReWaves.gen_injections">[docs]</a>
    <span class="k">def</span> <span class="nf">gen_injections</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                       <span class="n">snr</span><span class="p">:</span> <span class="nb">int</span><span class="o">|</span><span class="nb">float</span><span class="o">|</span><span class="nb">list</span><span class="p">,</span>
                       <span class="n">pad</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
                       <span class="n">randomize_noise</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                       <span class="n">random_seed</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                       <span class="n">injections_per_snr</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
                       <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Inject all strains in simulated noise with the given SNR values.</span>

<span class="sd">        See &#39;BaseInjected.gen_injections&#39; for more details.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        snr : int | float | list</span>
<span class="sd">        </span>
<span class="sd">        pad : int</span>
<span class="sd">            Number of zeros to pad the signal at both ends before the</span>
<span class="sd">            injection.</span>

<span class="sd">        randomize_noise : bool</span>
<span class="sd">            If True, the noise segment is randomly chosen before the injection.</span>
<span class="sd">            This can be used to avoid having the same noise injected for all</span>
<span class="sd">            clean strains.</span>
<span class="sd">            False by default.</span>
<span class="sd">            </span>
<span class="sd">            NOTE: To avoid the possibility of repeating the same noise section</span>
<span class="sd">            in different injections, the noise realization must be reasonably</span>
<span class="sd">            large, e.g:</span>
<span class="sd">                </span>
<span class="sd">                `noise_length &gt; n_clean_strains * self.max_length * len(snr)`</span>
<span class="sd">        </span>
<span class="sd">        random_seed : int, optional</span>
<span class="sd">            Random seed for the noise realization.</span>
<span class="sd">            Only used when randomize_noise is True.</span>

<span class="sd">        injections_per_snr : int</span>
<span class="sd">            Number of injections per SNR value.</span>
<span class="sd">            1 by default.</span>
<span class="sd">        </span>
<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - If whitening is intended to be applied afterwards it is useful to</span>
<span class="sd">          pad the signal in order to avoid the window vignetting produced by</span>
<span class="sd">          the whitening itself. This pad will be cropped afterwards.</span>
<span class="sd">        </span>
<span class="sd">        - New injections are stored in the &#39;strains&#39; atrribute, with the pad</span>
<span class="sd">          associated to all the injections performed at once. Even when</span>
<span class="sd">          whitening is also performed right after the injections.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            Once injections have been performed at a certain SNR value, there</span>
<span class="sd">            cannot be injected again at the same value. Trying it will trigger</span>
<span class="sd">            this exception.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">gen_injections</span><span class="p">(</span>
            <span class="n">snr</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="n">pad</span><span class="p">,</span> <span class="n">randomize_noise</span><span class="o">=</span><span class="n">randomize_noise</span><span class="p">,</span>
            <span class="n">random_seed</span><span class="o">=</span><span class="n">random_seed</span><span class="p">,</span> <span class="n">injections_per_snr</span><span class="o">=</span><span class="n">injections_per_snr</span><span class="p">,</span>
            <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_update_merger_positions</span><span class="p">()</span></div>

    
    <span class="k">def</span> <span class="nf">_inject</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                <span class="n">strain</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                <span class="n">snr</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">float</span><span class="p">,</span>
                <span class="o">*</span><span class="p">,</span>
                <span class="nb">id</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                <span class="n">snr_offset</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                <span class="n">pos</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Inject a strain at &#39;snr&#39; into noise using &#39;self.noise&#39; instance.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        strain : NDArray</span>
<span class="sd">            Signal to be injected into noise.</span>
<span class="sd">        </span>
<span class="sd">        snr : int | float</span>
<span class="sd">            Targeted signal-to-noise ratio.</span>
<span class="sd">        </span>
<span class="sd">        id : str</span>
<span class="sd">            Signal identifier (2nd layer of &#39;strains&#39; dict).</span>
<span class="sd">        </span>
<span class="sd">        snr_offset : int</span>
<span class="sd">            Offset (w.r.t. the merger) added to the start of the range for</span>
<span class="sd">            computing the SNR.</span>

<span class="sd">        pos : int, optional</span>
<span class="sd">            Index position in the noise array where to inject the signal.</span>
<span class="sd">            0 by default.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        injected : NDArray</span>
<span class="sd">            Injected signal.</span>
<span class="sd">        </span>
<span class="sd">        NOTES</span>
<span class="sd">        -----</span>
<span class="sd">        - The SNR is computed over the Post-Merger only.</span>

<span class="sd">        - The metadata is expected to reflect the original state of the strains</span>
<span class="sd">          previous to any padding performed right before calling this function,</span>
<span class="sd">          which may be done to avoid the vignette effect.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">clas</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_class</span><span class="p">(</span><span class="nb">id</span><span class="p">)</span>
        <span class="n">merger_pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="nb">id</span><span class="p">,</span><span class="s1">&#39;merger_pos&#39;</span><span class="p">]</span>
        <span class="n">original_length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">strains_clean</span><span class="p">[</span><span class="n">clas</span><span class="p">][</span><span class="nb">id</span><span class="p">])</span>

        <span class="n">i0</span> <span class="o">=</span> <span class="n">merger_pos</span> <span class="o">+</span> <span class="n">snr_offset</span>
        <span class="n">i1</span> <span class="o">=</span> <span class="p">(</span><span class="n">original_length</span> <span class="o">-</span> <span class="n">merger_pos</span><span class="p">)</span> <span class="o">+</span> <span class="n">snr_offset</span>
        <span class="n">injected</span><span class="p">,</span> <span class="n">scale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">noise</span><span class="o">.</span><span class="n">inject</span><span class="p">(</span><span class="n">strain</span><span class="p">,</span> <span class="n">snr</span><span class="o">=</span><span class="n">snr</span><span class="p">,</span> <span class="n">snr_lim</span><span class="o">=</span><span class="p">(</span><span class="n">i0</span><span class="p">,</span> <span class="n">i1</span><span class="p">),</span> <span class="n">pos</span><span class="o">=</span><span class="n">pos</span><span class="p">)</span>

        <span class="c1"># Compute the equivalent SNR over the entire waveform.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">whole_snr</span><span class="p">[</span><span class="nb">id</span><span class="p">][</span><span class="n">snr</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">noise</span><span class="o">.</span><span class="n">snr</span><span class="p">(</span><span class="n">strain</span><span class="o">*</span><span class="n">scale</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">injected</span>
    
<div class="viewcode-block" id="InjectedCoReWaves.whiten">
<a class="viewcode-back" href="../../gwadama.datasets.html#gwadama.datasets.InjectedCoReWaves.whiten">[docs]</a>
    <span class="k">def</span> <span class="nf">whiten</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Whiten injected strains.</span>
<span class="sd">        </span>
<span class="sd">        Calling this method performs the whitening of all injected strains.</span>
<span class="sd">        Strains are later cut to their original size before adding the pad,</span>
<span class="sd">        to remove the vigneting.</span>
<span class="sd">        </span>
<span class="sd">        NOTE: This is an irreversible action; if the original injections need</span>
<span class="sd">        to be preserved it is advised to make a copy of the instance before</span>
<span class="sd">        performing the whitening.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">whiten</span><span class="p">(</span><span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_update_merger_positions</span><span class="p">()</span></div>
</div>

</pre></div>

                </article>
              
              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
</div>
                </footer>
              
            </div>
            
            
              
            
          </div>
          <footer class="bd-footer-content">
            
          </footer>
        
      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script defer src="../../_static/scripts/bootstrap.js?digest=8878045cc6db502f8baf"></script>
<script defer src="../../_static/scripts/pydata-sphinx-theme.js?digest=8878045cc6db502f8baf"></script>

  <footer class="bd-footer">
<div class="bd-footer__inner bd-page-width">
  
    <div class="footer-items__start">
      
        <div class="footer-item">

  <p class="copyright">
    
       Copyright 2025, Miquel Llus Llorens Monteagudo.
      <br/>
    
  </p>
</div>
      
        <div class="footer-item">

  <p class="sphinx-version">
    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.2.6.
    <br/>
  </p>
</div>
      
    </div>
  
  
  
    <div class="footer-items__end">
      
        <div class="footer-item">
<p class="theme-version">
  <!-- # L10n: Setting the PST URL as an argument as this does not need to be localized -->
  Built with the <a href="https://pydata-sphinx-theme.readthedocs.io/en/stable/index.html">PyData Sphinx Theme</a> 0.16.1.
</p></div>
      
    </div>
  
</div>

  </footer>
  </body>
</html>