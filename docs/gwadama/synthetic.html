<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>gwadama.synthetic API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>gwadama.synthetic</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from typing import Callable

import numpy as np
import scipy as sp
import scipy.signal
from scipy.interpolate import make_interp_spline as sp_make_interp_spline

import clawdia



class NonwhiteGaussianNoise:
    &#34;&#34;&#34;Simulate non-white gaussian noise.

    ¡¡¡OLD VERSION FROM MASTER&#39;S THESIS!!! (Tweaked)

    I changed several things:
    - Now the PSD argument can be either a function or an array.

    Attributes
    ----------
    noise: NDArray

    duration: float
        Duration of the noise in seconds.
    
    psd: function
        Interpolant of PSD(f).
        If the instance is initialized with a realization of the PSD (an array)
        its original value can be accessed through the attribute &#39;_psd&#39;.
    
    sample_rate: int

    f_nyquist: int
        Nyquist frequency.

    rng: numpy.random.Generator

    &#34;&#34;&#34;
    def __init__(self, *, duration, psd, sample_rate, rng, freq_cutoff=0):
        &#34;&#34;&#34;Initialises the noise instance.

        Parameters
        ----------
        duration: float
            Duration of noise to be generated, in seconds. It may change after
            genetarting the noise, depending on its sample frequency.

        psd: function | NDArray
            Power Spectral Density of the non-white part of the noise.
            If NDArray, will be used to create a quadratic spline interpolant,
            assuming shape (2, psd_length):
                psd[0] = frequency samples
                psd[1] = psd samples

        sample_rate: int
            Sample frequency of the signal.

        random_seed: int or 1-d array_like
            Seed for numpy.random.RandomState.
        
        freq_lowcut: int, optional
            Low cut-off frequency to apply when computing noise in frequency space.
        
        rng: numpy.random.Generator
        
        &#34;&#34;&#34;
        self.duration = duration  # May be corrected after calling _gen_noise()
        self.freq_cutoff = freq_cutoff
        self.sample_rate = sample_rate
        self.freq_nyquist = sample_rate // 2
        self.rng = rng  # Shared with the parent scope.
        self.psd, self._psd = self._setup_psd(psd)
        self._check_initial_parameters()
        
        self._gen_noise()
    
    def __getstate__(self):
        &#34;&#34;&#34;Avoid error when trying to pickle PSD interpolator.&#34;&#34;&#34;

        state = self.__dict__.copy()
        del state[&#39;psd&#39;]  # Delete the encapsulated (unpickable) function
        
        return state
    
    def __setstate__(self, state):
        &#34;&#34;&#34;Avoid error when trying to pickle PSD interpolator.&#34;&#34;&#34;

        psd, _ = self._setup_psd(state[&#39;_psd&#39;])
        state[&#39;psd&#39;] = psd
        self.__dict__.update(state)

    def __getitem__(self, key):
        &#34;&#34;&#34;Direct slice access to noise array.&#34;&#34;&#34;
        return self.noise[key]

    def __len__(self):
        &#34;&#34;&#34;Length of the noise array.&#34;&#34;&#34;
        return len(self.noise)

    def __repr__(self):
        args = (type(self).__name__, self.duration, self.sample_rate, self.rng.bit_generator.state)

        return &#34;{}(t={}, sample_rate={}, random_state={})&#34;.format(*args)

    def _setup_psd(self, psd: np.ndarray | Callable) -&gt; Callable:
        &#34;&#34;&#34;Return the PSD array AND an interpolating function.&#34;&#34;&#34;

        if callable(psd):
            psd_fun = psd
            # Compute a realization of the PSD function with 1 bin per
            # integer frequency.
            freqs = np.linspace(0, self.sample_rate//2, self.sample_rate//2)
            psd_array = np.stack([freqs, psd(freqs)])
            i_cut = np.argmin((freqs - self.freq_cutoff) &lt; 0)
            psd_array[1,:i_cut] = 0
        else:
            # Build a spline quadratic interpolant for the input PSD array
            # which ensures to be 0 below the cutoff frequency.
            _psd_interp = sp_make_interp_spline(psd[0], psd[1], k=2)
            def psd_fun(freqs):
                psd = _psd_interp(freqs)
                i_cut = np.argmin((freqs - self.freq_cutoff) &lt; 0)
                psd[:i_cut] = 0
                return psd
            psd_array = np.asarray(psd)
            
        return psd_fun, psd_array

    def inject(self, x, *, snr, snr_lim=None, pos=0, normed=False):
        &#34;&#34;&#34;Add the simulated noise to the signal &#39;x&#39;.

        Parameters
        ----------
        x : array
            Signal array. Its length must be lower or equal to
            the length of the noise array.

        snr : int or float, optional
            Signal to Noise Ratio. Defaults to 1.

        snr_lim : tuple, optional
            Limits in &#39;x&#39; where to calculate the SNR.

        pos : int, optional
            Index position in the noise array where to inject the signal.
            0 by default.

        normed : boolean, optional
            Normalize &#39;x&#39; to its maximum amplitude after adding the noise.
            False by default.

        Returns
        -------
        noisy : array
            Signal array with noise at the desired SNR.

        scale : float
            Coefficient used to rescale the signal.

        &#34;&#34;&#34;
        n = len(x)
        if n &gt; len(self.noise):
            raise ValueError(&#34;&#39;x&#39; is larger than the noise array&#34;)

        if snr_lim is None:
            scale = snr / self.snr(x)
        else:
            scale = snr / self.snr(x[slice(*snr_lim)])

        x_noisy = x * scale + self.noise[pos:pos+n]

        if normed:
            norm = np.max(np.abs(x_noisy))
            x_noisy /= norm
            scale /= norm

        return (x_noisy, scale)

    def rescale(self, x, *, snr):
        &#34;&#34;&#34;Rescale the signal &#39;x&#39; to the given snr w.r.t. the PSD.

        Parameters
        ----------
        x : array
            Signal array.

        snr : int or float, optional
            Signal to Noise Ratio. Defaults to 1.

        Returns
        -------
        x_new : float
            Rescaled signal.

        &#34;&#34;&#34;
        factor = snr / self.snr(x)
        x_new = x * factor

        return (x_new, factor)

    def snr(self, x):
        &#34;&#34;&#34;Compute the Signal to Noise Ratio using Clawdia&#39;s function.
        
        Due to the legacy code state, I need to compute a sample of the PSD
        first. But in the future I plan to make it so that it can take both
        a PSD estimation function or an array realization like I did here.

        &#34;&#34;&#34;
        freqs = np.linspace(self.freq_cutoff, self.freq_nyquist, 2*self.sample_rate)
        psd = np.array([freqs, self.psd(freqs)])
        snr = clawdia.estimators.snr(x, psd=psd, at=1/self.sample_rate, window=(&#39;tukey&#39;,0.1))
        
        return snr

    def _check_initial_parameters(self):
        # Check optional arguments.
        if self.duration is not None:
            if not isinstance(self.duration, (int, float)):
                raise TypeError(&#34;&#39;duration&#39; must be an integer or float number&#34;)
        elif self.noise is None:
            raise TypeError(&#34;either &#39;duration&#39; or &#39;noise&#39; must be provided!&#34;)
        elif not isinstance(self.noise, (list, tuple, np.ndarray)):
            raise TypeError(&#34;&#39;noise&#39; must be an array-like iterable&#34;)

        # Check required arguments.
        if self.psd is None:
            raise TypeError(&#34;&#39;psd&#39; must be provided&#34;)
        if self.sample_rate is None:
            raise TypeError(&#34;&#39;sample_rate&#39; must be provided&#34;)

    def _gen_noise(self):
        &#34;&#34;&#34;Generate the noise array.&#34;&#34;&#34;
        length = int(self.duration * self.sample_rate)
        
        # Positive frequencies + 0
        n = length // 2
        f = np.arange(0, self.freq_nyquist, self.freq_nyquist/n)
        i_cut = np.argmax(f &gt;= self.freq_cutoff)
        
        # Noise components of the positive and zero frequencies in Fourier space
        # weighted by the PSD amplitude and the normal distribution.
        psd = self.psd(f)
        psd[:i_cut] = 0  # Ensure no components are computed under the cutoff frequency.
        nf = np.sqrt(length * self.sample_rate * psd) / 2
        nf = nf*self.rng.normal(size=n) + 1j*nf*self.rng.normal(size=n)
        
        # The final noise array realization
        self.noise = np.fft.irfft(nf, n=length)
        self.duration = len(self.noise) / self.sample_rate  # Actual final duration

    # def highpass_filter(self,
    #                     signal: np.ndarray,
    #                     f_cut: int | float,
    #                     f_width: int | float) -&gt; np.ndarray:
    #     &#34;&#34;&#34;Apply a forward-backward digital highpass filter.

    #     Apply a forward-backward digital highpass filter to &#39;signal&#39; CENTERED
    #     at frequency &#39;f_cut&#39; with a transition band of &#39;f_width&#39;.

    #     It enforces the (single) filter to allow only loss of 2 dB at passband
    #     (`f_cut + f_width/2` Hz) and a minimum filter of 20 dB at stopband
    #     (`f_cut - f_width/2` Hz).
        
    #     REFERENCES
    #     ----------
    #     Order selection: https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.buttord.html
    #     Design: https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.butter.html
    #     Filter: https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.sosfiltfilt.html

    #     &#34;&#34;&#34;
    #     f_pass = f_cut + f_width/2
    #     f_stop = f_cut - f_width/2
    #     N, wn = sp.signal.buttord(wp=f_pass, ws=f_stop, gpass=2, gstop=16, fs=self.sample_rate)
    #     sos = sp.signal.butter(N, wn, btype=&#39;highpass&#39;, fs=self.sample_rate, output=&#39;sos&#39;)
    #     filtered = sp.signal.sosfiltfilt(sos, signal)

    #     return filtered
    
    def highpass_filter(self,
                        signal: np.ndarray,
                        f_cut: int | float,
                        f_order: int | float) -&gt; np.ndarray:
        &#34;&#34;&#34;Apply a forward-backward digital highpass filter.

        Apply a forward-backward digital highpass filter to &#39;signal&#39;
        at frequency &#39;f_cut&#39; with an order of &#39;f_order&#39;.
        
        REFERENCES
        ----------
        Design: https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.butter.html
        Filter: https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.sosfiltfilt.html

        &#34;&#34;&#34;
        sos = sp.signal.butter(f_order, f_cut, btype=&#39;highpass&#39;, fs=self.sample_rate, output=&#39;sos&#39;)
        filtered = sp.signal.sosfiltfilt(sos, signal)

        return filtered



def sine_gaussian_waveform(times: np.ndarray,
                           *,
                           t0: float,
                           f0: float,
                           Q: float,
                           hrss: float) -&gt; np.ndarray:
    &#34;&#34;&#34;Generate a Sine-Gaussian-like waveform.
    
    PARAMETERS
    ----------
    times: NDArray
        Time samples.
    
    t0: float
        Time of the peak.
    
    f0: float
        Central frequency.
    
    Q: float
        Quality factor of the wave.
    
    hrss: float
        Root sum squared amplitude of the wave.
        REF: (2015) Powell J, Trifirò D, Cuoco E, Heng I S and Cavaglià M,
                Class. Quantum Grav. 32 215012.
    
    &#34;&#34;&#34;
    h0  = np.sqrt(np.sqrt(2) * np.pi * f0 / Q) * hrss
    env = h0 * np.exp( -(np.pi * f0 / Q * (times-t0)) ** 2)
    arg = 2 * np.pi * f0 * (times - t0)
    
    return env * np.sin(arg)


def gaussian_waveform(times: np.ndarray,
                      *,
                      t0: float,
                      hrss: float,
                      duration: float,
                      amp_threshold: float) -&gt; np.ndarray:
    &#34;&#34;&#34;Generate a Gaussian-like waveform.
    
    PARAMETERS
    ----------
    times: NDArray
        Time samples.
    
    t0: float
        Time of the peak.
    
    hrss: float
        Root sum squared amplitude of the wave.
        REF: (2015) Powell J, Trifirò D, Cuoco E, Heng I S and Cavaglià M,
                Class. Quantum Grav. 32 215012.
    
    duration: float
        In seconds.
    
    amp_threshold: float
        Fraction w.r.t. the maximum absolute amplitude of the wave where to
        consider the amplitude of the wave zero.
        Here is used to compute the effective duration of the wave.
    
    &#34;&#34;&#34;
    h0  = (-8*np.log(amp_threshold))**(1/4) * hrss / np.sqrt(duration)
    env = h0 * np.exp(4 * np.log(amp_threshold) * ((times-t0) / duration)**2)

    return env


def ring_down_waveform(times: np.ndarray,
                       *,
                       t0: float,
                       f0: float,
                       Q: float,
                       hrss: float) -&gt; np.ndarray:
    &#34;&#34;&#34;Generate a Sine-Gaussian-like waveform.

    This waveform has its peak at the beginning. In order to synchronise it
    with other waveforms which have their peak at the center, it is recommended
    to use the &#39;t0&#39; parameter.

    
    PARAMETERS
    ----------
    times: NDArray
        Time samples.
    
    t0: float
        Time of the peak.

    f0: float
        Central frequency.
    
    Q: float
        Quality factor of the wave.
    
    hrss: float
        Root sum squared amplitude of the wave.
        REF: (2015) Powell J, Trifirò D, Cuoco E, Heng I S and Cavaglià M,
                Class. Quantum Grav. 32 215012.

    &#34;&#34;&#34;
    t0_ = 0
    h0  = np.sqrt(np.sqrt(2) * np.pi * f0 / Q) * hrss
    env = h0 * np.exp(- np.pi / np.sqrt(2) * f0 / Q * (times - t0_))
    arg = 2 * np.pi * f0 * (times - t0_)

    h = env * np.sin(arg)
    sample_rate = int(1/np.median(np.diff(times)))
    pad = int(t0 * sample_rate)
    h = np.pad(h, pad_width=(pad, 0))[:-pad]

    return h</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="gwadama.synthetic.gaussian_waveform"><code class="name flex">
<span>def <span class="ident">gaussian_waveform</span></span>(<span>times: numpy.ndarray, *, t0: float, hrss: float, duration: float, amp_threshold: float) -> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Generate a Gaussian-like waveform.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>times</code></strong> :&ensp;<code>NDArray</code></dt>
<dd>Time samples.</dd>
<dt><strong><code>t0</code></strong> :&ensp;<code>float</code></dt>
<dd>Time of the peak.</dd>
<dt><strong><code>hrss</code></strong> :&ensp;<code>float</code></dt>
<dd>Root sum squared amplitude of the wave.
REF: (2015) Powell J, Trifirò D, Cuoco E, Heng I S and Cavaglià M,
Class. Quantum Grav. 32 215012.</dd>
<dt><strong><code>duration</code></strong> :&ensp;<code>float</code></dt>
<dd>In seconds.</dd>
<dt><strong><code>amp_threshold</code></strong> :&ensp;<code>float</code></dt>
<dd>Fraction w.r.t. the maximum absolute amplitude of the wave where to
consider the amplitude of the wave zero.
Here is used to compute the effective duration of the wave.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gaussian_waveform(times: np.ndarray,
                      *,
                      t0: float,
                      hrss: float,
                      duration: float,
                      amp_threshold: float) -&gt; np.ndarray:
    &#34;&#34;&#34;Generate a Gaussian-like waveform.
    
    PARAMETERS
    ----------
    times: NDArray
        Time samples.
    
    t0: float
        Time of the peak.
    
    hrss: float
        Root sum squared amplitude of the wave.
        REF: (2015) Powell J, Trifirò D, Cuoco E, Heng I S and Cavaglià M,
                Class. Quantum Grav. 32 215012.
    
    duration: float
        In seconds.
    
    amp_threshold: float
        Fraction w.r.t. the maximum absolute amplitude of the wave where to
        consider the amplitude of the wave zero.
        Here is used to compute the effective duration of the wave.
    
    &#34;&#34;&#34;
    h0  = (-8*np.log(amp_threshold))**(1/4) * hrss / np.sqrt(duration)
    env = h0 * np.exp(4 * np.log(amp_threshold) * ((times-t0) / duration)**2)

    return env</code></pre>
</details>
</dd>
<dt id="gwadama.synthetic.ring_down_waveform"><code class="name flex">
<span>def <span class="ident">ring_down_waveform</span></span>(<span>times: numpy.ndarray, *, t0: float, f0: float, Q: float, hrss: float) -> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Generate a Sine-Gaussian-like waveform.</p>
<p>This waveform has its peak at the beginning. In order to synchronise it
with other waveforms which have their peak at the center, it is recommended
to use the 't0' parameter.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>times</code></strong> :&ensp;<code>NDArray</code></dt>
<dd>Time samples.</dd>
<dt><strong><code>t0</code></strong> :&ensp;<code>float</code></dt>
<dd>Time of the peak.</dd>
<dt><strong><code>f0</code></strong> :&ensp;<code>float</code></dt>
<dd>Central frequency.</dd>
<dt><strong><code>Q</code></strong> :&ensp;<code>float</code></dt>
<dd>Quality factor of the wave.</dd>
<dt><strong><code>hrss</code></strong> :&ensp;<code>float</code></dt>
<dd>Root sum squared amplitude of the wave.
REF: (2015) Powell J, Trifirò D, Cuoco E, Heng I S and Cavaglià M,
Class. Quantum Grav. 32 215012.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ring_down_waveform(times: np.ndarray,
                       *,
                       t0: float,
                       f0: float,
                       Q: float,
                       hrss: float) -&gt; np.ndarray:
    &#34;&#34;&#34;Generate a Sine-Gaussian-like waveform.

    This waveform has its peak at the beginning. In order to synchronise it
    with other waveforms which have their peak at the center, it is recommended
    to use the &#39;t0&#39; parameter.

    
    PARAMETERS
    ----------
    times: NDArray
        Time samples.
    
    t0: float
        Time of the peak.

    f0: float
        Central frequency.
    
    Q: float
        Quality factor of the wave.
    
    hrss: float
        Root sum squared amplitude of the wave.
        REF: (2015) Powell J, Trifirò D, Cuoco E, Heng I S and Cavaglià M,
                Class. Quantum Grav. 32 215012.

    &#34;&#34;&#34;
    t0_ = 0
    h0  = np.sqrt(np.sqrt(2) * np.pi * f0 / Q) * hrss
    env = h0 * np.exp(- np.pi / np.sqrt(2) * f0 / Q * (times - t0_))
    arg = 2 * np.pi * f0 * (times - t0_)

    h = env * np.sin(arg)
    sample_rate = int(1/np.median(np.diff(times)))
    pad = int(t0 * sample_rate)
    h = np.pad(h, pad_width=(pad, 0))[:-pad]

    return h</code></pre>
</details>
</dd>
<dt id="gwadama.synthetic.sine_gaussian_waveform"><code class="name flex">
<span>def <span class="ident">sine_gaussian_waveform</span></span>(<span>times: numpy.ndarray, *, t0: float, f0: float, Q: float, hrss: float) -> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Generate a Sine-Gaussian-like waveform.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>times</code></strong> :&ensp;<code>NDArray</code></dt>
<dd>Time samples.</dd>
<dt><strong><code>t0</code></strong> :&ensp;<code>float</code></dt>
<dd>Time of the peak.</dd>
<dt><strong><code>f0</code></strong> :&ensp;<code>float</code></dt>
<dd>Central frequency.</dd>
<dt><strong><code>Q</code></strong> :&ensp;<code>float</code></dt>
<dd>Quality factor of the wave.</dd>
<dt><strong><code>hrss</code></strong> :&ensp;<code>float</code></dt>
<dd>Root sum squared amplitude of the wave.
REF: (2015) Powell J, Trifirò D, Cuoco E, Heng I S and Cavaglià M,
Class. Quantum Grav. 32 215012.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sine_gaussian_waveform(times: np.ndarray,
                           *,
                           t0: float,
                           f0: float,
                           Q: float,
                           hrss: float) -&gt; np.ndarray:
    &#34;&#34;&#34;Generate a Sine-Gaussian-like waveform.
    
    PARAMETERS
    ----------
    times: NDArray
        Time samples.
    
    t0: float
        Time of the peak.
    
    f0: float
        Central frequency.
    
    Q: float
        Quality factor of the wave.
    
    hrss: float
        Root sum squared amplitude of the wave.
        REF: (2015) Powell J, Trifirò D, Cuoco E, Heng I S and Cavaglià M,
                Class. Quantum Grav. 32 215012.
    
    &#34;&#34;&#34;
    h0  = np.sqrt(np.sqrt(2) * np.pi * f0 / Q) * hrss
    env = h0 * np.exp( -(np.pi * f0 / Q * (times-t0)) ** 2)
    arg = 2 * np.pi * f0 * (times - t0)
    
    return env * np.sin(arg)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="gwadama.synthetic.NonwhiteGaussianNoise"><code class="flex name class">
<span>class <span class="ident">NonwhiteGaussianNoise</span></span>
<span>(</span><span>*, duration, psd, sample_rate, rng, freq_cutoff=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Simulate non-white gaussian noise.</p>
<p>¡¡¡OLD VERSION FROM MASTER'S THESIS!!! (Tweaked)</p>
<p>I changed several things:
- Now the PSD argument can be either a function or an array.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>noise</code></strong> :&ensp;<code>NDArray</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>duration</code></strong> :&ensp;<code>float</code></dt>
<dd>Duration of the noise in seconds.</dd>
<dt><strong><code>psd</code></strong> :&ensp;<code>function</code></dt>
<dd>Interpolant of PSD(f).
If the instance is initialized with a realization of the PSD (an array)
its original value can be accessed through the attribute '_psd'.</dd>
<dt><strong><code>sample_rate</code></strong> :&ensp;<code>int</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>f_nyquist</code></strong> :&ensp;<code>int</code></dt>
<dd>Nyquist frequency.</dd>
<dt><strong><code>rng</code></strong> :&ensp;<code>numpy.random.Generator</code></dt>
<dd>&nbsp;</dd>
</dl>
<p>Initialises the noise instance.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>duration</code></strong> :&ensp;<code>float</code></dt>
<dd>Duration of noise to be generated, in seconds. It may change after
genetarting the noise, depending on its sample frequency.</dd>
<dt><strong><code>psd</code></strong> :&ensp;<code>function | NDArray</code></dt>
<dd>Power Spectral Density of the non-white part of the noise.
If NDArray, will be used to create a quadratic spline interpolant,
assuming shape (2, psd_length):
psd[0] = frequency samples
psd[1] = psd samples</dd>
<dt><strong><code>sample_rate</code></strong> :&ensp;<code>int</code></dt>
<dd>Sample frequency of the signal.</dd>
<dt><strong><code>random_seed</code></strong> :&ensp;<code>int</code> or <code>1-d array_like</code></dt>
<dd>Seed for numpy.random.RandomState.</dd>
<dt><strong><code>freq_lowcut</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Low cut-off frequency to apply when computing noise in frequency space.</dd>
<dt><strong><code>rng</code></strong> :&ensp;<code>numpy.random.Generator</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NonwhiteGaussianNoise:
    &#34;&#34;&#34;Simulate non-white gaussian noise.

    ¡¡¡OLD VERSION FROM MASTER&#39;S THESIS!!! (Tweaked)

    I changed several things:
    - Now the PSD argument can be either a function or an array.

    Attributes
    ----------
    noise: NDArray

    duration: float
        Duration of the noise in seconds.
    
    psd: function
        Interpolant of PSD(f).
        If the instance is initialized with a realization of the PSD (an array)
        its original value can be accessed through the attribute &#39;_psd&#39;.
    
    sample_rate: int

    f_nyquist: int
        Nyquist frequency.

    rng: numpy.random.Generator

    &#34;&#34;&#34;
    def __init__(self, *, duration, psd, sample_rate, rng, freq_cutoff=0):
        &#34;&#34;&#34;Initialises the noise instance.

        Parameters
        ----------
        duration: float
            Duration of noise to be generated, in seconds. It may change after
            genetarting the noise, depending on its sample frequency.

        psd: function | NDArray
            Power Spectral Density of the non-white part of the noise.
            If NDArray, will be used to create a quadratic spline interpolant,
            assuming shape (2, psd_length):
                psd[0] = frequency samples
                psd[1] = psd samples

        sample_rate: int
            Sample frequency of the signal.

        random_seed: int or 1-d array_like
            Seed for numpy.random.RandomState.
        
        freq_lowcut: int, optional
            Low cut-off frequency to apply when computing noise in frequency space.
        
        rng: numpy.random.Generator
        
        &#34;&#34;&#34;
        self.duration = duration  # May be corrected after calling _gen_noise()
        self.freq_cutoff = freq_cutoff
        self.sample_rate = sample_rate
        self.freq_nyquist = sample_rate // 2
        self.rng = rng  # Shared with the parent scope.
        self.psd, self._psd = self._setup_psd(psd)
        self._check_initial_parameters()
        
        self._gen_noise()
    
    def __getstate__(self):
        &#34;&#34;&#34;Avoid error when trying to pickle PSD interpolator.&#34;&#34;&#34;

        state = self.__dict__.copy()
        del state[&#39;psd&#39;]  # Delete the encapsulated (unpickable) function
        
        return state
    
    def __setstate__(self, state):
        &#34;&#34;&#34;Avoid error when trying to pickle PSD interpolator.&#34;&#34;&#34;

        psd, _ = self._setup_psd(state[&#39;_psd&#39;])
        state[&#39;psd&#39;] = psd
        self.__dict__.update(state)

    def __getitem__(self, key):
        &#34;&#34;&#34;Direct slice access to noise array.&#34;&#34;&#34;
        return self.noise[key]

    def __len__(self):
        &#34;&#34;&#34;Length of the noise array.&#34;&#34;&#34;
        return len(self.noise)

    def __repr__(self):
        args = (type(self).__name__, self.duration, self.sample_rate, self.rng.bit_generator.state)

        return &#34;{}(t={}, sample_rate={}, random_state={})&#34;.format(*args)

    def _setup_psd(self, psd: np.ndarray | Callable) -&gt; Callable:
        &#34;&#34;&#34;Return the PSD array AND an interpolating function.&#34;&#34;&#34;

        if callable(psd):
            psd_fun = psd
            # Compute a realization of the PSD function with 1 bin per
            # integer frequency.
            freqs = np.linspace(0, self.sample_rate//2, self.sample_rate//2)
            psd_array = np.stack([freqs, psd(freqs)])
            i_cut = np.argmin((freqs - self.freq_cutoff) &lt; 0)
            psd_array[1,:i_cut] = 0
        else:
            # Build a spline quadratic interpolant for the input PSD array
            # which ensures to be 0 below the cutoff frequency.
            _psd_interp = sp_make_interp_spline(psd[0], psd[1], k=2)
            def psd_fun(freqs):
                psd = _psd_interp(freqs)
                i_cut = np.argmin((freqs - self.freq_cutoff) &lt; 0)
                psd[:i_cut] = 0
                return psd
            psd_array = np.asarray(psd)
            
        return psd_fun, psd_array

    def inject(self, x, *, snr, snr_lim=None, pos=0, normed=False):
        &#34;&#34;&#34;Add the simulated noise to the signal &#39;x&#39;.

        Parameters
        ----------
        x : array
            Signal array. Its length must be lower or equal to
            the length of the noise array.

        snr : int or float, optional
            Signal to Noise Ratio. Defaults to 1.

        snr_lim : tuple, optional
            Limits in &#39;x&#39; where to calculate the SNR.

        pos : int, optional
            Index position in the noise array where to inject the signal.
            0 by default.

        normed : boolean, optional
            Normalize &#39;x&#39; to its maximum amplitude after adding the noise.
            False by default.

        Returns
        -------
        noisy : array
            Signal array with noise at the desired SNR.

        scale : float
            Coefficient used to rescale the signal.

        &#34;&#34;&#34;
        n = len(x)
        if n &gt; len(self.noise):
            raise ValueError(&#34;&#39;x&#39; is larger than the noise array&#34;)

        if snr_lim is None:
            scale = snr / self.snr(x)
        else:
            scale = snr / self.snr(x[slice(*snr_lim)])

        x_noisy = x * scale + self.noise[pos:pos+n]

        if normed:
            norm = np.max(np.abs(x_noisy))
            x_noisy /= norm
            scale /= norm

        return (x_noisy, scale)

    def rescale(self, x, *, snr):
        &#34;&#34;&#34;Rescale the signal &#39;x&#39; to the given snr w.r.t. the PSD.

        Parameters
        ----------
        x : array
            Signal array.

        snr : int or float, optional
            Signal to Noise Ratio. Defaults to 1.

        Returns
        -------
        x_new : float
            Rescaled signal.

        &#34;&#34;&#34;
        factor = snr / self.snr(x)
        x_new = x * factor

        return (x_new, factor)

    def snr(self, x):
        &#34;&#34;&#34;Compute the Signal to Noise Ratio using Clawdia&#39;s function.
        
        Due to the legacy code state, I need to compute a sample of the PSD
        first. But in the future I plan to make it so that it can take both
        a PSD estimation function or an array realization like I did here.

        &#34;&#34;&#34;
        freqs = np.linspace(self.freq_cutoff, self.freq_nyquist, 2*self.sample_rate)
        psd = np.array([freqs, self.psd(freqs)])
        snr = clawdia.estimators.snr(x, psd=psd, at=1/self.sample_rate, window=(&#39;tukey&#39;,0.1))
        
        return snr

    def _check_initial_parameters(self):
        # Check optional arguments.
        if self.duration is not None:
            if not isinstance(self.duration, (int, float)):
                raise TypeError(&#34;&#39;duration&#39; must be an integer or float number&#34;)
        elif self.noise is None:
            raise TypeError(&#34;either &#39;duration&#39; or &#39;noise&#39; must be provided!&#34;)
        elif not isinstance(self.noise, (list, tuple, np.ndarray)):
            raise TypeError(&#34;&#39;noise&#39; must be an array-like iterable&#34;)

        # Check required arguments.
        if self.psd is None:
            raise TypeError(&#34;&#39;psd&#39; must be provided&#34;)
        if self.sample_rate is None:
            raise TypeError(&#34;&#39;sample_rate&#39; must be provided&#34;)

    def _gen_noise(self):
        &#34;&#34;&#34;Generate the noise array.&#34;&#34;&#34;
        length = int(self.duration * self.sample_rate)
        
        # Positive frequencies + 0
        n = length // 2
        f = np.arange(0, self.freq_nyquist, self.freq_nyquist/n)
        i_cut = np.argmax(f &gt;= self.freq_cutoff)
        
        # Noise components of the positive and zero frequencies in Fourier space
        # weighted by the PSD amplitude and the normal distribution.
        psd = self.psd(f)
        psd[:i_cut] = 0  # Ensure no components are computed under the cutoff frequency.
        nf = np.sqrt(length * self.sample_rate * psd) / 2
        nf = nf*self.rng.normal(size=n) + 1j*nf*self.rng.normal(size=n)
        
        # The final noise array realization
        self.noise = np.fft.irfft(nf, n=length)
        self.duration = len(self.noise) / self.sample_rate  # Actual final duration

    # def highpass_filter(self,
    #                     signal: np.ndarray,
    #                     f_cut: int | float,
    #                     f_width: int | float) -&gt; np.ndarray:
    #     &#34;&#34;&#34;Apply a forward-backward digital highpass filter.

    #     Apply a forward-backward digital highpass filter to &#39;signal&#39; CENTERED
    #     at frequency &#39;f_cut&#39; with a transition band of &#39;f_width&#39;.

    #     It enforces the (single) filter to allow only loss of 2 dB at passband
    #     (`f_cut + f_width/2` Hz) and a minimum filter of 20 dB at stopband
    #     (`f_cut - f_width/2` Hz).
        
    #     REFERENCES
    #     ----------
    #     Order selection: https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.buttord.html
    #     Design: https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.butter.html
    #     Filter: https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.sosfiltfilt.html

    #     &#34;&#34;&#34;
    #     f_pass = f_cut + f_width/2
    #     f_stop = f_cut - f_width/2
    #     N, wn = sp.signal.buttord(wp=f_pass, ws=f_stop, gpass=2, gstop=16, fs=self.sample_rate)
    #     sos = sp.signal.butter(N, wn, btype=&#39;highpass&#39;, fs=self.sample_rate, output=&#39;sos&#39;)
    #     filtered = sp.signal.sosfiltfilt(sos, signal)

    #     return filtered
    
    def highpass_filter(self,
                        signal: np.ndarray,
                        f_cut: int | float,
                        f_order: int | float) -&gt; np.ndarray:
        &#34;&#34;&#34;Apply a forward-backward digital highpass filter.

        Apply a forward-backward digital highpass filter to &#39;signal&#39;
        at frequency &#39;f_cut&#39; with an order of &#39;f_order&#39;.
        
        REFERENCES
        ----------
        Design: https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.butter.html
        Filter: https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.sosfiltfilt.html

        &#34;&#34;&#34;
        sos = sp.signal.butter(f_order, f_cut, btype=&#39;highpass&#39;, fs=self.sample_rate, output=&#39;sos&#39;)
        filtered = sp.signal.sosfiltfilt(sos, signal)

        return filtered</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="gwadama.synthetic.NonwhiteGaussianNoise.highpass_filter"><code class="name flex">
<span>def <span class="ident">highpass_filter</span></span>(<span>self, signal: numpy.ndarray, f_cut: int | float, f_order: int | float) -> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Apply a forward-backward digital highpass filter.</p>
<p>Apply a forward-backward digital highpass filter to 'signal'
at frequency 'f_cut' with an order of 'f_order'.</p>
<h2 id="references">References</h2>
<p>Design: <a href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.butter.html">https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.butter.html</a>
Filter: <a href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.sosfiltfilt.html">https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.sosfiltfilt.html</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def highpass_filter(self,
                    signal: np.ndarray,
                    f_cut: int | float,
                    f_order: int | float) -&gt; np.ndarray:
    &#34;&#34;&#34;Apply a forward-backward digital highpass filter.

    Apply a forward-backward digital highpass filter to &#39;signal&#39;
    at frequency &#39;f_cut&#39; with an order of &#39;f_order&#39;.
    
    REFERENCES
    ----------
    Design: https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.butter.html
    Filter: https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.sosfiltfilt.html

    &#34;&#34;&#34;
    sos = sp.signal.butter(f_order, f_cut, btype=&#39;highpass&#39;, fs=self.sample_rate, output=&#39;sos&#39;)
    filtered = sp.signal.sosfiltfilt(sos, signal)

    return filtered</code></pre>
</details>
</dd>
<dt id="gwadama.synthetic.NonwhiteGaussianNoise.inject"><code class="name flex">
<span>def <span class="ident">inject</span></span>(<span>self, x, *, snr, snr_lim=None, pos=0, normed=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Add the simulated noise to the signal 'x'.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>array</code></dt>
<dd>Signal array. Its length must be lower or equal to
the length of the noise array.</dd>
<dt><strong><code>snr</code></strong> :&ensp;<code>int</code> or <code>float</code>, optional</dt>
<dd>Signal to Noise Ratio. Defaults to 1.</dd>
<dt><strong><code>snr_lim</code></strong> :&ensp;<code>tuple</code>, optional</dt>
<dd>Limits in 'x' where to calculate the SNR.</dd>
<dt><strong><code>pos</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Index position in the noise array where to inject the signal.
0 by default.</dd>
<dt><strong><code>normed</code></strong> :&ensp;<code>boolean</code>, optional</dt>
<dd>Normalize 'x' to its maximum amplitude after adding the noise.
False by default.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>noisy</code></strong> :&ensp;<code>array</code></dt>
<dd>Signal array with noise at the desired SNR.</dd>
<dt><strong><code>scale</code></strong> :&ensp;<code>float</code></dt>
<dd>Coefficient used to rescale the signal.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inject(self, x, *, snr, snr_lim=None, pos=0, normed=False):
    &#34;&#34;&#34;Add the simulated noise to the signal &#39;x&#39;.

    Parameters
    ----------
    x : array
        Signal array. Its length must be lower or equal to
        the length of the noise array.

    snr : int or float, optional
        Signal to Noise Ratio. Defaults to 1.

    snr_lim : tuple, optional
        Limits in &#39;x&#39; where to calculate the SNR.

    pos : int, optional
        Index position in the noise array where to inject the signal.
        0 by default.

    normed : boolean, optional
        Normalize &#39;x&#39; to its maximum amplitude after adding the noise.
        False by default.

    Returns
    -------
    noisy : array
        Signal array with noise at the desired SNR.

    scale : float
        Coefficient used to rescale the signal.

    &#34;&#34;&#34;
    n = len(x)
    if n &gt; len(self.noise):
        raise ValueError(&#34;&#39;x&#39; is larger than the noise array&#34;)

    if snr_lim is None:
        scale = snr / self.snr(x)
    else:
        scale = snr / self.snr(x[slice(*snr_lim)])

    x_noisy = x * scale + self.noise[pos:pos+n]

    if normed:
        norm = np.max(np.abs(x_noisy))
        x_noisy /= norm
        scale /= norm

    return (x_noisy, scale)</code></pre>
</details>
</dd>
<dt id="gwadama.synthetic.NonwhiteGaussianNoise.rescale"><code class="name flex">
<span>def <span class="ident">rescale</span></span>(<span>self, x, *, snr)</span>
</code></dt>
<dd>
<div class="desc"><p>Rescale the signal 'x' to the given snr w.r.t. the PSD.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>array</code></dt>
<dd>Signal array.</dd>
<dt><strong><code>snr</code></strong> :&ensp;<code>int</code> or <code>float</code>, optional</dt>
<dd>Signal to Noise Ratio. Defaults to 1.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>x_new</code></strong> :&ensp;<code>float</code></dt>
<dd>Rescaled signal.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rescale(self, x, *, snr):
    &#34;&#34;&#34;Rescale the signal &#39;x&#39; to the given snr w.r.t. the PSD.

    Parameters
    ----------
    x : array
        Signal array.

    snr : int or float, optional
        Signal to Noise Ratio. Defaults to 1.

    Returns
    -------
    x_new : float
        Rescaled signal.

    &#34;&#34;&#34;
    factor = snr / self.snr(x)
    x_new = x * factor

    return (x_new, factor)</code></pre>
</details>
</dd>
<dt id="gwadama.synthetic.NonwhiteGaussianNoise.snr"><code class="name flex">
<span>def <span class="ident">snr</span></span>(<span>self, x)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the Signal to Noise Ratio using Clawdia's function.</p>
<p>Due to the legacy code state, I need to compute a sample of the PSD
first. But in the future I plan to make it so that it can take both
a PSD estimation function or an array realization like I did here.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def snr(self, x):
    &#34;&#34;&#34;Compute the Signal to Noise Ratio using Clawdia&#39;s function.
    
    Due to the legacy code state, I need to compute a sample of the PSD
    first. But in the future I plan to make it so that it can take both
    a PSD estimation function or an array realization like I did here.

    &#34;&#34;&#34;
    freqs = np.linspace(self.freq_cutoff, self.freq_nyquist, 2*self.sample_rate)
    psd = np.array([freqs, self.psd(freqs)])
    snr = clawdia.estimators.snr(x, psd=psd, at=1/self.sample_rate, window=(&#39;tukey&#39;,0.1))
    
    return snr</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="gwadama" href="index.html">gwadama</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="gwadama.synthetic.gaussian_waveform" href="#gwadama.synthetic.gaussian_waveform">gaussian_waveform</a></code></li>
<li><code><a title="gwadama.synthetic.ring_down_waveform" href="#gwadama.synthetic.ring_down_waveform">ring_down_waveform</a></code></li>
<li><code><a title="gwadama.synthetic.sine_gaussian_waveform" href="#gwadama.synthetic.sine_gaussian_waveform">sine_gaussian_waveform</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="gwadama.synthetic.NonwhiteGaussianNoise" href="#gwadama.synthetic.NonwhiteGaussianNoise">NonwhiteGaussianNoise</a></code></h4>
<ul class="">
<li><code><a title="gwadama.synthetic.NonwhiteGaussianNoise.highpass_filter" href="#gwadama.synthetic.NonwhiteGaussianNoise.highpass_filter">highpass_filter</a></code></li>
<li><code><a title="gwadama.synthetic.NonwhiteGaussianNoise.inject" href="#gwadama.synthetic.NonwhiteGaussianNoise.inject">inject</a></code></li>
<li><code><a title="gwadama.synthetic.NonwhiteGaussianNoise.rescale" href="#gwadama.synthetic.NonwhiteGaussianNoise.rescale">rescale</a></code></li>
<li><code><a title="gwadama.synthetic.NonwhiteGaussianNoise.snr" href="#gwadama.synthetic.NonwhiteGaussianNoise.snr">snr</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>