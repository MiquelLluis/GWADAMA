
<!DOCTYPE html>


<html lang="en" data-content_root="./" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>gwadama.datasets &#8212; GWADAMA 0.2.1 documentation</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  <!--
    this give us a css class that will be invisible only if js is disabled
  -->
  <noscript>
    <style>
      .pst-js-only { display: none !important; }

    </style>
  </noscript>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="_static/styles/theme.css?digest=8878045cc6db502f8baf" rel="stylesheet" />
<link href="_static/styles/pydata-sphinx-theme.css?digest=8878045cc6db502f8baf" rel="stylesheet" />

    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=362ab14a" />
    <link rel="stylesheet" type="text/css" href="_static/custom.css?v=6e061ff1" />
  
  <!-- So that users can add custom icons -->
  <script src="_static/scripts/fontawesome.js?digest=8878045cc6db502f8baf"></script>
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="_static/scripts/bootstrap.js?digest=8878045cc6db502f8baf" />
<link rel="preload" as="script" href="_static/scripts/pydata-sphinx-theme.js?digest=8878045cc6db502f8baf" />

    <script src="_static/documentation_options.js?v=37f418d5"></script>
    <script src="_static/doctools.js?v=888ff710"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'gwadama.datasets';</script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="gwadama.detectors" href="gwadama.detectors.html" />
    <link rel="prev" title="API Documentation" href="modules.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  <meta name="docsearch:version" content="0.2.1" />
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <dialog id="pst-search-dialog">
    
<form class="bd-search d-flex align-items-center"
      action="search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         placeholder="Search the docs ..."
         aria-label="Search the docs ..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form>
  </dialog>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
<div class="bd-header__inner bd-page-width">
  <button class="pst-navbar-icon sidebar-toggle primary-toggle" aria-label="Site navigation">
    <span class="fa-solid fa-bars"></span>
  </button>
  
  
  <div class="col-lg-3 navbar-header-items__start">
    
      <div class="navbar-item"><div class="navbar-logo">
    <a href="index.html" class="navbar-brand" style="color: inherit; cursor: pointer;">
        <img src="_static/gwadama-logo.png" class="navbar-project-icon" />
        <span class="navbar-project-name">GWADAMA</span>
        <span class="navbar-project-version">v0.2.1</span>
    </a>
</div></div>
    
  </div>
  
  <div class="col-lg-9 navbar-header-items">
    
    <div class="me-auto navbar-header-items__center">
      
        <div class="navbar-item">
<nav>
  <ul class="bd-navbar-elements navbar-nav">
    
<li class="nav-item current active">
  <a class="nav-link nav-internal" href="modules.html">
    API Documentation
  </a>
</li>

  </ul>
</nav></div>
      
    </div>
    
    
    <div class="navbar-header-items__end">
      
        <div class="navbar-item navbar-persistent--container">
          

<button class="btn search-button-field search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
 <i class="fa-solid fa-magnifying-glass"></i>
 <span class="search-button__default-text">Search</span>
 <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
</button>
        </div>
      
      
        <div class="navbar-item">

<button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button pst-js-only" aria-label="Color mode" data-bs-title="Color mode"  data-bs-placement="bottom" data-bs-toggle="tooltip">
  <i class="theme-switch fa-solid fa-sun                fa-lg" data-mode="light" title="Light"></i>
  <i class="theme-switch fa-solid fa-moon               fa-lg" data-mode="dark"  title="Dark"></i>
  <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"  title="System Settings"></i>
</button></div>
      
        <div class="navbar-item"><ul class="navbar-icon-links"
    aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://github.com/MiquelLluis/GWADAMA" title="GitHub" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-square-github fa-lg" aria-hidden="true"></i>
            <span class="sr-only">GitHub</span></a>
        </li>
</ul></div>
      
    </div>
    
  </div>
  
  
    <div class="navbar-persistent--mobile">

<button class="btn search-button-field search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
 <i class="fa-solid fa-magnifying-glass"></i>
 <span class="search-button__default-text">Search</span>
 <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
</button>
    </div>
  

  
    <button class="pst-navbar-icon sidebar-toggle secondary-toggle" aria-label="On this page">
      <span class="fa-solid fa-outdent"></span>
    </button>
  
</div>

    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
      <dialog id="pst-primary-sidebar-modal"></dialog>
      <div id="pst-primary-sidebar" class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
      <div class="sidebar-header-items__center">
        
          
          
            <div class="navbar-item">
<nav>
  <ul class="bd-navbar-elements navbar-nav">
    
<li class="nav-item current active">
  <a class="nav-link nav-internal" href="modules.html">
    API Documentation
  </a>
</li>

  </ul>
</nav></div>
          
        
      </div>
    
    
    
      <div class="sidebar-header-items__end">
        
          <div class="navbar-item">

<button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button pst-js-only" aria-label="Color mode" data-bs-title="Color mode"  data-bs-placement="bottom" data-bs-toggle="tooltip">
  <i class="theme-switch fa-solid fa-sun                fa-lg" data-mode="light" title="Light"></i>
  <i class="theme-switch fa-solid fa-moon               fa-lg" data-mode="dark"  title="Dark"></i>
  <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"  title="System Settings"></i>
</button></div>
        
          <div class="navbar-item"><ul class="navbar-icon-links"
    aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://github.com/MiquelLluis/GWADAMA" title="GitHub" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-square-github fa-lg" aria-hidden="true"></i>
            <span class="sr-only">GitHub</span></a>
        </li>
</ul></div>
        
      </div>
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">
<nav class="bd-docs-nav bd-links"
     aria-label="Section Navigation">
  <p class="bd-links__title" role="heading" aria-level="1">Section Navigation</p>
  <div class="bd-toc-item navbar-nav"><ul class="current nav bd-sidenav">
<li class="toctree-l1 current active"><a class="current reference internal" href="#">gwadama.datasets</a></li>
<li class="toctree-l1"><a class="reference internal" href="gwadama.detectors.html">gwadama.detectors</a></li>
<li class="toctree-l1"><a class="reference internal" href="gwadama.dictools.html">gwadama.dictools</a></li>
<li class="toctree-l1"><a class="reference internal" href="gwadama.fat.html">gwadama.fat</a></li>
<li class="toctree-l1"><a class="reference internal" href="gwadama.ioo.html">gwadama.ioo</a></li>
<li class="toctree-l1"><a class="reference internal" href="gwadama.synthetic.html">gwadama.synthetic</a></li>
<li class="toctree-l1"><a class="reference internal" href="gwadama.tat.html">gwadama.tat</a></li>
<li class="toctree-l1"><a class="reference internal" href="gwadama.units.html">gwadama.units</a></li>
</ul>
</div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
      <div class="sidebar-primary-item">
<div id="ethical-ad-placement"
      class="flat"
      data-ea-publisher="readthedocs"
      data-ea-type="readthedocs-sidebar"
      data-ea-manual="true">
</div></div>
  </div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        
          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item">

<nav aria-label="Breadcrumb" class="d-print-none">
  <ul class="bd-breadcrumbs">
    
    <li class="breadcrumb-item breadcrumb-home">
      <a href="index.html" class="nav-link" aria-label="Home">
        <i class="fa-solid fa-home"></i>
      </a>
    </li>
    
    <li class="breadcrumb-item"><a href="modules.html" class="nav-link">API Documentation</a></li>
    
    <li class="breadcrumb-item active" aria-current="page"><span class="ellipsis">gwadama.datasets</span></li>
  </ul>
</nav>
</div>
      
    </div>
  
  
</div>
</div>
              
              
              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <section id="module-gwadama.datasets">
<span id="gwadama-datasets"></span><h1>gwadama.datasets<a class="headerlink" href="#module-gwadama.datasets" title="Link to this heading">#</a></h1>
<p>datasets.py</p>
<p>Main classes to manage GW datasets.</p>
<p>There are two basic type of datasets, clean and injected:</p>
<ul class="simple">
<li><p>Clean datasets’ classes inherit from the Base class, extending their properties
as needed.</p></li>
<li><p>Injected datasets’ classes inherit from the BaseInjected class, and
optionally from other UserDefined(Base) classes.</p></li>
</ul>
<dl class="py class">
<dt class="sig sig-object py" id="gwadama.datasets.Base">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">gwadama.datasets.</span></span><span class="sig-name descname"><span class="pre">Base</span></span><a class="reference internal" href="_modules/gwadama/datasets.html#Base"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gwadama.datasets.Base" title="Link to this definition">#</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Base class for all datasets.</p>
<p>TODO: Update docstring.</p>
<p>Any dataset made of ‘clean’ (noiseless) GW must inherit this class.
It is designed to store strains as nested dictionaries, with each level’s
key identifying a class/property of the strain. Each individual strain is a
1D NDArray containing the features.</p>
<p>By default there are two basic levels:</p>
<blockquote>
<div><ul class="simple">
<li><p>Class; to group up strains in categories.</p></li>
<li><p>Id; An unique identifier for each strain, which must exist in the
metadata DataFrame as Index.</p></li>
</ul>
</div></blockquote>
<p>Extra depths can be added, and will be thought of as modifications of the
same original strains from the upper identifier level. If splitting the
dataset into train and test susbsets, only combinations of (Class, Id) will
be considered.</p>
<p>NOTE: This class shall not be called directly. Use one of its subclasses.</p>
<dl class="field-list">
<dt class="field-odd">Attributes<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>classes</strong><span class="classifier">dict</span></dt><dd><p>Dict of strings and their integer labels, one per class (category).</p>
</dd>
<dt><strong>metadata</strong><span class="classifier">pandas.DataFrame</span></dt><dd><p>All parameters and data related to the strains.
The order is the same as inside ‘strains’ if unrolled to a flat list
of strains up to the second depth level (the ID).
The total number of different waves must be equal to <cite>len(metadata)</cite>;
this does not include possible variations such polarizations or
multiple scallings of the same waveform when performing injections.</p>
</dd>
<dt><strong>strains</strong><span class="classifier">dict[dict […]]</span></dt><dd><p>Strains stored as a nested dictionary, with each strain in an
independent array to provide more flexibility with data of a wide
range of lengths.</p>
<ul class="simple">
<li><p>Shape: {class: {id: strain} }</p></li>
<li><p>The ‘class’ key is the name of the class, a string which must exist
in the ‘classes’ list.</p></li>
<li><p>The ‘id’ is a unique identifier for each strain, and must exist in
the index of the ‘metadata’ (DataFrame) attribute.</p></li>
<li><p>Extra depths can be added as variations of each strain, such as
polarizations.</p></li>
</ul>
</dd>
<dt><strong>labels</strong><span class="classifier">dict</span></dt><dd><p>Class label of each wave ID, with shape {id: class_label}.
Each ID points to the label of its class in the ‘classes’ attribute.
Can be automatically constructed by calling the ‘_gen_labels()’ method.</p>
</dd>
<dt><strong>max_length</strong><span class="classifier">int</span></dt><dd><p>Length of the longest strain in the dataset.
Remember to update it if modifying the strains length.</p>
</dd>
<dt><strong>times</strong><span class="classifier">dict, optional</span></dt><dd><p>Time samples associated with the strains, following the same structure
up to the second depth level: {class: {id: time_points} }
Useful when the sampling rate is variable or different between strains.
If None, all strains are assumed to be constantly sampled to the
sampling rate indicated by the ‘sample_rate’ attribute.</p>
</dd>
<dt><strong>sample_rate</strong><span class="classifier">int, optional</span></dt><dd><p>If the ‘times’ attribute is present, this value is ignored. Otherwise
it is assumed all strains are constantly sampled to this value.</p>
<p>NOTE: If dealing with variable sampling rates, avoid setting this
attribute to anything other than None.</p>
</dd>
<dt><strong>random_seed</strong><span class="classifier">int, optional</span></dt><dd><p>Value passed to ‘sklearn.model_selection.train_test_split’ to generate
the Train and Test subsets. Saved for reproducibility purposes.</p>
</dd>
<dt><strong>Xtrain, Xtest</strong><span class="classifier">dict, optional</span></dt><dd><p>Train and test subsets randomly split using SKLearn train_test_split
function with stratified labels.
Shape: {id: strain}.
The ‘id’ corresponds to the strain’s index at ‘self.metadata’.
They are just another views into the same data stored at ‘self.strains’,
so no copies are performed.</p>
</dd>
<dt><strong>Ytrain, Ytest</strong><span class="classifier">NDArray[int], optional</span></dt><dd><p>1D Array containing the labels in the same order as ‘Xtrain’ and
‘Xtest’ respectively.
See the attribute ‘labels’ for more info.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<div class="pst-scrollable-table-container"><table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#gwadama.datasets.Base.build_train_test_subsets" title="gwadama.datasets.Base.build_train_test_subsets"><code class="xref py py-obj docutils literal notranslate"><span class="pre">build_train_test_subsets</span></code></a>(train_size[, ...])</p></td>
<td><p>Generate a random Train and Test subsets.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#gwadama.datasets.Base.find_class" title="gwadama.datasets.Base.find_class"><code class="xref py py-obj docutils literal notranslate"><span class="pre">find_class</span></code></a>(id)</p></td>
<td><p>Find which 'class' corresponds the strain 'id'.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#gwadama.datasets.Base.get_strain" title="gwadama.datasets.Base.get_strain"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_strain</span></code></a>(*indices[, normalize])</p></td>
<td><p>Get a single strain from the complete index coordinates.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#gwadama.datasets.Base.get_strains_array" title="gwadama.datasets.Base.get_strains_array"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_strains_array</span></code></a>([length])</p></td>
<td><p>Get all strains stacked in a zero-padded Numpy 2d-array.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#gwadama.datasets.Base.get_times" title="gwadama.datasets.Base.get_times"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_times</span></code></a>(*indices)</p></td>
<td><p>Get a single time array from the complete index coordinates.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#gwadama.datasets.Base.get_xtest_array" title="gwadama.datasets.Base.get_xtest_array"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_xtest_array</span></code></a>([length, classes])</p></td>
<td><p>Get the test subset stacked in a zero-padded Numpy 2d-array.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#gwadama.datasets.Base.get_xtrain_array" title="gwadama.datasets.Base.get_xtrain_array"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_xtrain_array</span></code></a>([length, classes])</p></td>
<td><p>Get the train subset stacked in a zero-padded Numpy 2d-array.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#gwadama.datasets.Base.get_ytest_array" title="gwadama.datasets.Base.get_ytest_array"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_ytest_array</span></code></a>([classes, with_id, with_index])</p></td>
<td><p>Get the filtered test labels.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#gwadama.datasets.Base.get_ytrain_array" title="gwadama.datasets.Base.get_ytrain_array"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_ytrain_array</span></code></a>([classes, with_id, with_index])</p></td>
<td><p>Get the filtered training labels.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#gwadama.datasets.Base.items" title="gwadama.datasets.Base.items"><code class="xref py py-obj docutils literal notranslate"><span class="pre">items</span></code></a>()</p></td>
<td><p>Return a new view of the dataset's items with unrolled indices.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#gwadama.datasets.Base.keys" title="gwadama.datasets.Base.keys"><code class="xref py py-obj docutils literal notranslate"><span class="pre">keys</span></code></a>([max_depth])</p></td>
<td><p>Return the unrolled combinations of all strain identifiers.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#gwadama.datasets.Base.pad_strains" title="gwadama.datasets.Base.pad_strains"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pad_strains</span></code></a>(padding)</p></td>
<td><p>Pad strains with zeros on both sides.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#gwadama.datasets.Base.resample" title="gwadama.datasets.Base.resample"><code class="xref py py-obj docutils literal notranslate"><span class="pre">resample</span></code></a>(sample_rate[, verbose])</p></td>
<td><p>Resample strain and time arrays to a constant rate.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#gwadama.datasets.Base.shrink_strains" title="gwadama.datasets.Base.shrink_strains"><code class="xref py py-obj docutils literal notranslate"><span class="pre">shrink_strains</span></code></a>(limits)</p></td>
<td><p>Shrink strains to a specific interval.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#gwadama.datasets.Base.stack_by_id" title="gwadama.datasets.Base.stack_by_id"><code class="xref py py-obj docutils literal notranslate"><span class="pre">stack_by_id</span></code></a>(id_list[, length])</p></td>
<td><p>Stack an subset of strains by their ID into a Numpy array.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#gwadama.datasets.Base.whiten" title="gwadama.datasets.Base.whiten"><code class="xref py py-obj docutils literal notranslate"><span class="pre">whiten</span></code></a>([asd_array, pad, highpass, flength, ...])</p></td>
<td><p>Whiten the strains.</p></td>
</tr>
</tbody>
</table>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="gwadama.datasets.Base.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/gwadama/datasets.html#Base.__init__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gwadama.datasets.Base.__init__" title="Link to this definition">#</a></dt>
<dd><p>Overwrite when inheriting!</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gwadama.datasets.Base.build_train_test_subsets">
<span class="sig-name descname"><span class="pre">build_train_test_subsets</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">train_size</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_seed</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gwadama/datasets.html#Base.build_train_test_subsets"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gwadama.datasets.Base.build_train_test_subsets" title="Link to this definition">#</a></dt>
<dd><p>Generate a random Train and Test subsets.</p>
<p>Only entries in the index of ‘metadata’ DataFrame are considered
independent waveforms, any extra key (layer) in the ‘strains’ dict
is treated monolithically during the shuffle.</p>
<p>The strain values are just new views into the ‘strains’ attribute.
The shuffling is performed by Scikit-Learn’s function
‘train_test_split’, with stratification enabled.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>train_size</strong><span class="classifier">int | float</span></dt><dd><p>If float, should be between 0.0 and 1.0 and represent the proportion
of the dataset to include in the train subset.
If int, represents the absolute number of train waves.</p>
<p>Ref: <a class="reference external" href="https://scikit-learn.org/stable/modules/generated/sklearn.model_selection.train_test_split.html">https://scikit-learn.org/stable/modules/generated/sklearn.model_selection.train_test_split.html</a></p>
</dd>
<dt><strong>random_seed</strong><span class="classifier">int, optional</span></dt><dd><p>Passed directly to ‘sklearn.model_selection.train_test_split’.
It is also saved in its homonymous attribute.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gwadama.datasets.Base.find_class">
<span class="sig-name descname"><span class="pre">find_class</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">id</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gwadama/datasets.html#Base.find_class"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gwadama.datasets.Base.find_class" title="Link to this definition">#</a></dt>
<dd><p>Find which ‘class’ corresponds the strain ‘id’.</p>
<p>Finds the ‘class’ of the strain represented by the unique identifier
‘id’.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>id</strong><span class="classifier">str</span></dt><dd><p>Unique identifier of the string, that which also appears in the
<cite>metadata.index</cite> DataFrame.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>clas</strong><span class="classifier">int | str</span></dt><dd><p>Class key associated to the strain ‘id’.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gwadama.datasets.Base.get_strain">
<span class="sig-name descname"><span class="pre">get_strain</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">indices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.2)"><span class="pre">ndarray</span></a></span></span><a class="reference internal" href="_modules/gwadama/datasets.html#Base.get_strain"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gwadama.datasets.Base.get_strain" title="Link to this definition">#</a></dt>
<dd><p>Get a single strain from the complete index coordinates.</p>
<p>This is just a shortcut to avoid having to write several squared
brackets.</p>
<p>NOTE: The returned strain is not a copy; if its contents are modified,
the changes will be reflected inside the ‘strains’ attribute.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>*indices</strong><span class="classifier">str | int</span></dt><dd><p>The indices of the strain to retrieve.</p>
</dd>
<dt><strong>normalize</strong><span class="classifier">bool</span></dt><dd><p>If True, the returned strain will be normalized to its maximum
amplitude.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>strain</strong><span class="classifier">np.ndarray</span></dt><dd><p>The requested strain.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gwadama.datasets.Base.get_strains_array">
<span class="sig-name descname"><span class="pre">get_strains_array</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">length</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.2)"><span class="pre">ndarray</span></a></span></span><a class="reference internal" href="_modules/gwadama/datasets.html#Base.get_strains_array"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gwadama.datasets.Base.get_strains_array" title="Link to this definition">#</a></dt>
<dd><p>Get all strains stacked in a zero-padded Numpy 2d-array.</p>
<p>Stacks all signals into an homogeneous numpy array whose length
(axis=1) is determined by either ‘length’ or, if None, by the longest
strain in the subset.
The remaining space is zeroed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>length</strong><span class="classifier">int, optional</span></dt><dd><p>Target length of the ‘strains_array’. If None, the longest signal
determines the length.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>strains_array</strong><span class="classifier">np.ndarray</span></dt><dd><p>train subset.</p>
</dd>
<dt><strong>lengths</strong><span class="classifier">list</span></dt><dd><p>Original length of each strain, following the same order as the
first axis of ‘train_array’.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gwadama.datasets.Base.get_times">
<span class="sig-name descname"><span class="pre">get_times</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">indices</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.2)"><span class="pre">ndarray</span></a></span></span><a class="reference internal" href="_modules/gwadama/datasets.html#Base.get_times"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gwadama.datasets.Base.get_times" title="Link to this definition">#</a></dt>
<dd><p>Get a single time array from the complete index coordinates.</p>
<p>This is just a shortcut to avoid having to write several squared
brackets.</p>
<p>NOTE: The returned strain is not a copy; if its contents are modified,
the changes will be reflected inside the ‘times’ attribute.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gwadama.datasets.Base.get_xtest_array">
<span class="sig-name descname"><span class="pre">get_xtest_array</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">length</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">classes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'all'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gwadama/datasets.html#Base.get_xtest_array"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gwadama.datasets.Base.get_xtest_array" title="Link to this definition">#</a></dt>
<dd><p>Get the test subset stacked in a zero-padded Numpy 2d-array.</p>
<p>Stacks all signals in the test subset into an homogeneous numpy array
whose length (axis=1) is determined by either ‘length’ or, if None, by
the longest strain in the subset. The remaining space is zeroed.</p>
<p>Optionally, classes can be filtered by specifying which to include with
the <cite>classes</cite> parameter.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>length</strong><span class="classifier">int, optional</span></dt><dd></dd>
<dt><strong>classes</strong><span class="classifier">str | List[str], optional</span></dt><dd><p>Specify which classes to include. Include ‘all’ by default.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>test_array</strong><span class="classifier">np.ndarray</span></dt><dd><p>test subset.</p>
</dd>
<dt><strong>lengths</strong><span class="classifier">list</span></dt><dd><p>Original length of each strain, following the same order as the
first axis of ‘test_array’.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gwadama.datasets.Base.get_xtrain_array">
<span class="sig-name descname"><span class="pre">get_xtrain_array</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">length</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">classes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'all'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gwadama/datasets.html#Base.get_xtrain_array"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gwadama.datasets.Base.get_xtrain_array" title="Link to this definition">#</a></dt>
<dd><p>Get the train subset stacked in a zero-padded Numpy 2d-array.</p>
<p>Stacks all signals in the train subset into an homogeneous numpy array
whose length (axis=1) is determined by either ‘length’ or, if None, by
the longest strain in the subset. The remaining space is zeroed.</p>
<p>Optionally, classes can be filtered by specifying which to include with
the <cite>classes</cite> parameter.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>length</strong><span class="classifier">int, optional</span></dt><dd><p>Target length of the ‘train_array’. If None, the longest signal
determines the length.</p>
</dd>
<dt><strong>classes</strong><span class="classifier">str | List[str], optional</span></dt><dd><p>Specify which classes to include. Include ‘all’ by default.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>train_array</strong><span class="classifier">np.ndarray</span></dt><dd><p>train subset.</p>
</dd>
<dt><strong>lengths</strong><span class="classifier">list</span></dt><dd><p>Original length of each strain, following the same order as the
first axis of ‘train_array’.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gwadama.datasets.Base.get_ytest_array">
<span class="sig-name descname"><span class="pre">get_ytest_array</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">classes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'all'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_id</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_index</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gwadama/datasets.html#Base.get_ytest_array"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gwadama.datasets.Base.get_ytest_array" title="Link to this definition">#</a></dt>
<dd><p>Get the filtered test labels.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>classes</strong><span class="classifier">str | list[str] | ‘all’</span></dt><dd><p>The classes to include in the labels.
All classes are included by default.</p>
</dd>
<dt><strong>with_id</strong><span class="classifier">bool</span></dt><dd><p>If True, return also the list of related IDs.</p>
</dd>
<dt><strong>with_index</strong><span class="classifier">bool</span></dt><dd><p>If True, return also the related GLOBAL indices; w.r.t. the stacked
arrays returned by ‘get_xtest_array’ WITHOUT filters.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>np.ndarray</dt><dd><p>Filtered test labels.</p>
</dd>
<dt>np.ndarray, optional</dt><dd><p>IDs associated to the filtered test labels.</p>
</dd>
<dt>np.ndarray, optional</dt><dd><p>Indices associated to the filtered test labels.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gwadama.datasets.Base.get_ytrain_array">
<span class="sig-name descname"><span class="pre">get_ytrain_array</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">classes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'all'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_id</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_index</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gwadama/datasets.html#Base.get_ytrain_array"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gwadama.datasets.Base.get_ytrain_array" title="Link to this definition">#</a></dt>
<dd><p>Get the filtered training labels.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>classes</strong><span class="classifier">str | list[str] | ‘all’</span></dt><dd><p>The classes to include in the labels.
All classes are included by default.</p>
</dd>
<dt><strong>with_id</strong><span class="classifier">bool</span></dt><dd><p>If True, return also the list of related IDs.</p>
</dd>
<dt><strong>with_index</strong><span class="classifier">bool</span></dt><dd><p>If True, return also the related GLOBAL indices; w.r.t. the stacked
arrays returned by ‘get_xtrain_array’ WITHOUT filters.
False by default.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>np.ndarray</dt><dd><p>Filtered train labels.</p>
</dd>
<dt>np.ndarray, optional</dt><dd><p>IDs associated to the filtered train labels.</p>
</dd>
<dt>np.ndarray, optional</dt><dd><p>Indices associated to the filtered train labels.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gwadama.datasets.Base.items">
<span class="sig-name descname"><span class="pre">items</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/gwadama/datasets.html#Base.items"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gwadama.datasets.Base.items" title="Link to this definition">#</a></dt>
<dd><p>Return a new view of the dataset’s items with unrolled indices.</p>
<p>Each iteration consists on a tuple containing all the nested keys in
‘self.strains’ along with the corresponding strain,
(clas, id, <a href="#id1"><span class="problematic" id="id2">*</span></a>, strain).</p>
<p>It can be thought of as an extension of Python’s <cite>dict.items()</cite>.
Useful to quickly iterate over all items in the dataset.</p>
<p>Example of usage with an arbitrary number of keys in the nested
dictionary of strains:</p>
<p><a href="#id3"><span class="problematic" id="id4">``</span></a>`
for <a href="#id5"><span class="problematic" id="id6">*</span></a>keys, strain in self.items():</p>
<blockquote>
<div><p>print(f”Number of identifiers: {len(keys)}”)
print(f”Length of the strain: {len(strain)}”)
do_something(strain)</p>
</div></blockquote>
<p><a href="#id7"><span class="problematic" id="id8">``</span></a><a href="#id9"><span class="problematic" id="id10">`</span></a></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gwadama.datasets.Base.keys">
<span class="sig-name descname"><span class="pre">keys</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">max_depth</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span></span></span><a class="reference internal" href="_modules/gwadama/datasets.html#Base.keys"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gwadama.datasets.Base.keys" title="Link to this definition">#</a></dt>
<dd><p>Return the unrolled combinations of all strain identifiers.</p>
<p>Return the unrolled combinations of all keys  of the nested dictionary
of strains by a hierarchical recursive search.</p>
<p>It can be thought of as the extended version of Python’s
‘dict().keys()’, although this returns a plain list.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>max_depth</strong><span class="classifier">int, optional</span></dt><dd><p>If specified, it is the number of layers to iterate to at most in
the nested ‘strains’ dictionary.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>keys</strong><span class="classifier">list</span></dt><dd><p>The unrolled combination in a Python list.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gwadama.datasets.Base.pad_strains">
<span class="sig-name descname"><span class="pre">pad_strains</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">padding</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">tuple</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">dict</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="reference internal" href="_modules/gwadama/datasets.html#Base.pad_strains"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gwadama.datasets.Base.pad_strains" title="Link to this definition">#</a></dt>
<dd><p>Pad strains with zeros on both sides.</p>
<p>This function pads each strain with a specific number of samples on both sides.
It also updates the ‘max_length’ attribute to reflect the new maximum length of the padded strains.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>padding</strong><span class="classifier">int | tuple | dict</span></dt><dd><p>The padding to apply to each strain.
If padding is an integer, it will be applied at both sides of all strains.
If padding is a tuple, it must be of the form (left_pad, right_pad) in samples.
If padding is a dictionary, it must be of the form {id: (left_pad, right_pad)},
where id is the identifier of each strain.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>If time arrays are present, they are also padded accordingly.</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gwadama.datasets.Base.resample">
<span class="sig-name descname"><span class="pre">resample</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sample_rate</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="reference internal" href="_modules/gwadama/datasets.html#Base.resample"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gwadama.datasets.Base.resample" title="Link to this definition">#</a></dt>
<dd><p>Resample strain and time arrays to a constant rate.</p>
<p>This assumes time tracking either with time arrays or with the
sampling rate provided during initialization, which will be used to
generate the time arrays previous to the resampling.</p>
<p>This method updates the sample_rate and the max_length.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>sample_rate</strong><span class="classifier">int</span></dt><dd><p>The new sampling rate in Hz.</p>
</dd>
<dt><strong>verbose</strong><span class="classifier">bool</span></dt><dd><p>If True, print information about the resampling.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gwadama.datasets.Base.shrink_strains">
<span class="sig-name descname"><span class="pre">shrink_strains</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">limits</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">tuple</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">dict</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="reference internal" href="_modules/gwadama/datasets.html#Base.shrink_strains"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gwadama.datasets.Base.shrink_strains" title="Link to this definition">#</a></dt>
<dd><p>Shrink strains to a specific interval.</p>
<p>Shrink strains (and their associated time arrays if present) to the
interval given by ‘limits’.</p>
<p>It also updates the ‘max_length’ attribute.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>limits</strong><span class="classifier">tuple | dict</span></dt><dd><p>The limits of the interval to shrink to.
If limits is a tuple, it must be of the form (start, end) in
samples.
If limits is a dictionary, it must be of the form {id: (start, end)},
where id is the identifier of each strain.</p>
<p>NOTE: If extra layers below ID are present, they will be shrunk
accordingly.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gwadama.datasets.Base.stack_by_id">
<span class="sig-name descname"><span class="pre">stack_by_id</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">id_list</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">length</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gwadama/datasets.html#Base.stack_by_id"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gwadama.datasets.Base.stack_by_id" title="Link to this definition">#</a></dt>
<dd><p>Stack an subset of strains by their ID into a Numpy array.</p>
<p>Stack an arbitrary selection of strains by their original ID into a
zero-padded 2d-array. The resulting order is the same as the order of
that in ‘id_list’.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>id_list</strong><span class="classifier">list</span></dt><dd><p>The IDs of the strains to be stacked.</p>
</dd>
<dt><strong>length</strong><span class="classifier">int, optional</span></dt><dd><p>The target length of the stacked array. If None, the longest signal
determines the length.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>stacked_signals</strong><span class="classifier">np.ndarray</span></dt><dd><p>The array containing the stacked strains.</p>
</dd>
<dt><strong>lengths</strong><span class="classifier">list</span></dt><dd><p>The original lengths of each strain, following the same order as
the first axis of ‘stacked_signals’.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>Unlike in ‘get_xtrain_array’ and ‘get_xtest_array’, this method does
not filter by ‘classes’ since it would be redundant, as IDs are
unique.</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gwadama.datasets.Base.whiten">
<span class="sig-name descname"><span class="pre">whiten</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">asd_array</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.2)"><span class="pre">ndarray</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pad</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">highpass</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flength</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normed</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="reference internal" href="_modules/gwadama/datasets.html#Base.whiten"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gwadama.datasets.Base.whiten" title="Link to this definition">#</a></dt>
<dd><p>Whiten the strains.</p>
<p>Calling this method performs the whitening of all strains.
Optionally, strains are first zero-padded, whitened and then shrunk to
their initial size. This is useful to remove the vignetting effect.</p>
<p>NOTE: Original (non-whitened) strains will be stored in the
‘nonwhiten_strains’ attribute.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="gwadama.datasets.BaseInjected">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">gwadama.datasets.</span></span><span class="sig-name descname"><span class="pre">BaseInjected</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">clean_dataset</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#gwadama.datasets.Base" title="gwadama.datasets.Base"><span class="pre">Base</span></a></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">psd</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.2)"><span class="pre">ndarray</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Callable</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">detector</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">noise_length</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">freq_cutoff</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">freq_butter_order</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">whiten_params</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">dict</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_seed</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gwadama/datasets.html#BaseInjected"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gwadama.datasets.BaseInjected" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#gwadama.datasets.Base" title="gwadama.datasets.Base"><code class="xref py py-class docutils literal notranslate"><span class="pre">Base</span></code></a></p>
<p>Manage an injected dataset with multiple SNR values.</p>
<p>It is designed to store strains as nested dictionaries, with each level’s
key identifying a class/property of the strain. Each individual strain is a
1D NDArray containing the features.</p>
<p>NOTE: Instances of this class or any other Class(BaseInjected) are
initialized from an instance of any Class(Base) instance (clean dataset).</p>
<p>By default there are THREE basic levels:</p>
<blockquote>
<div><ul class="simple">
<li><p>Class; to group up strains in categories.</p></li>
<li><p>Id; An unique identifier for each strain, which must exist in the
metadata DataFrame as Index.</p></li>
<li><p>SNR; the signal-to-noise ratio at which has been injected w.r.t. a
power spectral density of reference (e.g. the sensitivity of a GW
detector).</p></li>
</ul>
</div></blockquote>
<p>An extra depth can be added below, and will be treated as multiple
injections at the same SNR value. This is usfeul for example to make
injections at multiple noise realizations.</p>
<dl class="field-list">
<dt class="field-odd">Attributes<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>classes</strong><span class="classifier">list[str]</span></dt><dd><p>List of labels, one per class (category).</p>
</dd>
<dt><strong>metadata</strong><span class="classifier">pandas.DataFrame</span></dt><dd><p>All parameters and data related to the original strains, inherited
(copied) from a clean Class(Base) instance.
The order is the same as inside ‘strains’ if unrolled to a flat list
of strains up to the second depth level (the ID).
The total number of different waves must be equal to <cite>len(metadata)</cite>;
this does not include possible variations such polarizations or
multiple scallings of the same waveform when performing injections.</p>
</dd>
<dt><strong>strains_clean</strong><span class="classifier">dict[dict]</span></dt><dd><p>Strains inherited (copied) from a clean Class(Base) instance.
This copy is kept in order to perform new injections.</p>
<ul class="simple">
<li><p>Shape: {class: {id: strain} }</p></li>
<li><p>The ‘class’ key is the name of the class, a string which must exist
in the ‘classes’ list.</p></li>
<li><p>The ‘id’ is a unique identifier for each strain, and must exist in
the index of the ‘metadata’ (DataFrame) attribute.</p></li>
</ul>
<p>NOTE: These strains should be not modified. If new clean strains are
needed, create a new clean dataset instance first, and then initialise
this class with it.</p>
<p>TODO: Accept extra layers in the clean_strains dictionary.</p>
</dd>
<dt><strong>strains</strong><span class="classifier">dict[dict]</span></dt><dd><p>Injected trains stored as a nested dictionary, with each strain in an
independent array to provide more flexibility with data of a wide
range of lengths.</p>
<ul class="simple">
<li><p>Shape: {class: {id: {snr: strain} } }</p></li>
<li><p>The ‘class’ key is the name of the class, a string which must exist
in the ‘classes’ list.</p></li>
<li><p>The ‘id’ is a unique identifier for each strain, and must exist in
the index of the ‘metadata’ (DataFrame) attribute.</p></li>
<li><p>The ‘snr’ key is an integer indicating the signal-to-noise ratio of
the injection.</p></li>
<li><p>A fourth depth can be added below as additional injections per SNR.</p></li>
</ul>
</dd>
<dt><strong>labels</strong><span class="classifier">dict</span></dt><dd><p>Indices of the class of each wave ID, inherited from a clean
Class(Base) instance, with shape {id: class_index}.
Each ID points to the index of its class in the ‘classes’ attribute.</p>
</dd>
<dt><strong>units</strong><span class="classifier">str</span></dt><dd><p>Flag indicating whether the data is in ‘geometrized’ or ‘IS’ units.</p>
</dd>
<dt><strong>times</strong><span class="classifier">dict, optional</span></dt><dd><p>Time samples associated with the strains, following the same structure.
Useful when the sampling rate is variable or different between strains.
If None, all strains are assumed to be constantly sampled to the
sampling rate indicated by the ‘sample_rate’ attribute.</p>
</dd>
<dt><strong>sample_rate</strong><span class="classifier">int</span></dt><dd><p>Inherited from the parent Class(Base) instance.</p>
</dd>
<dt><strong>max_length</strong><span class="classifier">int</span></dt><dd><p>Length of the longest strain in the dataset.
Remember to update it if manually changing strains’ length.</p>
</dd>
<dt><strong>random_seed</strong><span class="classifier">int</span></dt><dd><p>Value passed to ‘sklearn.model_selection.train_test_split’ to generate
the Train and Test subsets. Saved for reproducibility purposes.
Also used to initialize Numpy’s default RandomGenerator.</p>
</dd>
<dt><strong>rng</strong><span class="classifier">np.random.Generator</span></dt><dd><p>Random number generator used for sampling the background noise.
Initialized with <cite>np.random.default_rng(random_seed)</cite>.</p>
</dd>
<dt><strong>detector</strong><span class="classifier">str</span></dt><dd><p>GW detector name.</p>
</dd>
<dt><strong>psd_</strong><span class="classifier">NDArray</span></dt><dd><p>Numerical representation of the Power Spectral Density (PSD) of the
detector’s sensitivity.</p>
</dd>
<dt><strong>asd_</strong><span class="classifier">NDArray</span></dt><dd><p>Numerical representation of the Amplitude Spectral Density (ASD) of the
detector’s sensitivity.</p>
</dd>
<dt><strong>noise</strong><span class="classifier">gwadama.synthetic.NonwhiteGaussianNoise</span></dt><dd><p>Background noise instance from NonwhiteGaussianNoise.</p>
</dd>
<dt><strong>snr_list</strong><span class="classifier">list</span></dt><dd><p>List of SNR values at which each signal has been injected.</p>
</dd>
<dt><strong>pad</strong><span class="classifier">dict</span></dt><dd><p>Padding introduced at each SNR injection, used in case the strains will
be whitened after, to remove the vigneting at edges.
It is associated to SNR values because the only implemented way to
pad the signals is during the signal injection.</p>
</dd>
<dt><strong>injections_per_snr</strong><span class="classifier">int</span></dt><dd><p>Number of injections per SNR value.</p>
</dd>
<dt><strong>whitened</strong><span class="classifier">bool</span></dt><dd><p>Flat indicating whether the dataset has been whitened. Initially will
be set to False, and changed to True after calling the ‘whiten’ method.
Once whitened, this flag will remain True, since the whitening is
implemented to be irreversible instance-wise.</p>
</dd>
<dt><strong>whiten_params</strong><span class="classifier">dict</span></dt><dd><p>TODO</p>
<dl class="simple">
<dt>freq_cutoff<span class="classifier">int | float</span></dt><dd><p>Frequency cutoff below which no noise bins will be generated in the
frequency space, and also used for the high-pass filter applied to
clean signals before injection.</p>
</dd>
<dt>freq_butter_order<span class="classifier">int</span></dt><dd><p>Butterworth filter order.
See (<a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.butter.html">https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.butter.html</a>)
for more information.</p>
</dd>
</dl>
</dd>
<dt><strong>Xtrain, Xtest</strong><span class="classifier">dict, optional</span></dt><dd><p>Train and test subsets randomly split using SKLearn train_test_split
function with stratified labels.
Shape adds the SNR layer: {id: {snr: strain}}.
The ‘id’ corresponds to the strain’s index at ‘self.metadata’.</p>
</dd>
<dt><strong>Ytrain, Ytest</strong><span class="classifier">NDArray[int], optional</span></dt><dd><p>1D Array containing the labels in the same order as ‘Xtrain’ and
‘Xtest’ respectively.</p>
<p>NOTE: Does not include the SNR layer, therefore labels are not repeated.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<div class="pst-scrollable-table-container"><table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#gwadama.datasets.BaseInjected.asd" title="gwadama.datasets.BaseInjected.asd"><code class="xref py py-obj docutils literal notranslate"><span class="pre">asd</span></code></a>(frequencies)</p></td>
<td><p>Amplitude spectral density (ASD) of the detector at given frequencies.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#gwadama.datasets.BaseInjected.build_train_test_subsets" title="gwadama.datasets.BaseInjected.build_train_test_subsets"><code class="xref py py-obj docutils literal notranslate"><span class="pre">build_train_test_subsets</span></code></a>(train_size[, ...])</p></td>
<td><p>Generate a random Train and Test subsets.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#gwadama.datasets.BaseInjected.export_strains_to_gwf" title="gwadama.datasets.BaseInjected.export_strains_to_gwf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">export_strains_to_gwf</span></code></a>(path, channel[, ...])</p></td>
<td><p>Export all strains to GWF format, one file per strain.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#gwadama.datasets.BaseInjected.find_class" title="gwadama.datasets.BaseInjected.find_class"><code class="xref py py-obj docutils literal notranslate"><span class="pre">find_class</span></code></a>(id)</p></td>
<td><p>Find which 'class' corresponds the strain 'id'.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#gwadama.datasets.BaseInjected.gen_injections" title="gwadama.datasets.BaseInjected.gen_injections"><code class="xref py py-obj docutils literal notranslate"><span class="pre">gen_injections</span></code></a>(snr[, pad, randomize_noise, ...])</p></td>
<td><p>Inject all strains in simulated noise with the given SNR values.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#gwadama.datasets.BaseInjected.get_strain" title="gwadama.datasets.BaseInjected.get_strain"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_strain</span></code></a>(*indices[, normalize])</p></td>
<td><p>Get a single strain from the complete index coordinates.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#gwadama.datasets.BaseInjected.get_strains_array" title="gwadama.datasets.BaseInjected.get_strains_array"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_strains_array</span></code></a>([length])</p></td>
<td><p>Get all strains stacked in a zero-padded Numpy 2d-array.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#gwadama.datasets.BaseInjected.get_times" title="gwadama.datasets.BaseInjected.get_times"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_times</span></code></a>(*indices)</p></td>
<td><p>Get a single time array from the complete index coordinates.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#gwadama.datasets.BaseInjected.get_xtest_array" title="gwadama.datasets.BaseInjected.get_xtest_array"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_xtest_array</span></code></a>([length, classes, snr, ...])</p></td>
<td><p>Get the test subset stacked in a zero-padded Numpy 2d-array.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#gwadama.datasets.BaseInjected.get_xtrain_array" title="gwadama.datasets.BaseInjected.get_xtrain_array"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_xtrain_array</span></code></a>([length, classes, snr, ...])</p></td>
<td><p>Get the train subset stacked in a zero-padded Numpy 2d-array.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#gwadama.datasets.BaseInjected.get_ytest_array" title="gwadama.datasets.BaseInjected.get_ytest_array"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_ytest_array</span></code></a>([classes, snr, with_id, ...])</p></td>
<td><p>Get the filtered test labels.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#gwadama.datasets.BaseInjected.get_ytrain_array" title="gwadama.datasets.BaseInjected.get_ytrain_array"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_ytrain_array</span></code></a>([classes, snr, with_id, ...])</p></td>
<td><p>Get the filtered training labels.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#gwadama.datasets.BaseInjected.items" title="gwadama.datasets.BaseInjected.items"><code class="xref py py-obj docutils literal notranslate"><span class="pre">items</span></code></a>()</p></td>
<td><p>Return a new view of the dataset's items with unrolled indices.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#gwadama.datasets.BaseInjected.keys" title="gwadama.datasets.BaseInjected.keys"><code class="xref py py-obj docutils literal notranslate"><span class="pre">keys</span></code></a>([max_depth])</p></td>
<td><p>Return the unrolled combinations of all strain identifiers.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#gwadama.datasets.BaseInjected.pad_strains" title="gwadama.datasets.BaseInjected.pad_strains"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pad_strains</span></code></a>(padding)</p></td>
<td><p>Pad strains with zeros on both sides.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#gwadama.datasets.BaseInjected.psd" title="gwadama.datasets.BaseInjected.psd"><code class="xref py py-obj docutils literal notranslate"><span class="pre">psd</span></code></a>(frequencies)</p></td>
<td><p>Power spectral density (PSD) of the detector at given frequencies.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#gwadama.datasets.BaseInjected.resample" title="gwadama.datasets.BaseInjected.resample"><code class="xref py py-obj docutils literal notranslate"><span class="pre">resample</span></code></a>(sample_rate[, verbose])</p></td>
<td><p>Resample strain and time arrays to a constant rate.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#gwadama.datasets.BaseInjected.shrink_strains" title="gwadama.datasets.BaseInjected.shrink_strains"><code class="xref py py-obj docutils literal notranslate"><span class="pre">shrink_strains</span></code></a>(limits)</p></td>
<td><p>Shrink strains to a specific interval.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#gwadama.datasets.BaseInjected.stack_by_id" title="gwadama.datasets.BaseInjected.stack_by_id"><code class="xref py py-obj docutils literal notranslate"><span class="pre">stack_by_id</span></code></a>(id_list[, length, snr_included])</p></td>
<td><p>Stack a subset of strains by ID into a zero-padded 2d-array.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#gwadama.datasets.BaseInjected.whiten" title="gwadama.datasets.BaseInjected.whiten"><code class="xref py py-obj docutils literal notranslate"><span class="pre">whiten</span></code></a>([verbose])</p></td>
<td><p>Whiten injected strains.</p></td>
</tr>
</tbody>
</table>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="gwadama.datasets.BaseInjected.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">clean_dataset</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#gwadama.datasets.Base" title="gwadama.datasets.Base"><span class="pre">Base</span></a></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">psd</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.2)"><span class="pre">ndarray</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Callable</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">detector</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">noise_length</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">freq_cutoff</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">freq_butter_order</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">whiten_params</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">dict</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_seed</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gwadama/datasets.html#BaseInjected.__init__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gwadama.datasets.BaseInjected.__init__" title="Link to this definition">#</a></dt>
<dd><p>Base constructor for injected datasets.</p>
<p>TODO: Update docstring.</p>
<p>When inheriting from this class, it is recommended to run this method
first in your __init__ function.</p>
<p>Relevant attributes are inherited from the ‘clean_dataset’ instance,
which can be any inherited from BaseDataset whose strains have not
been injected yet.</p>
<p>If train/test subsets are present, they too are updated when performing
injections or changing units, but only through re-building them from
the main ‘strains’ attribute using the already generated indices.
Original train/test subsets from the clean dataset are not inherited.</p>
<p>WARNING: Initializing this class does not perform the injections! For
that use the method ‘gen_injections’.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>clean_dataset</strong><span class="classifier">Base</span></dt><dd><p>Instance of a Class(Base) with noiseless signals.</p>
</dd>
<dt><strong>psd</strong><span class="classifier">np.ndarray | Callable</span></dt><dd><p>Power Spectral Density of the detector’s sensitivity in the range
of frequencies of interest. Can be given as a callable function
whose argument is expected to be an array of frequencies, or as a
2d-array with shape (2, psd_length) so that</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">psd[0]</span> <span class="pre">=</span> <span class="pre">frequency_samples</span>
<span class="pre">psd[1]</span> <span class="pre">=</span> <span class="pre">psd_samples</span>
<span class="pre">`</span></code>.</p>
<p>NOTE: It is also used to compute the ‘asd’ attribute (ASD).</p>
</dd>
<dt><strong>detector</strong><span class="classifier">str</span></dt><dd><p>GW detector name.
Not used, just for identification.</p>
</dd>
<dt><strong>noise_length</strong><span class="classifier">int</span></dt><dd><p>Length of the background noise array to be generated for later use.
It should be at least longer than the longest signal expected to be
injected.</p>
</dd>
<dt><strong>freq_cutoff</strong><span class="classifier">int | float</span></dt><dd><p>Frequency cutoff below which no noise bins will be generated in the
frequency space, and also used for the high-pass filter applied to
clean signals before injection.</p>
</dd>
<dt><strong>freq_butter_order</strong><span class="classifier">int | float</span></dt><dd><p>Butterworth filter order.
See (<a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.butter.html">https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.butter.html</a>)
for more information.</p>
</dd>
<dt><strong>flength</strong><span class="classifier">int</span></dt><dd><p>Length (in samples) of the time-domain FIR whitening filter.</p>
</dd>
<dt><strong>whiten_params</strong><span class="classifier">dict, optional</span></dt><dd><p>Parameters of the whitening filter, with the following entries:</p>
<ul class="simple">
<li><dl class="simple">
<dt>‘flength’<span class="classifier">int</span></dt><dd><p>Length (in samples) of the time-domain FIR whitening.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>‘highpass’<span class="classifier">float</span></dt><dd><p>Frequency cutoff.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>‘normed’<span class="classifier">bool</span></dt><dd><p>Normalization applied after the whitening filter.</p>
</dd>
</dl>
</li>
</ul>
</dd>
<dt><strong>random_seed</strong><span class="classifier">int, optional</span></dt><dd><p>Value passed to ‘sklearn.model_selection.train_test_split’ to
generate the Train and Test subsets.
Saved for reproducibility purposes, and also used to initialize
Numpy’s default RandomGenerator.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gwadama.datasets.BaseInjected.asd">
<span class="sig-name descname"><span class="pre">asd</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">frequencies</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.2)"><span class="pre">ndarray</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.2)"><span class="pre">ndarray</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="_modules/gwadama/datasets.html#BaseInjected.asd"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gwadama.datasets.BaseInjected.asd" title="Link to this definition">#</a></dt>
<dd><p>Amplitude spectral density (ASD) of the detector at given frequencies.</p>
<p>Interpolates the ASD at the given frequencies from their array
representation. If during initialization the ASD was given as its
array representation, the interpolant is computed using SciPy’s
quadratic spline interpolant function.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gwadama.datasets.BaseInjected.build_train_test_subsets">
<span class="sig-name descname"><span class="pre">build_train_test_subsets</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">train_size</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_seed</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#gwadama.datasets.BaseInjected.build_train_test_subsets" title="Link to this definition">#</a></dt>
<dd><p>Generate a random Train and Test subsets.</p>
<p>Only entries in the index of ‘metadata’ DataFrame are considered
independent waveforms, any extra key (layer) in the ‘strains’ dict
is treated monolithically during the shuffle.</p>
<p>The strain values are just new views into the ‘strains’ attribute.
The shuffling is performed by Scikit-Learn’s function
‘train_test_split’, with stratification enabled.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>train_size</strong><span class="classifier">int | float</span></dt><dd><p>If float, should be between 0.0 and 1.0 and represent the proportion
of the dataset to include in the train subset.
If int, represents the absolute number of train waves.</p>
<p>Ref: <a class="reference external" href="https://scikit-learn.org/stable/modules/generated/sklearn.model_selection.train_test_split.html">https://scikit-learn.org/stable/modules/generated/sklearn.model_selection.train_test_split.html</a></p>
</dd>
<dt><strong>random_seed</strong><span class="classifier">int, optional</span></dt><dd><p>Passed directly to ‘sklearn.model_selection.train_test_split’.
It is also saved in its homonymous attribute.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gwadama.datasets.BaseInjected.export_strains_to_gwf">
<span class="sig-name descname"><span class="pre">export_strains_to_gwf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">channel</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t0_gps</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="reference internal" href="_modules/gwadama/datasets.html#BaseInjected.export_strains_to_gwf"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gwadama.datasets.BaseInjected.export_strains_to_gwf" title="Link to this definition">#</a></dt>
<dd><p>Export all strains to GWF format, one file per strain.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gwadama.datasets.BaseInjected.find_class">
<span class="sig-name descname"><span class="pre">find_class</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#gwadama.datasets.BaseInjected.find_class" title="Link to this definition">#</a></dt>
<dd><p>Find which ‘class’ corresponds the strain ‘id’.</p>
<p>Finds the ‘class’ of the strain represented by the unique identifier
‘id’.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>id</strong><span class="classifier">str</span></dt><dd><p>Unique identifier of the string, that which also appears in the
<cite>metadata.index</cite> DataFrame.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>clas</strong><span class="classifier">int | str</span></dt><dd><p>Class key associated to the strain ‘id’.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gwadama.datasets.BaseInjected.gen_injections">
<span class="sig-name descname"><span class="pre">gen_injections</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">snr</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">float</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pad</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">randomize_noise</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_seed</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">injections_per_snr</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gwadama/datasets.html#BaseInjected.gen_injections"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gwadama.datasets.BaseInjected.gen_injections" title="Link to this definition">#</a></dt>
<dd><p>Inject all strains in simulated noise with the given SNR values.</p>
<ul class="simple">
<li><p>The SNR is computed using a matched filter against the noise PSD.</p></li>
<li><p>If <cite>pad &gt; 0</cite>, it also updates the time arrays.</p></li>
<li><p>If strain units are in geometrized, they will be converted first to
IS, injected, and converted back to geometrized.</p></li>
<li><p>After each injection, applies a highpass filter at the low-cut
frequency specified at __init__.</p></li>
<li><p>If the method ‘whiten’ has been already called, all further
injections will automatically be whitened and their pad removed.</p></li>
</ul>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>snr</strong><span class="classifier">int | float | list</span></dt><dd></dd>
<dt><strong>pad</strong><span class="classifier">int</span></dt><dd><p>Number of zeros to pad the signal at both ends before the
injection.</p>
</dd>
<dt><strong>randomize_noise</strong><span class="classifier">bool</span></dt><dd><p>If True, the noise segment is randomly chosen before the injection.
This can be used to avoid having the same noise injected for all
clean strains.
False by default.</p>
<p>NOTE: To avoid the possibility of repeating the same noise section
in different injections, the noise realization must be reasonably
large, e.g:</p>
<blockquote>
<div><p><cite>noise_length &gt; n_clean_strains * self.max_length * len(snr)</cite></p>
</div></blockquote>
</dd>
<dt><strong>random_seed</strong><span class="classifier">int, optional</span></dt><dd><p>Random seed for the noise realization.
Only used when randomize_noise is True.</p>
</dd>
<dt><strong>injections_per_snr</strong><span class="classifier">int</span></dt><dd><p>Number of injections per SNR value. Defaults to 1.</p>
<p>This is useful to minimize the statistical impact of the noise
when performing injections at a sensitive (low) SNR.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>ValueError</dt><dd><p>Once injections have been performed at a certain SNR value, there
cannot be injected again at the same value. Trying it will trigger
this exception.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>If whitening is intended to be applied afterwards it is useful to
pad the signal in order to avoid the window vignetting produced by
the whitening itself. This pad will be cropped afterwards.</p></li>
<li><p>New injections are stored in the ‘strains’ atrribute, with the pad
associated to all the injections performed at once. Even when
whitening is also performed right after the injections.</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gwadama.datasets.BaseInjected.get_strain">
<span class="sig-name descname"><span class="pre">get_strain</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">indices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.2)"><span class="pre">ndarray</span></a></span></span><a class="headerlink" href="#gwadama.datasets.BaseInjected.get_strain" title="Link to this definition">#</a></dt>
<dd><p>Get a single strain from the complete index coordinates.</p>
<p>This is just a shortcut to avoid having to write several squared
brackets.</p>
<p>NOTE: The returned strain is not a copy; if its contents are modified,
the changes will be reflected inside the ‘strains’ attribute.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>*indices</strong><span class="classifier">str | int</span></dt><dd><p>The indices of the strain to retrieve.</p>
</dd>
<dt><strong>normalize</strong><span class="classifier">bool</span></dt><dd><p>If True, the returned strain will be normalized to its maximum
amplitude.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>strain</strong><span class="classifier">np.ndarray</span></dt><dd><p>The requested strain.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gwadama.datasets.BaseInjected.get_strains_array">
<span class="sig-name descname"><span class="pre">get_strains_array</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">length</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.2)"><span class="pre">ndarray</span></a></span></span><a class="headerlink" href="#gwadama.datasets.BaseInjected.get_strains_array" title="Link to this definition">#</a></dt>
<dd><p>Get all strains stacked in a zero-padded Numpy 2d-array.</p>
<p>Stacks all signals into an homogeneous numpy array whose length
(axis=1) is determined by either ‘length’ or, if None, by the longest
strain in the subset.
The remaining space is zeroed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>length</strong><span class="classifier">int, optional</span></dt><dd><p>Target length of the ‘strains_array’. If None, the longest signal
determines the length.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>strains_array</strong><span class="classifier">np.ndarray</span></dt><dd><p>train subset.</p>
</dd>
<dt><strong>lengths</strong><span class="classifier">list</span></dt><dd><p>Original length of each strain, following the same order as the
first axis of ‘train_array’.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gwadama.datasets.BaseInjected.get_times">
<span class="sig-name descname"><span class="pre">get_times</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">indices</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.2)"><span class="pre">ndarray</span></a></span></span><a class="reference internal" href="_modules/gwadama/datasets.html#BaseInjected.get_times"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gwadama.datasets.BaseInjected.get_times" title="Link to this definition">#</a></dt>
<dd><p>Get a single time array from the complete index coordinates.</p>
<p>This is just a shortcut to avoid having to write several squared
brackets.</p>
<p>NOTE: The returned strain is not a copy; if its contents are modified,
the changes will be reflected inside the ‘times’ attribute.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gwadama.datasets.BaseInjected.get_xtest_array">
<span class="sig-name descname"><span class="pre">get_xtest_array</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">length</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">classes</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">list</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'all'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">snr</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">list</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'all'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_metadata</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gwadama/datasets.html#BaseInjected.get_xtest_array"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gwadama.datasets.BaseInjected.get_xtest_array" title="Link to this definition">#</a></dt>
<dd><p>Get the test subset stacked in a zero-padded Numpy 2d-array.</p>
<p>Stacks all signals in the test subset into an homogeneous numpy array
whose length (axis=1) is determined by either ‘length’ or, if None, by
the longest strain in the subset. The remaining space is zeroed.</p>
<p>Allows the possibility to filter by class and SNR.</p>
<p>NOTE: Same signals injected at different SNR are stacked continuously.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>length</strong><span class="classifier">int, optional</span></dt><dd><p>Target length of the ‘test_array’. If None, the longest signal
determines the length.</p>
</dd>
<dt><strong>classes</strong><span class="classifier">str | list[str]</span></dt><dd><p>Whitelist of classes to include in the stack.
All classes are included by default.</p>
</dd>
<dt><strong>snr</strong><span class="classifier">int | list[int] | str</span></dt><dd><p>Whitelist of SNR injections to include in the stack. If more than
one are selected, they are stacked zipped as follows:</p>
<p><a href="#id11"><span class="problematic" id="id12">``</span></a>`
eos0 id0 snr0
eos0 id0 snr1</p>
<blockquote>
<div><p>…</p>
</div></blockquote>
<p><a href="#id13"><span class="problematic" id="id14">``</span></a><a href="#id15"><span class="problematic" id="id16">`</span></a></p>
<p>All injections are included by default.</p>
</dd>
<dt><strong>with_metadata</strong><span class="classifier">bool</span></dt><dd><p>If True, the associated metadata is returned in addition to the
test array in a Pandas DataFrame instance.
This metadata is obtained from the original ‘metadata’ attribute,
with the former index inserted as the first column, ‘id’, and with an
additional column for the SNR values.
False by default.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>test_array</strong><span class="classifier">np.ndarray</span></dt><dd><p>Test subset.</p>
</dd>
<dt><strong>lengths</strong><span class="classifier">list</span></dt><dd><p>Original length of each strain, following the same order as the
first axis of ‘test_array’.</p>
</dd>
<dt><strong>metadata</strong><span class="classifier">pd.DataFrame, optional</span></dt><dd><p>If ‘with_metadata’ is True, the associated metadata is returned
with its entries in the same order as the ‘test_array’.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gwadama.datasets.BaseInjected.get_xtrain_array">
<span class="sig-name descname"><span class="pre">get_xtrain_array</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">length</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">classes</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">list</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'all'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">snr</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">list</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'all'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_metadata</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gwadama/datasets.html#BaseInjected.get_xtrain_array"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gwadama.datasets.BaseInjected.get_xtrain_array" title="Link to this definition">#</a></dt>
<dd><p>Get the train subset stacked in a zero-padded Numpy 2d-array.</p>
<p>Stacks all signals in the train subset into an homogeneous numpy array
whose length (axis=1) is determined by either ‘length’ or, if None, by
the longest strain in the subset. The remaining space is zeroed.</p>
<p>Allows the possibility to filter by class and SNR.</p>
<p>NOTE: Same signals injected at different SNR are stacked continuously.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>length</strong><span class="classifier">int, optional</span></dt><dd><p>Target length of the ‘train_array’. If None, the longest signal
determines the length.</p>
</dd>
<dt><strong>classes</strong><span class="classifier">str | list[str]</span></dt><dd><p>Whitelist of classes to include in the stack.
All classes are included by default.</p>
</dd>
<dt><strong>snr</strong><span class="classifier">int | list[int] | str</span></dt><dd><p>Whitelist of SNR injections to include in the stack. If more than
one are selected, they are stacked zipped as follows:</p>
<p><a href="#id17"><span class="problematic" id="id18">``</span></a>`
eos0 id0 snr0
eos0 id0 snr1</p>
<blockquote>
<div><p>…</p>
</div></blockquote>
<p><a href="#id19"><span class="problematic" id="id20">``</span></a><a href="#id21"><span class="problematic" id="id22">`</span></a></p>
<p>All injections are included by default.</p>
</dd>
<dt><strong>with_metadata</strong><span class="classifier">bool</span></dt><dd><p>If True, the associated metadata is returned in addition to the
train array in a Pandas DataFrame instance.
This metadata is obtained from the original ‘metadata’ attribute,
with the former index inserted as the first column, ‘id’, and with an
additional column for the SNR values.
False by default.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>train_array</strong><span class="classifier">np.ndarray</span></dt><dd><p>Train subset.</p>
</dd>
<dt><strong>lengths</strong><span class="classifier">list</span></dt><dd><p>Original length of each strain, following the same order as the
first axis of ‘train_array’.</p>
</dd>
<dt><strong>metadata</strong><span class="classifier">pd.DataFrame, optional</span></dt><dd><p>If ‘with_metadata’ is True, the associated metadata is returned
with its entries in the same order as the ‘train_array’.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gwadama.datasets.BaseInjected.get_ytest_array">
<span class="sig-name descname"><span class="pre">get_ytest_array</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">classes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'all'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">snr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'all'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_id</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_index</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gwadama/datasets.html#BaseInjected.get_ytest_array"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gwadama.datasets.BaseInjected.get_ytest_array" title="Link to this definition">#</a></dt>
<dd><p>Get the filtered test labels.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>classes</strong><span class="classifier">str | list[str] | ‘all’</span></dt><dd><p>Whitelist of classes to include in the labels.
All classes are included by default.</p>
</dd>
<dt><strong>snr</strong><span class="classifier">int | list[int] | str</span></dt><dd><p>Whitelist of SNR injections to include in the labels.
All injections are included by default.</p>
</dd>
<dt><strong>with_id</strong><span class="classifier">bool</span></dt><dd><p>If True, return also the related IDs.
False by default.</p>
</dd>
<dt><strong>with_index</strong><span class="classifier">bool</span></dt><dd><p>If True, return also the related GLOBAL indices w.r.t. the stacked
arrays returned by ‘get_xtest_array’ WITHOUT filters.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>np.ndarray</dt><dd><p>Filtered test labels.</p>
</dd>
<dt>np.ndarray, optional</dt><dd><p>IDs associated to the filtered test labels.</p>
</dd>
<dt>np.ndarray, optional</dt><dd><p>Indices associated to the filtered test labels.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gwadama.datasets.BaseInjected.get_ytrain_array">
<span class="sig-name descname"><span class="pre">get_ytrain_array</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">classes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'all'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">snr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'all'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_id</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_index</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gwadama/datasets.html#BaseInjected.get_ytrain_array"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gwadama.datasets.BaseInjected.get_ytrain_array" title="Link to this definition">#</a></dt>
<dd><p>Get the filtered training labels.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>classes</strong><span class="classifier">str | list[str] | ‘all’</span></dt><dd><p>Whitelist of classes to include in the labels.
All classes are included by default.</p>
</dd>
<dt><strong>snr</strong><span class="classifier">int | list[int] | str</span></dt><dd><p>Whitelist of SNR injections to include in the labels.
All injections are included by default.</p>
</dd>
<dt><strong>with_id</strong><span class="classifier">bool</span></dt><dd><p>If True, return also the related IDs.
False by default.</p>
</dd>
<dt><strong>with_index</strong><span class="classifier">bool</span></dt><dd><p>If True, return also the related GLOBAL indices w.r.t. the stacked
arrays returned by ‘get_xtrain_array’ WITHOUT filters.
False by default.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>np.ndarray</dt><dd><p>Filtered train labels.</p>
</dd>
<dt>np.ndarray, optional</dt><dd><p>IDs associated to the filtered train labels.</p>
</dd>
<dt>np.ndarray, optional</dt><dd><p>Indices associated to the filtered train labels.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gwadama.datasets.BaseInjected.items">
<span class="sig-name descname"><span class="pre">items</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gwadama.datasets.BaseInjected.items" title="Link to this definition">#</a></dt>
<dd><p>Return a new view of the dataset’s items with unrolled indices.</p>
<p>Each iteration consists on a tuple containing all the nested keys in
‘self.strains’ along with the corresponding strain,
(clas, id, <a href="#id23"><span class="problematic" id="id24">*</span></a>, strain).</p>
<p>It can be thought of as an extension of Python’s <cite>dict.items()</cite>.
Useful to quickly iterate over all items in the dataset.</p>
<p>Example of usage with an arbitrary number of keys in the nested
dictionary of strains:</p>
<p><a href="#id25"><span class="problematic" id="id26">``</span></a>`
for <a href="#id27"><span class="problematic" id="id28">*</span></a>keys, strain in self.items():</p>
<blockquote>
<div><p>print(f”Number of identifiers: {len(keys)}”)
print(f”Length of the strain: {len(strain)}”)
do_something(strain)</p>
</div></blockquote>
<p><a href="#id29"><span class="problematic" id="id30">``</span></a><a href="#id31"><span class="problematic" id="id32">`</span></a></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gwadama.datasets.BaseInjected.keys">
<span class="sig-name descname"><span class="pre">keys</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">max_depth</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span></span></span><a class="headerlink" href="#gwadama.datasets.BaseInjected.keys" title="Link to this definition">#</a></dt>
<dd><p>Return the unrolled combinations of all strain identifiers.</p>
<p>Return the unrolled combinations of all keys  of the nested dictionary
of strains by a hierarchical recursive search.</p>
<p>It can be thought of as the extended version of Python’s
‘dict().keys()’, although this returns a plain list.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>max_depth</strong><span class="classifier">int, optional</span></dt><dd><p>If specified, it is the number of layers to iterate to at most in
the nested ‘strains’ dictionary.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>keys</strong><span class="classifier">list</span></dt><dd><p>The unrolled combination in a Python list.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gwadama.datasets.BaseInjected.pad_strains">
<span class="sig-name descname"><span class="pre">pad_strains</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">padding</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">tuple</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">dict</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#gwadama.datasets.BaseInjected.pad_strains" title="Link to this definition">#</a></dt>
<dd><p>Pad strains with zeros on both sides.</p>
<p>This function pads each strain with a specific number of samples on both sides.
It also updates the ‘max_length’ attribute to reflect the new maximum length of the padded strains.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>padding</strong><span class="classifier">int | tuple | dict</span></dt><dd><p>The padding to apply to each strain.
If padding is an integer, it will be applied at both sides of all strains.
If padding is a tuple, it must be of the form (left_pad, right_pad) in samples.
If padding is a dictionary, it must be of the form {id: (left_pad, right_pad)},
where id is the identifier of each strain.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>If time arrays are present, they are also padded accordingly.</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gwadama.datasets.BaseInjected.psd">
<span class="sig-name descname"><span class="pre">psd</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">frequencies</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.2)"><span class="pre">ndarray</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.2)"><span class="pre">ndarray</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="_modules/gwadama/datasets.html#BaseInjected.psd"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gwadama.datasets.BaseInjected.psd" title="Link to this definition">#</a></dt>
<dd><p>Power spectral density (PSD) of the detector at given frequencies.</p>
<p>Interpolates the PSD at the given frequencies from their array
representation. If during initialization the PSD was given as its
array representation, the interpolant is computed using SciPy’s
quadratic spline interpolant function.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gwadama.datasets.BaseInjected.resample">
<span class="sig-name descname"><span class="pre">resample</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sample_rate</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#gwadama.datasets.BaseInjected.resample" title="Link to this definition">#</a></dt>
<dd><p>Resample strain and time arrays to a constant rate.</p>
<p>This assumes time tracking either with time arrays or with the
sampling rate provided during initialization, which will be used to
generate the time arrays previous to the resampling.</p>
<p>This method updates the sample_rate and the max_length.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>sample_rate</strong><span class="classifier">int</span></dt><dd><p>The new sampling rate in Hz.</p>
</dd>
<dt><strong>verbose</strong><span class="classifier">bool</span></dt><dd><p>If True, print information about the resampling.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gwadama.datasets.BaseInjected.shrink_strains">
<span class="sig-name descname"><span class="pre">shrink_strains</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">limits</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">tuple</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">dict</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#gwadama.datasets.BaseInjected.shrink_strains" title="Link to this definition">#</a></dt>
<dd><p>Shrink strains to a specific interval.</p>
<p>Shrink strains (and their associated time arrays if present) to the
interval given by ‘limits’.</p>
<p>It also updates the ‘max_length’ attribute.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>limits</strong><span class="classifier">tuple | dict</span></dt><dd><p>The limits of the interval to shrink to.
If limits is a tuple, it must be of the form (start, end) in
samples.
If limits is a dictionary, it must be of the form {id: (start, end)},
where id is the identifier of each strain.</p>
<p>NOTE: If extra layers below ID are present, they will be shrunk
accordingly.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gwadama.datasets.BaseInjected.stack_by_id">
<span class="sig-name descname"><span class="pre">stack_by_id</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">id_list</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">length</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">snr_included</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'all'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gwadama/datasets.html#BaseInjected.stack_by_id"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gwadama.datasets.BaseInjected.stack_by_id" title="Link to this definition">#</a></dt>
<dd><p>Stack a subset of strains by ID into a zero-padded 2d-array.</p>
<p>This may allow (for example) to group up strains by their original ID
without leaking differnet injections (SNR) of the same strain into
different splits.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>id_list</strong><span class="classifier">array-like</span></dt><dd><p>The IDs of the strains to be stacked.</p>
</dd>
<dt><strong>length</strong><span class="classifier">int, optional</span></dt><dd><p>The target length of the stacked array. If None, the longest signal
determines the length.</p>
</dd>
<dt><strong>snr_included</strong><span class="classifier">int | list[int] | str, optional</span></dt><dd><p>The SNR injections to include in the stack. If more than one are
selected, they are stacked zipped as follows:</p>
<p><a href="#id33"><span class="problematic" id="id34">``</span></a>`
id0 snr0
id0 snr1</p>
<blockquote>
<div><p>…</p>
</div></blockquote>
<p><a href="#id35"><span class="problematic" id="id36">``</span></a><a href="#id37"><span class="problematic" id="id38">`</span></a></p>
<p>All injections are included by default.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>stacked_signals</strong><span class="classifier">np.ndarray</span></dt><dd><p>The array containing the stacked strains.</p>
</dd>
<dt><strong>lengths</strong><span class="classifier">list</span></dt><dd><p>The original lengths of each strain, following the same order as
the first axis of ‘stacked_signals’.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt>ValueError</dt><dd><p>If the value of ‘snr’ is not valid.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>Unlike in ‘get_xtrain_array’ and ‘get_xtest_array’, this method does
not filter by ‘classes’ since it would be redundant, as IDs are
unique.</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gwadama.datasets.BaseInjected.whiten">
<span class="sig-name descname"><span class="pre">whiten</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gwadama/datasets.html#BaseInjected.whiten"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gwadama.datasets.BaseInjected.whiten" title="Link to this definition">#</a></dt>
<dd><p>Whiten injected strains.</p>
<p>Calling this method performs the whitening of all injected strains.
Strains are later cut to their original size before adding the pad,
to remove the vigneting.</p>
<p>NOTE: This is an irreversible action; if the original injections need
to be preserved it is advised to make a copy of the instance before
performing the whitening.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="gwadama.datasets.CoReWaves">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">gwadama.datasets.</span></span><span class="sig-name descname"><span class="pre">CoReWaves</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">coredb</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="gwadama.ioo.html#gwadama.ioo.CoReManager" title="gwadama.ioo.CoReManager"><span class="pre">CoReManager</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">classes</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">dict</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">discarded</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">set</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cropped</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">dict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">distance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inclination</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phi</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gwadama/datasets.html#CoReWaves"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gwadama.datasets.CoReWaves" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#gwadama.datasets.Base" title="gwadama.datasets.Base"><code class="xref py py-class docutils literal notranslate"><span class="pre">Base</span></code></a></p>
<p>Manage all operations needed to perform over a noiseless CoRe dataset.</p>
<p>Initial strains and metadata are obtained from a CoReManager instance.</p>
<p>NOTE: This class treats as different classes (categories) each equation of
state (EOS) present in the CoReManager instance.</p>
<p>NOTE^2: This class adds a time attribute with time samples related to each
GW.</p>
<p>Workflow:</p>
<ul class="simple">
<li><p>Load the strains from a CoreWaEasy instance, discarding or cropping those
indicated with their respective arguments.</p></li>
<li><p>Resample.</p></li>
<li><p>Project onto the ET detector arms.</p></li>
<li><p>Change units and scale from geometrized to IS and vice versa.</p></li>
<li><p>Export the (latest version of) dataset to a HDF5.</p></li>
<li><p>Export the (latest version of) dataset to a GWF.</p></li>
</ul>
<dl class="field-list">
<dt class="field-odd">Attributes<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>classes</strong><span class="classifier">dict</span></dt><dd><p>Dict of strings and their integer labels, one per class (category).
The keys are the name of the Equation of State (EOS) used to describe
the physics behind the simulation which produced each strain.</p>
</dd>
<dt><strong>strains</strong><span class="classifier">dict {class: {id: gw_strain} }</span></dt><dd><p>Strains stored as a nested dictionary, with each strain in an
independent array to provide more flexibility with data of a wide
range of lengths.
The class key is the name of the class, a string which must exist in
the ‘classes’ list.
The ‘id’ is an unique identifier for each strain, and must exist in the
<cite>self.metadata.index</cite> column of the metadata DataFrame.
Initially, an extra depth layer is defined to store the polarizations
of the CoRe GW simulated data. After the projection this layer will be
collapsed to a single strain.</p>
</dd>
<dt><strong>times</strong><span class="classifier">dict {class: {id: gw_time_points} }</span></dt><dd><p>Time samples associated with the strains, following the same structure.
Useful when the sampling rate is variable or different between strains.</p>
</dd>
<dt><strong>metadata</strong><span class="classifier">pandas.DataFrame</span></dt><dd><p>All parameters and data related to the strains.
The order is the same as inside ‘strains’ if unrolled to a flat list
of strains up to the second depth level (the id.).
Example:</p>
<p><a href="#id39"><span class="problematic" id="id40">``</span></a>`
metadata[eos][key] = {</p>
<blockquote>
<div><p>‘id’: str,
‘mass’: float,
‘mass_ratio’: float,
‘eccentricity’: float,
‘mass_starA’: float,
‘mass_starB’: float,
‘spin_starA’: float,
‘spin_starB’: float</p>
</div></blockquote>
</dd>
<dt><strong>units</strong><span class="classifier">str</span></dt><dd><p>Flag indicating whether the data is in ‘geometrized’ or ‘IS’ units.</p>
</dd>
<dt><strong>sample_rate</strong><span class="classifier">int, optional</span></dt><dd><p>Initially this attribute is None because the initial GW from CoRe are
sampled at different and non-constant sampling rates. After the
resampling, this attribute will be set to the new global sampling rate.</p>
<p>Caveat: If the ‘times’ attribute is present, this value is ignored.
Otherwise it is assumed all strains are constantly sampled to this.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<div class="pst-scrollable-table-container"><table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#gwadama.datasets.CoReWaves.build_train_test_subsets" title="gwadama.datasets.CoReWaves.build_train_test_subsets"><code class="xref py py-obj docutils literal notranslate"><span class="pre">build_train_test_subsets</span></code></a>(train_size[, ...])</p></td>
<td><p>Generate a random Train and Test subsets.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#gwadama.datasets.CoReWaves.convert_to_IS_units" title="gwadama.datasets.CoReWaves.convert_to_IS_units"><code class="xref py py-obj docutils literal notranslate"><span class="pre">convert_to_IS_units</span></code></a>()</p></td>
<td><p>Convert data from scaled geometrized units to IS units.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#gwadama.datasets.CoReWaves.convert_to_scaled_geometrized_units" title="gwadama.datasets.CoReWaves.convert_to_scaled_geometrized_units"><code class="xref py py-obj docutils literal notranslate"><span class="pre">convert_to_scaled_geometrized_units</span></code></a>()</p></td>
<td><p>Convert data from IS to scaled geometrized units.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#gwadama.datasets.CoReWaves.find_class" title="gwadama.datasets.CoReWaves.find_class"><code class="xref py py-obj docutils literal notranslate"><span class="pre">find_class</span></code></a>(id)</p></td>
<td><p>Find which 'class' corresponds the strain 'id'.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#gwadama.datasets.CoReWaves.get_strain" title="gwadama.datasets.CoReWaves.get_strain"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_strain</span></code></a>(*indices[, normalize])</p></td>
<td><p>Get a single strain from the complete index coordinates.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#gwadama.datasets.CoReWaves.get_strains_array" title="gwadama.datasets.CoReWaves.get_strains_array"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_strains_array</span></code></a>([length])</p></td>
<td><p>Get all strains stacked in a zero-padded Numpy 2d-array.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#gwadama.datasets.CoReWaves.get_times" title="gwadama.datasets.CoReWaves.get_times"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_times</span></code></a>(*indices)</p></td>
<td><p>Get a single time array from the complete index coordinates.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#gwadama.datasets.CoReWaves.get_xtest_array" title="gwadama.datasets.CoReWaves.get_xtest_array"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_xtest_array</span></code></a>([length, classes])</p></td>
<td><p>Get the test subset stacked in a zero-padded Numpy 2d-array.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#gwadama.datasets.CoReWaves.get_xtrain_array" title="gwadama.datasets.CoReWaves.get_xtrain_array"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_xtrain_array</span></code></a>([length, classes])</p></td>
<td><p>Get the train subset stacked in a zero-padded Numpy 2d-array.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#gwadama.datasets.CoReWaves.get_ytest_array" title="gwadama.datasets.CoReWaves.get_ytest_array"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_ytest_array</span></code></a>([classes, with_id, with_index])</p></td>
<td><p>Get the filtered test labels.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#gwadama.datasets.CoReWaves.get_ytrain_array" title="gwadama.datasets.CoReWaves.get_ytrain_array"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_ytrain_array</span></code></a>([classes, with_id, with_index])</p></td>
<td><p>Get the filtered training labels.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#gwadama.datasets.CoReWaves.items" title="gwadama.datasets.CoReWaves.items"><code class="xref py py-obj docutils literal notranslate"><span class="pre">items</span></code></a>()</p></td>
<td><p>Return a new view of the dataset's items with unrolled indices.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#gwadama.datasets.CoReWaves.keys" title="gwadama.datasets.CoReWaves.keys"><code class="xref py py-obj docutils literal notranslate"><span class="pre">keys</span></code></a>([max_depth])</p></td>
<td><p>Return the unrolled combinations of all strain identifiers.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#gwadama.datasets.CoReWaves.pad_strains" title="gwadama.datasets.CoReWaves.pad_strains"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pad_strains</span></code></a>(padding)</p></td>
<td><p>Pad strains with zeros on both sides.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#gwadama.datasets.CoReWaves.project" title="gwadama.datasets.CoReWaves.project"><code class="xref py py-obj docutils literal notranslate"><span class="pre">project</span></code></a>(*, detector, ra, dec, geo_time, psi)</p></td>
<td><p>Project strains into the chosen detector at specified coordinates.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#gwadama.datasets.CoReWaves.resample" title="gwadama.datasets.CoReWaves.resample"><code class="xref py py-obj docutils literal notranslate"><span class="pre">resample</span></code></a>(sample_rate[, verbose])</p></td>
<td><p>Resample strain and time arrays to a constant rate.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#gwadama.datasets.CoReWaves.shrink_strains" title="gwadama.datasets.CoReWaves.shrink_strains"><code class="xref py py-obj docutils literal notranslate"><span class="pre">shrink_strains</span></code></a>(limits)</p></td>
<td><p>Shrink strains to a specific interval.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#gwadama.datasets.CoReWaves.shrink_to_merger" title="gwadama.datasets.CoReWaves.shrink_to_merger"><code class="xref py py-obj docutils literal notranslate"><span class="pre">shrink_to_merger</span></code></a>([offset])</p></td>
<td><p>Shrink strains and time arrays w.r.t.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#gwadama.datasets.CoReWaves.stack_by_id" title="gwadama.datasets.CoReWaves.stack_by_id"><code class="xref py py-obj docutils literal notranslate"><span class="pre">stack_by_id</span></code></a>(id_list[, length])</p></td>
<td><p>Stack an subset of strains by their ID into a Numpy array.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#gwadama.datasets.CoReWaves.whiten" title="gwadama.datasets.CoReWaves.whiten"><code class="xref py py-obj docutils literal notranslate"><span class="pre">whiten</span></code></a>([asd_array, pad, highpass, flength, ...])</p></td>
<td><p>Whiten the strains.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="pst-scrollable-table-container"><table class="table">
<tbody>
<tr class="row-odd"><td><p><strong>find_merger</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="gwadama.datasets.CoReWaves.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">coredb</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="gwadama.ioo.html#gwadama.ioo.CoReManager" title="gwadama.ioo.CoReManager"><span class="pre">CoReManager</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">classes</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">dict</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">discarded</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">set</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cropped</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">dict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">distance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inclination</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phi</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gwadama/datasets.html#CoReWaves.__init__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gwadama.datasets.CoReWaves.__init__" title="Link to this definition">#</a></dt>
<dd><p>Initialize a CoReWaves dataset.</p>
<p>TODO</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>coredb</strong><span class="classifier">ioo.CoReManager</span></dt><dd><p>Instance of CoReManager with the actual data.</p>
</dd>
<dt><strong>classes</strong><span class="classifier">dict[str]</span></dt><dd><p>Dictionary with the Equation of State (class) name as key and the
corresponding label index as value.</p>
</dd>
<dt><strong>discarded</strong><span class="classifier">set[str]</span></dt><dd><p>Set of GW IDs to discard from the dataset.</p>
</dd>
<dt><strong>cropped</strong><span class="classifier">dict[str]</span></dt><dd><p>Dictionary with the class name as key and the corresponding
cropping range as value. The range is given as a tuple of the form
(start_index, stop_index).</p>
</dd>
<dt><strong>distance</strong><span class="classifier">float</span></dt><dd><p>Distance to the source in Mpc.</p>
</dd>
<dt><strong>inclination</strong><span class="classifier">float</span></dt><dd><p>Inclination of the source in radians.</p>
</dd>
<dt><strong>phi</strong><span class="classifier">float</span></dt><dd><p>Azimuthal angle of the source in radians.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gwadama.datasets.CoReWaves.build_train_test_subsets">
<span class="sig-name descname"><span class="pre">build_train_test_subsets</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">train_size</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_seed</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#gwadama.datasets.CoReWaves.build_train_test_subsets" title="Link to this definition">#</a></dt>
<dd><p>Generate a random Train and Test subsets.</p>
<p>Only entries in the index of ‘metadata’ DataFrame are considered
independent waveforms, any extra key (layer) in the ‘strains’ dict
is treated monolithically during the shuffle.</p>
<p>The strain values are just new views into the ‘strains’ attribute.
The shuffling is performed by Scikit-Learn’s function
‘train_test_split’, with stratification enabled.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>train_size</strong><span class="classifier">int | float</span></dt><dd><p>If float, should be between 0.0 and 1.0 and represent the proportion
of the dataset to include in the train subset.
If int, represents the absolute number of train waves.</p>
<p>Ref: <a class="reference external" href="https://scikit-learn.org/stable/modules/generated/sklearn.model_selection.train_test_split.html">https://scikit-learn.org/stable/modules/generated/sklearn.model_selection.train_test_split.html</a></p>
</dd>
<dt><strong>random_seed</strong><span class="classifier">int, optional</span></dt><dd><p>Passed directly to ‘sklearn.model_selection.train_test_split’.
It is also saved in its homonymous attribute.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gwadama.datasets.CoReWaves.convert_to_IS_units">
<span class="sig-name descname"><span class="pre">convert_to_IS_units</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="reference internal" href="_modules/gwadama/datasets.html#CoReWaves.convert_to_IS_units"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gwadama.datasets.CoReWaves.convert_to_IS_units" title="Link to this definition">#</a></dt>
<dd><p>Convert data from scaled geometrized units to IS units.</p>
<p>Convert strains and times from geometrized units (scaled to the mass
of the system and the source distance) to IS units.</p>
<p>Will raise an error if the data is already in IS units.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gwadama.datasets.CoReWaves.convert_to_scaled_geometrized_units">
<span class="sig-name descname"><span class="pre">convert_to_scaled_geometrized_units</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="reference internal" href="_modules/gwadama/datasets.html#CoReWaves.convert_to_scaled_geometrized_units"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gwadama.datasets.CoReWaves.convert_to_scaled_geometrized_units" title="Link to this definition">#</a></dt>
<dd><p>Convert data from IS to scaled geometrized units.</p>
<p>Convert strains and times from IS to geometrized units, and scaled to the mass
of the system and the source distance.</p>
<p>Will raise an error if the data is already in geometrized units.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gwadama.datasets.CoReWaves.find_class">
<span class="sig-name descname"><span class="pre">find_class</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#gwadama.datasets.CoReWaves.find_class" title="Link to this definition">#</a></dt>
<dd><p>Find which ‘class’ corresponds the strain ‘id’.</p>
<p>Finds the ‘class’ of the strain represented by the unique identifier
‘id’.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>id</strong><span class="classifier">str</span></dt><dd><p>Unique identifier of the string, that which also appears in the
<cite>metadata.index</cite> DataFrame.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>clas</strong><span class="classifier">int | str</span></dt><dd><p>Class key associated to the strain ‘id’.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gwadama.datasets.CoReWaves.find_merger">
<span class="sig-name descname"><span class="pre">find_merger</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">strain</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.2)"><span class="pre">ndarray</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="reference internal" href="_modules/gwadama/datasets.html#CoReWaves.find_merger"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gwadama.datasets.CoReWaves.find_merger" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gwadama.datasets.CoReWaves.get_strain">
<span class="sig-name descname"><span class="pre">get_strain</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">indices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.2)"><span class="pre">ndarray</span></a></span></span><a class="headerlink" href="#gwadama.datasets.CoReWaves.get_strain" title="Link to this definition">#</a></dt>
<dd><p>Get a single strain from the complete index coordinates.</p>
<p>This is just a shortcut to avoid having to write several squared
brackets.</p>
<p>NOTE: The returned strain is not a copy; if its contents are modified,
the changes will be reflected inside the ‘strains’ attribute.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>*indices</strong><span class="classifier">str | int</span></dt><dd><p>The indices of the strain to retrieve.</p>
</dd>
<dt><strong>normalize</strong><span class="classifier">bool</span></dt><dd><p>If True, the returned strain will be normalized to its maximum
amplitude.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>strain</strong><span class="classifier">np.ndarray</span></dt><dd><p>The requested strain.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gwadama.datasets.CoReWaves.get_strains_array">
<span class="sig-name descname"><span class="pre">get_strains_array</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">length</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.2)"><span class="pre">ndarray</span></a></span></span><a class="headerlink" href="#gwadama.datasets.CoReWaves.get_strains_array" title="Link to this definition">#</a></dt>
<dd><p>Get all strains stacked in a zero-padded Numpy 2d-array.</p>
<p>Stacks all signals into an homogeneous numpy array whose length
(axis=1) is determined by either ‘length’ or, if None, by the longest
strain in the subset.
The remaining space is zeroed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>length</strong><span class="classifier">int, optional</span></dt><dd><p>Target length of the ‘strains_array’. If None, the longest signal
determines the length.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>strains_array</strong><span class="classifier">np.ndarray</span></dt><dd><p>train subset.</p>
</dd>
<dt><strong>lengths</strong><span class="classifier">list</span></dt><dd><p>Original length of each strain, following the same order as the
first axis of ‘train_array’.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gwadama.datasets.CoReWaves.get_times">
<span class="sig-name descname"><span class="pre">get_times</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">indices</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.2)"><span class="pre">ndarray</span></a></span></span><a class="headerlink" href="#gwadama.datasets.CoReWaves.get_times" title="Link to this definition">#</a></dt>
<dd><p>Get a single time array from the complete index coordinates.</p>
<p>This is just a shortcut to avoid having to write several squared
brackets.</p>
<p>NOTE: The returned strain is not a copy; if its contents are modified,
the changes will be reflected inside the ‘times’ attribute.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gwadama.datasets.CoReWaves.get_xtest_array">
<span class="sig-name descname"><span class="pre">get_xtest_array</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">length</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">classes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'all'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#gwadama.datasets.CoReWaves.get_xtest_array" title="Link to this definition">#</a></dt>
<dd><p>Get the test subset stacked in a zero-padded Numpy 2d-array.</p>
<p>Stacks all signals in the test subset into an homogeneous numpy array
whose length (axis=1) is determined by either ‘length’ or, if None, by
the longest strain in the subset. The remaining space is zeroed.</p>
<p>Optionally, classes can be filtered by specifying which to include with
the <cite>classes</cite> parameter.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>length</strong><span class="classifier">int, optional</span></dt><dd></dd>
<dt><strong>classes</strong><span class="classifier">str | List[str], optional</span></dt><dd><p>Specify which classes to include. Include ‘all’ by default.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>test_array</strong><span class="classifier">np.ndarray</span></dt><dd><p>test subset.</p>
</dd>
<dt><strong>lengths</strong><span class="classifier">list</span></dt><dd><p>Original length of each strain, following the same order as the
first axis of ‘test_array’.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gwadama.datasets.CoReWaves.get_xtrain_array">
<span class="sig-name descname"><span class="pre">get_xtrain_array</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">length</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">classes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'all'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#gwadama.datasets.CoReWaves.get_xtrain_array" title="Link to this definition">#</a></dt>
<dd><p>Get the train subset stacked in a zero-padded Numpy 2d-array.</p>
<p>Stacks all signals in the train subset into an homogeneous numpy array
whose length (axis=1) is determined by either ‘length’ or, if None, by
the longest strain in the subset. The remaining space is zeroed.</p>
<p>Optionally, classes can be filtered by specifying which to include with
the <cite>classes</cite> parameter.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>length</strong><span class="classifier">int, optional</span></dt><dd><p>Target length of the ‘train_array’. If None, the longest signal
determines the length.</p>
</dd>
<dt><strong>classes</strong><span class="classifier">str | List[str], optional</span></dt><dd><p>Specify which classes to include. Include ‘all’ by default.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>train_array</strong><span class="classifier">np.ndarray</span></dt><dd><p>train subset.</p>
</dd>
<dt><strong>lengths</strong><span class="classifier">list</span></dt><dd><p>Original length of each strain, following the same order as the
first axis of ‘train_array’.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gwadama.datasets.CoReWaves.get_ytest_array">
<span class="sig-name descname"><span class="pre">get_ytest_array</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">classes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'all'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_id</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_index</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#gwadama.datasets.CoReWaves.get_ytest_array" title="Link to this definition">#</a></dt>
<dd><p>Get the filtered test labels.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>classes</strong><span class="classifier">str | list[str] | ‘all’</span></dt><dd><p>The classes to include in the labels.
All classes are included by default.</p>
</dd>
<dt><strong>with_id</strong><span class="classifier">bool</span></dt><dd><p>If True, return also the list of related IDs.</p>
</dd>
<dt><strong>with_index</strong><span class="classifier">bool</span></dt><dd><p>If True, return also the related GLOBAL indices; w.r.t. the stacked
arrays returned by ‘get_xtest_array’ WITHOUT filters.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>np.ndarray</dt><dd><p>Filtered test labels.</p>
</dd>
<dt>np.ndarray, optional</dt><dd><p>IDs associated to the filtered test labels.</p>
</dd>
<dt>np.ndarray, optional</dt><dd><p>Indices associated to the filtered test labels.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gwadama.datasets.CoReWaves.get_ytrain_array">
<span class="sig-name descname"><span class="pre">get_ytrain_array</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">classes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'all'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_id</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_index</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#gwadama.datasets.CoReWaves.get_ytrain_array" title="Link to this definition">#</a></dt>
<dd><p>Get the filtered training labels.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>classes</strong><span class="classifier">str | list[str] | ‘all’</span></dt><dd><p>The classes to include in the labels.
All classes are included by default.</p>
</dd>
<dt><strong>with_id</strong><span class="classifier">bool</span></dt><dd><p>If True, return also the list of related IDs.</p>
</dd>
<dt><strong>with_index</strong><span class="classifier">bool</span></dt><dd><p>If True, return also the related GLOBAL indices; w.r.t. the stacked
arrays returned by ‘get_xtrain_array’ WITHOUT filters.
False by default.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>np.ndarray</dt><dd><p>Filtered train labels.</p>
</dd>
<dt>np.ndarray, optional</dt><dd><p>IDs associated to the filtered train labels.</p>
</dd>
<dt>np.ndarray, optional</dt><dd><p>Indices associated to the filtered train labels.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gwadama.datasets.CoReWaves.items">
<span class="sig-name descname"><span class="pre">items</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gwadama.datasets.CoReWaves.items" title="Link to this definition">#</a></dt>
<dd><p>Return a new view of the dataset’s items with unrolled indices.</p>
<p>Each iteration consists on a tuple containing all the nested keys in
‘self.strains’ along with the corresponding strain,
(clas, id, <a href="#id41"><span class="problematic" id="id42">*</span></a>, strain).</p>
<p>It can be thought of as an extension of Python’s <cite>dict.items()</cite>.
Useful to quickly iterate over all items in the dataset.</p>
<p>Example of usage with an arbitrary number of keys in the nested
dictionary of strains:</p>
<p><a href="#id43"><span class="problematic" id="id44">``</span></a>`
for <a href="#id45"><span class="problematic" id="id46">*</span></a>keys, strain in self.items():</p>
<blockquote>
<div><p>print(f”Number of identifiers: {len(keys)}”)
print(f”Length of the strain: {len(strain)}”)
do_something(strain)</p>
</div></blockquote>
<p><a href="#id47"><span class="problematic" id="id48">``</span></a><a href="#id49"><span class="problematic" id="id50">`</span></a></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gwadama.datasets.CoReWaves.keys">
<span class="sig-name descname"><span class="pre">keys</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">max_depth</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span></span></span><a class="headerlink" href="#gwadama.datasets.CoReWaves.keys" title="Link to this definition">#</a></dt>
<dd><p>Return the unrolled combinations of all strain identifiers.</p>
<p>Return the unrolled combinations of all keys  of the nested dictionary
of strains by a hierarchical recursive search.</p>
<p>It can be thought of as the extended version of Python’s
‘dict().keys()’, although this returns a plain list.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>max_depth</strong><span class="classifier">int, optional</span></dt><dd><p>If specified, it is the number of layers to iterate to at most in
the nested ‘strains’ dictionary.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>keys</strong><span class="classifier">list</span></dt><dd><p>The unrolled combination in a Python list.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gwadama.datasets.CoReWaves.pad_strains">
<span class="sig-name descname"><span class="pre">pad_strains</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">padding</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">tuple</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">dict</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#gwadama.datasets.CoReWaves.pad_strains" title="Link to this definition">#</a></dt>
<dd><p>Pad strains with zeros on both sides.</p>
<p>This function pads each strain with a specific number of samples on both sides.
It also updates the ‘max_length’ attribute to reflect the new maximum length of the padded strains.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>padding</strong><span class="classifier">int | tuple | dict</span></dt><dd><p>The padding to apply to each strain.
If padding is an integer, it will be applied at both sides of all strains.
If padding is a tuple, it must be of the form (left_pad, right_pad) in samples.
If padding is a dictionary, it must be of the form {id: (left_pad, right_pad)},
where id is the identifier of each strain.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>If time arrays are present, they are also padded accordingly.</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gwadama.datasets.CoReWaves.project">
<span class="sig-name descname"><span class="pre">project</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">detector</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ra</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dec</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">geo_time</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">psi</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gwadama/datasets.html#CoReWaves.project"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gwadama.datasets.CoReWaves.project" title="Link to this definition">#</a></dt>
<dd><p>Project strains into the chosen detector at specified coordinates.</p>
<p>Project strains into the chosen detector at specified coordinates,
using Bilby.</p>
<p>This collapses the polarization layer in ‘strains’ and ‘times’ to a
single strain.
The times are rebuilt taking as a reference point the merger (t = 0).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>detector</strong><span class="classifier">str</span></dt><dd><p>Name of the ET arm in Bilby for InterferometerList().</p>
</dd>
<dt><strong>ra, dec</strong><span class="classifier">float</span></dt><dd><p>Sky position in equatorial coordinates.</p>
</dd>
<dt><strong>geo_time</strong><span class="classifier">int | float</span></dt><dd><p>Time of injection in GPS.</p>
</dd>
<dt><strong>psi</strong><span class="classifier">float</span></dt><dd><p>Polarization angle.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gwadama.datasets.CoReWaves.resample">
<span class="sig-name descname"><span class="pre">resample</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sample_rate</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="reference internal" href="_modules/gwadama/datasets.html#CoReWaves.resample"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gwadama.datasets.CoReWaves.resample" title="Link to this definition">#</a></dt>
<dd><p>Resample strain and time arrays to a constant rate.</p>
<p>Resample CoRe strains (from NR simulations) to a constant rate.</p>
<p>This method updates the sample_rate, the max_length and the merger_pos
inside the metadata attribute.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>sample_rate</strong><span class="classifier">int</span></dt><dd><p>The new sampling rate in Hz.</p>
</dd>
<dt><strong>verbose</strong><span class="classifier">bool</span></dt><dd><p>If True, print information about the resampling.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gwadama.datasets.CoReWaves.shrink_strains">
<span class="sig-name descname"><span class="pre">shrink_strains</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">limits</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">tuple</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">dict</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#gwadama.datasets.CoReWaves.shrink_strains" title="Link to this definition">#</a></dt>
<dd><p>Shrink strains to a specific interval.</p>
<p>Shrink strains (and their associated time arrays if present) to the
interval given by ‘limits’.</p>
<p>It also updates the ‘max_length’ attribute.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>limits</strong><span class="classifier">tuple | dict</span></dt><dd><p>The limits of the interval to shrink to.
If limits is a tuple, it must be of the form (start, end) in
samples.
If limits is a dictionary, it must be of the form {id: (start, end)},
where id is the identifier of each strain.</p>
<p>NOTE: If extra layers below ID are present, they will be shrunk
accordingly.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gwadama.datasets.CoReWaves.shrink_to_merger">
<span class="sig-name descname"><span class="pre">shrink_to_merger</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">offset</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="reference internal" href="_modules/gwadama/datasets.html#CoReWaves.shrink_to_merger"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gwadama.datasets.CoReWaves.shrink_to_merger" title="Link to this definition">#</a></dt>
<dd><p>Shrink strains and time arrays w.r.t. the merger.</p>
<p>Shrink strains (and their associated time arrays) discarding the left
side of the merger (inspiral), with a given offset in samples.</p>
<p>This also updates the metadata column ‘merger_pos’.</p>
<p>NOTE: This is an irreversible action.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>offset</strong><span class="classifier">int</span></dt><dd><p>Offset in samples relative to the merger position.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gwadama.datasets.CoReWaves.stack_by_id">
<span class="sig-name descname"><span class="pre">stack_by_id</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">id_list</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">length</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#gwadama.datasets.CoReWaves.stack_by_id" title="Link to this definition">#</a></dt>
<dd><p>Stack an subset of strains by their ID into a Numpy array.</p>
<p>Stack an arbitrary selection of strains by their original ID into a
zero-padded 2d-array. The resulting order is the same as the order of
that in ‘id_list’.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>id_list</strong><span class="classifier">list</span></dt><dd><p>The IDs of the strains to be stacked.</p>
</dd>
<dt><strong>length</strong><span class="classifier">int, optional</span></dt><dd><p>The target length of the stacked array. If None, the longest signal
determines the length.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>stacked_signals</strong><span class="classifier">np.ndarray</span></dt><dd><p>The array containing the stacked strains.</p>
</dd>
<dt><strong>lengths</strong><span class="classifier">list</span></dt><dd><p>The original lengths of each strain, following the same order as
the first axis of ‘stacked_signals’.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>Unlike in ‘get_xtrain_array’ and ‘get_xtest_array’, this method does
not filter by ‘classes’ since it would be redundant, as IDs are
unique.</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gwadama.datasets.CoReWaves.whiten">
<span class="sig-name descname"><span class="pre">whiten</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">asd_array</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.2)"><span class="pre">ndarray</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pad</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">highpass</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flength</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normed</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#gwadama.datasets.CoReWaves.whiten" title="Link to this definition">#</a></dt>
<dd><p>Whiten the strains.</p>
<p>Calling this method performs the whitening of all strains.
Optionally, strains are first zero-padded, whitened and then shrunk to
their initial size. This is useful to remove the vignetting effect.</p>
<p>NOTE: Original (non-whitened) strains will be stored in the
‘nonwhiten_strains’ attribute.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="gwadama.datasets.InjectedCoReWaves">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">gwadama.datasets.</span></span><span class="sig-name descname"><span class="pre">InjectedCoReWaves</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">clean_dataset</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#gwadama.datasets.Base" title="gwadama.datasets.Base"><span class="pre">Base</span></a></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">psd</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.2)"><span class="pre">ndarray</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Callable</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">detector</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">noise_length</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">whiten_params</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">dict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">freq_cutoff</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">freq_butter_order</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_seed</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gwadama/datasets.html#InjectedCoReWaves"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gwadama.datasets.InjectedCoReWaves" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#gwadama.datasets.BaseInjected" title="gwadama.datasets.BaseInjected"><code class="xref py py-class docutils literal notranslate"><span class="pre">BaseInjected</span></code></a></p>
<p>Manage injections of GW data from CoRe dataset.</p>
<ul class="simple">
<li><p>Tracks index position of the merger.</p></li>
<li><p>Computes the SNR only at the ring-down starting from the merger.</p></li>
<li><p>Computes also the usual SNR over the whole signal and stores it for
later reference (attr. ‘whole_snr_list’).</p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Attributes<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>snr_list</strong><span class="classifier">list</span></dt><dd><p>Partial SNR values at which each signal is injected.
This SNR is computed ONLY over the Ring-Down section of the waveform
starting from the merger, hence the name ‘partial SNR’.</p>
</dd>
<dt><strong>whole_snr</strong><span class="classifier">dict</span></dt><dd><p>Nested dictionary storing for each injection the equivalent SNR value
computed over the whole signal, hence the name ‘whole SNR’.
Structure: {<a href="#id125"><span class="problematic" id="id126">id_</span></a>: {partial_snr: whole_snr}}</p>
</dd>
<dt><strong>TODO</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<div class="pst-scrollable-table-container"><table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#gwadama.datasets.InjectedCoReWaves.asd" title="gwadama.datasets.InjectedCoReWaves.asd"><code class="xref py py-obj docutils literal notranslate"><span class="pre">asd</span></code></a>(frequencies)</p></td>
<td><p>Amplitude spectral density (ASD) of the detector at given frequencies.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#gwadama.datasets.InjectedCoReWaves.build_train_test_subsets" title="gwadama.datasets.InjectedCoReWaves.build_train_test_subsets"><code class="xref py py-obj docutils literal notranslate"><span class="pre">build_train_test_subsets</span></code></a>(train_size[, ...])</p></td>
<td><p>Generate a random Train and Test subsets.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#gwadama.datasets.InjectedCoReWaves.export_strains_to_gwf" title="gwadama.datasets.InjectedCoReWaves.export_strains_to_gwf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">export_strains_to_gwf</span></code></a>(path, channel[, ...])</p></td>
<td><p>Export all strains to GWF format, one file per strain.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#gwadama.datasets.InjectedCoReWaves.find_class" title="gwadama.datasets.InjectedCoReWaves.find_class"><code class="xref py py-obj docutils literal notranslate"><span class="pre">find_class</span></code></a>(id)</p></td>
<td><p>Find which 'class' corresponds the strain 'id'.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#gwadama.datasets.InjectedCoReWaves.gen_injections" title="gwadama.datasets.InjectedCoReWaves.gen_injections"><code class="xref py py-obj docutils literal notranslate"><span class="pre">gen_injections</span></code></a>(snr[, pad, randomize_noise, ...])</p></td>
<td><p>Inject all strains in simulated noise with the given SNR values.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#gwadama.datasets.InjectedCoReWaves.get_strain" title="gwadama.datasets.InjectedCoReWaves.get_strain"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_strain</span></code></a>(*indices[, normalize])</p></td>
<td><p>Get a single strain from the complete index coordinates.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#gwadama.datasets.InjectedCoReWaves.get_strains_array" title="gwadama.datasets.InjectedCoReWaves.get_strains_array"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_strains_array</span></code></a>([length])</p></td>
<td><p>Get all strains stacked in a zero-padded Numpy 2d-array.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#gwadama.datasets.InjectedCoReWaves.get_times" title="gwadama.datasets.InjectedCoReWaves.get_times"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_times</span></code></a>(*indices)</p></td>
<td><p>Get a single time array from the complete index coordinates.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#gwadama.datasets.InjectedCoReWaves.get_xtest_array" title="gwadama.datasets.InjectedCoReWaves.get_xtest_array"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_xtest_array</span></code></a>([length, classes, snr, ...])</p></td>
<td><p>Get the test subset stacked in a zero-padded Numpy 2d-array.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#gwadama.datasets.InjectedCoReWaves.get_xtrain_array" title="gwadama.datasets.InjectedCoReWaves.get_xtrain_array"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_xtrain_array</span></code></a>([length, classes, snr, ...])</p></td>
<td><p>Get the train subset stacked in a zero-padded Numpy 2d-array.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#gwadama.datasets.InjectedCoReWaves.get_ytest_array" title="gwadama.datasets.InjectedCoReWaves.get_ytest_array"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_ytest_array</span></code></a>([classes, snr, with_id, ...])</p></td>
<td><p>Get the filtered test labels.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#gwadama.datasets.InjectedCoReWaves.get_ytrain_array" title="gwadama.datasets.InjectedCoReWaves.get_ytrain_array"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_ytrain_array</span></code></a>([classes, snr, with_id, ...])</p></td>
<td><p>Get the filtered training labels.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#gwadama.datasets.InjectedCoReWaves.items" title="gwadama.datasets.InjectedCoReWaves.items"><code class="xref py py-obj docutils literal notranslate"><span class="pre">items</span></code></a>()</p></td>
<td><p>Return a new view of the dataset's items with unrolled indices.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#gwadama.datasets.InjectedCoReWaves.keys" title="gwadama.datasets.InjectedCoReWaves.keys"><code class="xref py py-obj docutils literal notranslate"><span class="pre">keys</span></code></a>([max_depth])</p></td>
<td><p>Return the unrolled combinations of all strain identifiers.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#gwadama.datasets.InjectedCoReWaves.pad_strains" title="gwadama.datasets.InjectedCoReWaves.pad_strains"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pad_strains</span></code></a>(padding)</p></td>
<td><p>Pad strains with zeros on both sides.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#gwadama.datasets.InjectedCoReWaves.psd" title="gwadama.datasets.InjectedCoReWaves.psd"><code class="xref py py-obj docutils literal notranslate"><span class="pre">psd</span></code></a>(frequencies)</p></td>
<td><p>Power spectral density (PSD) of the detector at given frequencies.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#gwadama.datasets.InjectedCoReWaves.resample" title="gwadama.datasets.InjectedCoReWaves.resample"><code class="xref py py-obj docutils literal notranslate"><span class="pre">resample</span></code></a>(sample_rate[, verbose])</p></td>
<td><p>Resample strain and time arrays to a constant rate.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#gwadama.datasets.InjectedCoReWaves.shrink_strains" title="gwadama.datasets.InjectedCoReWaves.shrink_strains"><code class="xref py py-obj docutils literal notranslate"><span class="pre">shrink_strains</span></code></a>(limits)</p></td>
<td><p>Shrink strains to a specific interval.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#gwadama.datasets.InjectedCoReWaves.stack_by_id" title="gwadama.datasets.InjectedCoReWaves.stack_by_id"><code class="xref py py-obj docutils literal notranslate"><span class="pre">stack_by_id</span></code></a>(id_list[, length, snr_included])</p></td>
<td><p>Stack a subset of strains by ID into a zero-padded 2d-array.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#gwadama.datasets.InjectedCoReWaves.whiten" title="gwadama.datasets.InjectedCoReWaves.whiten"><code class="xref py py-obj docutils literal notranslate"><span class="pre">whiten</span></code></a>([verbose])</p></td>
<td><p>Whiten injected strains.</p></td>
</tr>
</tbody>
</table>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="gwadama.datasets.InjectedCoReWaves.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">clean_dataset</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#gwadama.datasets.Base" title="gwadama.datasets.Base"><span class="pre">Base</span></a></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">psd</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.2)"><span class="pre">ndarray</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Callable</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">detector</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">noise_length</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">whiten_params</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">dict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">freq_cutoff</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">freq_butter_order</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_seed</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gwadama/datasets.html#InjectedCoReWaves.__init__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gwadama.datasets.InjectedCoReWaves.__init__" title="Link to this definition">#</a></dt>
<dd><p>Initializes an instance of the InjectedCoReWaves class.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>clean_dataset</strong><span class="classifier">Base</span></dt><dd><p>An instance of a BaseDataset class with noiseless signals.</p>
</dd>
<dt><strong>psd</strong><span class="classifier">np.ndarray | Callable</span></dt><dd><p>Power Spectral Density of the detector’s sensitivity in the
range of frequencies of interest.
Can be given as a callable function whose argument is
expected to be an array of frequencies, or as a 2d-array
with shape (2, psd_length) so that</p>
<dl class="simple">
<dt><a href="#id51"><span class="problematic" id="id52">``</span></a><a href="#id53"><span class="problematic" id="id54">`</span></a></dt><dd><p>psd[0] = frequency_samples
psd[1] = psd_samples.</p>
</dd>
</dl>
<p><a href="#id55"><span class="problematic" id="id56">``</span></a><a href="#id57"><span class="problematic" id="id58">`</span></a></p>
<p>NOTE: It is also used to compute the ‘asd’ attribute (ASD).</p>
</dd>
<dt><strong>detector</strong><span class="classifier">str</span></dt><dd><p>GW detector name.</p>
</dd>
<dt><strong>noise_length</strong><span class="classifier">int</span></dt><dd><p>Length of the background noise array to be generated for
later use.
It should be at least longer than the longest signal
expected to be injected.</p>
</dd>
<dt><strong>whiten_params</strong><span class="classifier">dict</span></dt><dd><p>Parameters to be passed to the ‘whiten’ method of the
‘BaseInjected’ class.</p>
</dd>
<dt><strong>freq_cutoff</strong><span class="classifier">int | float</span></dt><dd><p>Frequency cutoff for the filter applied to the signal.</p>
</dd>
<dt><strong>freq_butter_order</strong><span class="classifier">int | float</span></dt><dd><p>Order of the Butterworth filter applied to the signal.</p>
</dd>
<dt><strong>random_seed</strong><span class="classifier">int</span></dt><dd><p>Random seed for generating random numbers.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gwadama.datasets.InjectedCoReWaves.asd">
<span class="sig-name descname"><span class="pre">asd</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">frequencies</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.2)"><span class="pre">ndarray</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.2)"><span class="pre">ndarray</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#gwadama.datasets.InjectedCoReWaves.asd" title="Link to this definition">#</a></dt>
<dd><p>Amplitude spectral density (ASD) of the detector at given frequencies.</p>
<p>Interpolates the ASD at the given frequencies from their array
representation. If during initialization the ASD was given as its
array representation, the interpolant is computed using SciPy’s
quadratic spline interpolant function.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gwadama.datasets.InjectedCoReWaves.build_train_test_subsets">
<span class="sig-name descname"><span class="pre">build_train_test_subsets</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">train_size</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_seed</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#gwadama.datasets.InjectedCoReWaves.build_train_test_subsets" title="Link to this definition">#</a></dt>
<dd><p>Generate a random Train and Test subsets.</p>
<p>Only entries in the index of ‘metadata’ DataFrame are considered
independent waveforms, any extra key (layer) in the ‘strains’ dict
is treated monolithically during the shuffle.</p>
<p>The strain values are just new views into the ‘strains’ attribute.
The shuffling is performed by Scikit-Learn’s function
‘train_test_split’, with stratification enabled.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>train_size</strong><span class="classifier">int | float</span></dt><dd><p>If float, should be between 0.0 and 1.0 and represent the proportion
of the dataset to include in the train subset.
If int, represents the absolute number of train waves.</p>
<p>Ref: <a class="reference external" href="https://scikit-learn.org/stable/modules/generated/sklearn.model_selection.train_test_split.html">https://scikit-learn.org/stable/modules/generated/sklearn.model_selection.train_test_split.html</a></p>
</dd>
<dt><strong>random_seed</strong><span class="classifier">int, optional</span></dt><dd><p>Passed directly to ‘sklearn.model_selection.train_test_split’.
It is also saved in its homonymous attribute.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gwadama.datasets.InjectedCoReWaves.export_strains_to_gwf">
<span class="sig-name descname"><span class="pre">export_strains_to_gwf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">channel</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t0_gps</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#gwadama.datasets.InjectedCoReWaves.export_strains_to_gwf" title="Link to this definition">#</a></dt>
<dd><p>Export all strains to GWF format, one file per strain.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gwadama.datasets.InjectedCoReWaves.find_class">
<span class="sig-name descname"><span class="pre">find_class</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#gwadama.datasets.InjectedCoReWaves.find_class" title="Link to this definition">#</a></dt>
<dd><p>Find which ‘class’ corresponds the strain ‘id’.</p>
<p>Finds the ‘class’ of the strain represented by the unique identifier
‘id’.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>id</strong><span class="classifier">str</span></dt><dd><p>Unique identifier of the string, that which also appears in the
<cite>metadata.index</cite> DataFrame.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>clas</strong><span class="classifier">int | str</span></dt><dd><p>Class key associated to the strain ‘id’.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gwadama.datasets.InjectedCoReWaves.gen_injections">
<span class="sig-name descname"><span class="pre">gen_injections</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">snr</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">float</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pad</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">randomize_noise</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_seed</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">injections_per_snr</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gwadama/datasets.html#InjectedCoReWaves.gen_injections"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gwadama.datasets.InjectedCoReWaves.gen_injections" title="Link to this definition">#</a></dt>
<dd><p>Inject all strains in simulated noise with the given SNR values.</p>
<p>See ‘BaseInjected.gen_injections’ for more details.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>snr</strong><span class="classifier">int | float | list</span></dt><dd></dd>
<dt><strong>pad</strong><span class="classifier">int</span></dt><dd><p>Number of zeros to pad the signal at both ends before the
injection.</p>
</dd>
<dt><strong>randomize_noise</strong><span class="classifier">bool</span></dt><dd><p>If True, the noise segment is randomly chosen before the injection.
This can be used to avoid having the same noise injected for all
clean strains.
False by default.</p>
<p>NOTE: To avoid the possibility of repeating the same noise section
in different injections, the noise realization must be reasonably
large, e.g:</p>
<blockquote>
<div><p><cite>noise_length &gt; n_clean_strains * self.max_length * len(snr)</cite></p>
</div></blockquote>
</dd>
<dt><strong>random_seed</strong><span class="classifier">int, optional</span></dt><dd><p>Random seed for the noise realization.
Only used when randomize_noise is True.</p>
</dd>
<dt><strong>injections_per_snr</strong><span class="classifier">int</span></dt><dd><p>Number of injections per SNR value.
1 by default.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>ValueError</dt><dd><p>Once injections have been performed at a certain SNR value, there
cannot be injected again at the same value. Trying it will trigger
this exception.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>If whitening is intended to be applied afterwards it is useful to
pad the signal in order to avoid the window vignetting produced by
the whitening itself. This pad will be cropped afterwards.</p></li>
<li><p>New injections are stored in the ‘strains’ atrribute, with the pad
associated to all the injections performed at once. Even when
whitening is also performed right after the injections.</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gwadama.datasets.InjectedCoReWaves.get_strain">
<span class="sig-name descname"><span class="pre">get_strain</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">indices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.2)"><span class="pre">ndarray</span></a></span></span><a class="headerlink" href="#gwadama.datasets.InjectedCoReWaves.get_strain" title="Link to this definition">#</a></dt>
<dd><p>Get a single strain from the complete index coordinates.</p>
<p>This is just a shortcut to avoid having to write several squared
brackets.</p>
<p>NOTE: The returned strain is not a copy; if its contents are modified,
the changes will be reflected inside the ‘strains’ attribute.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>*indices</strong><span class="classifier">str | int</span></dt><dd><p>The indices of the strain to retrieve.</p>
</dd>
<dt><strong>normalize</strong><span class="classifier">bool</span></dt><dd><p>If True, the returned strain will be normalized to its maximum
amplitude.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>strain</strong><span class="classifier">np.ndarray</span></dt><dd><p>The requested strain.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gwadama.datasets.InjectedCoReWaves.get_strains_array">
<span class="sig-name descname"><span class="pre">get_strains_array</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">length</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.2)"><span class="pre">ndarray</span></a></span></span><a class="headerlink" href="#gwadama.datasets.InjectedCoReWaves.get_strains_array" title="Link to this definition">#</a></dt>
<dd><p>Get all strains stacked in a zero-padded Numpy 2d-array.</p>
<p>Stacks all signals into an homogeneous numpy array whose length
(axis=1) is determined by either ‘length’ or, if None, by the longest
strain in the subset.
The remaining space is zeroed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>length</strong><span class="classifier">int, optional</span></dt><dd><p>Target length of the ‘strains_array’. If None, the longest signal
determines the length.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>strains_array</strong><span class="classifier">np.ndarray</span></dt><dd><p>train subset.</p>
</dd>
<dt><strong>lengths</strong><span class="classifier">list</span></dt><dd><p>Original length of each strain, following the same order as the
first axis of ‘train_array’.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gwadama.datasets.InjectedCoReWaves.get_times">
<span class="sig-name descname"><span class="pre">get_times</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">indices</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.2)"><span class="pre">ndarray</span></a></span></span><a class="headerlink" href="#gwadama.datasets.InjectedCoReWaves.get_times" title="Link to this definition">#</a></dt>
<dd><p>Get a single time array from the complete index coordinates.</p>
<p>This is just a shortcut to avoid having to write several squared
brackets.</p>
<p>NOTE: The returned strain is not a copy; if its contents are modified,
the changes will be reflected inside the ‘times’ attribute.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gwadama.datasets.InjectedCoReWaves.get_xtest_array">
<span class="sig-name descname"><span class="pre">get_xtest_array</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">length</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">classes</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">list</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'all'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">snr</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">list</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'all'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_metadata</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#gwadama.datasets.InjectedCoReWaves.get_xtest_array" title="Link to this definition">#</a></dt>
<dd><p>Get the test subset stacked in a zero-padded Numpy 2d-array.</p>
<p>Stacks all signals in the test subset into an homogeneous numpy array
whose length (axis=1) is determined by either ‘length’ or, if None, by
the longest strain in the subset. The remaining space is zeroed.</p>
<p>Allows the possibility to filter by class and SNR.</p>
<p>NOTE: Same signals injected at different SNR are stacked continuously.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>length</strong><span class="classifier">int, optional</span></dt><dd><p>Target length of the ‘test_array’. If None, the longest signal
determines the length.</p>
</dd>
<dt><strong>classes</strong><span class="classifier">str | list[str]</span></dt><dd><p>Whitelist of classes to include in the stack.
All classes are included by default.</p>
</dd>
<dt><strong>snr</strong><span class="classifier">int | list[int] | str</span></dt><dd><p>Whitelist of SNR injections to include in the stack. If more than
one are selected, they are stacked zipped as follows:</p>
<p><a href="#id59"><span class="problematic" id="id60">``</span></a>`
eos0 id0 snr0
eos0 id0 snr1</p>
<blockquote>
<div><p>…</p>
</div></blockquote>
<p><a href="#id61"><span class="problematic" id="id62">``</span></a><a href="#id63"><span class="problematic" id="id64">`</span></a></p>
<p>All injections are included by default.</p>
</dd>
<dt><strong>with_metadata</strong><span class="classifier">bool</span></dt><dd><p>If True, the associated metadata is returned in addition to the
test array in a Pandas DataFrame instance.
This metadata is obtained from the original ‘metadata’ attribute,
with the former index inserted as the first column, ‘id’, and with an
additional column for the SNR values.
False by default.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>test_array</strong><span class="classifier">np.ndarray</span></dt><dd><p>Test subset.</p>
</dd>
<dt><strong>lengths</strong><span class="classifier">list</span></dt><dd><p>Original length of each strain, following the same order as the
first axis of ‘test_array’.</p>
</dd>
<dt><strong>metadata</strong><span class="classifier">pd.DataFrame, optional</span></dt><dd><p>If ‘with_metadata’ is True, the associated metadata is returned
with its entries in the same order as the ‘test_array’.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gwadama.datasets.InjectedCoReWaves.get_xtrain_array">
<span class="sig-name descname"><span class="pre">get_xtrain_array</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">length</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">classes</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">list</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'all'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">snr</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">list</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'all'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_metadata</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#gwadama.datasets.InjectedCoReWaves.get_xtrain_array" title="Link to this definition">#</a></dt>
<dd><p>Get the train subset stacked in a zero-padded Numpy 2d-array.</p>
<p>Stacks all signals in the train subset into an homogeneous numpy array
whose length (axis=1) is determined by either ‘length’ or, if None, by
the longest strain in the subset. The remaining space is zeroed.</p>
<p>Allows the possibility to filter by class and SNR.</p>
<p>NOTE: Same signals injected at different SNR are stacked continuously.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>length</strong><span class="classifier">int, optional</span></dt><dd><p>Target length of the ‘train_array’. If None, the longest signal
determines the length.</p>
</dd>
<dt><strong>classes</strong><span class="classifier">str | list[str]</span></dt><dd><p>Whitelist of classes to include in the stack.
All classes are included by default.</p>
</dd>
<dt><strong>snr</strong><span class="classifier">int | list[int] | str</span></dt><dd><p>Whitelist of SNR injections to include in the stack. If more than
one are selected, they are stacked zipped as follows:</p>
<p><a href="#id65"><span class="problematic" id="id66">``</span></a>`
eos0 id0 snr0
eos0 id0 snr1</p>
<blockquote>
<div><p>…</p>
</div></blockquote>
<p><a href="#id67"><span class="problematic" id="id68">``</span></a><a href="#id69"><span class="problematic" id="id70">`</span></a></p>
<p>All injections are included by default.</p>
</dd>
<dt><strong>with_metadata</strong><span class="classifier">bool</span></dt><dd><p>If True, the associated metadata is returned in addition to the
train array in a Pandas DataFrame instance.
This metadata is obtained from the original ‘metadata’ attribute,
with the former index inserted as the first column, ‘id’, and with an
additional column for the SNR values.
False by default.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>train_array</strong><span class="classifier">np.ndarray</span></dt><dd><p>Train subset.</p>
</dd>
<dt><strong>lengths</strong><span class="classifier">list</span></dt><dd><p>Original length of each strain, following the same order as the
first axis of ‘train_array’.</p>
</dd>
<dt><strong>metadata</strong><span class="classifier">pd.DataFrame, optional</span></dt><dd><p>If ‘with_metadata’ is True, the associated metadata is returned
with its entries in the same order as the ‘train_array’.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gwadama.datasets.InjectedCoReWaves.get_ytest_array">
<span class="sig-name descname"><span class="pre">get_ytest_array</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">classes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'all'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">snr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'all'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_id</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_index</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#gwadama.datasets.InjectedCoReWaves.get_ytest_array" title="Link to this definition">#</a></dt>
<dd><p>Get the filtered test labels.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>classes</strong><span class="classifier">str | list[str] | ‘all’</span></dt><dd><p>Whitelist of classes to include in the labels.
All classes are included by default.</p>
</dd>
<dt><strong>snr</strong><span class="classifier">int | list[int] | str</span></dt><dd><p>Whitelist of SNR injections to include in the labels.
All injections are included by default.</p>
</dd>
<dt><strong>with_id</strong><span class="classifier">bool</span></dt><dd><p>If True, return also the related IDs.
False by default.</p>
</dd>
<dt><strong>with_index</strong><span class="classifier">bool</span></dt><dd><p>If True, return also the related GLOBAL indices w.r.t. the stacked
arrays returned by ‘get_xtest_array’ WITHOUT filters.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>np.ndarray</dt><dd><p>Filtered test labels.</p>
</dd>
<dt>np.ndarray, optional</dt><dd><p>IDs associated to the filtered test labels.</p>
</dd>
<dt>np.ndarray, optional</dt><dd><p>Indices associated to the filtered test labels.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gwadama.datasets.InjectedCoReWaves.get_ytrain_array">
<span class="sig-name descname"><span class="pre">get_ytrain_array</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">classes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'all'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">snr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'all'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_id</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_index</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#gwadama.datasets.InjectedCoReWaves.get_ytrain_array" title="Link to this definition">#</a></dt>
<dd><p>Get the filtered training labels.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>classes</strong><span class="classifier">str | list[str] | ‘all’</span></dt><dd><p>Whitelist of classes to include in the labels.
All classes are included by default.</p>
</dd>
<dt><strong>snr</strong><span class="classifier">int | list[int] | str</span></dt><dd><p>Whitelist of SNR injections to include in the labels.
All injections are included by default.</p>
</dd>
<dt><strong>with_id</strong><span class="classifier">bool</span></dt><dd><p>If True, return also the related IDs.
False by default.</p>
</dd>
<dt><strong>with_index</strong><span class="classifier">bool</span></dt><dd><p>If True, return also the related GLOBAL indices w.r.t. the stacked
arrays returned by ‘get_xtrain_array’ WITHOUT filters.
False by default.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>np.ndarray</dt><dd><p>Filtered train labels.</p>
</dd>
<dt>np.ndarray, optional</dt><dd><p>IDs associated to the filtered train labels.</p>
</dd>
<dt>np.ndarray, optional</dt><dd><p>Indices associated to the filtered train labels.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gwadama.datasets.InjectedCoReWaves.items">
<span class="sig-name descname"><span class="pre">items</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gwadama.datasets.InjectedCoReWaves.items" title="Link to this definition">#</a></dt>
<dd><p>Return a new view of the dataset’s items with unrolled indices.</p>
<p>Each iteration consists on a tuple containing all the nested keys in
‘self.strains’ along with the corresponding strain,
(clas, id, <a href="#id71"><span class="problematic" id="id72">*</span></a>, strain).</p>
<p>It can be thought of as an extension of Python’s <cite>dict.items()</cite>.
Useful to quickly iterate over all items in the dataset.</p>
<p>Example of usage with an arbitrary number of keys in the nested
dictionary of strains:</p>
<p><a href="#id73"><span class="problematic" id="id74">``</span></a>`
for <a href="#id75"><span class="problematic" id="id76">*</span></a>keys, strain in self.items():</p>
<blockquote>
<div><p>print(f”Number of identifiers: {len(keys)}”)
print(f”Length of the strain: {len(strain)}”)
do_something(strain)</p>
</div></blockquote>
<p><a href="#id77"><span class="problematic" id="id78">``</span></a><a href="#id79"><span class="problematic" id="id80">`</span></a></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gwadama.datasets.InjectedCoReWaves.keys">
<span class="sig-name descname"><span class="pre">keys</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">max_depth</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span></span></span><a class="headerlink" href="#gwadama.datasets.InjectedCoReWaves.keys" title="Link to this definition">#</a></dt>
<dd><p>Return the unrolled combinations of all strain identifiers.</p>
<p>Return the unrolled combinations of all keys  of the nested dictionary
of strains by a hierarchical recursive search.</p>
<p>It can be thought of as the extended version of Python’s
‘dict().keys()’, although this returns a plain list.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>max_depth</strong><span class="classifier">int, optional</span></dt><dd><p>If specified, it is the number of layers to iterate to at most in
the nested ‘strains’ dictionary.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>keys</strong><span class="classifier">list</span></dt><dd><p>The unrolled combination in a Python list.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gwadama.datasets.InjectedCoReWaves.pad_strains">
<span class="sig-name descname"><span class="pre">pad_strains</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">padding</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">tuple</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">dict</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#gwadama.datasets.InjectedCoReWaves.pad_strains" title="Link to this definition">#</a></dt>
<dd><p>Pad strains with zeros on both sides.</p>
<p>This function pads each strain with a specific number of samples on both sides.
It also updates the ‘max_length’ attribute to reflect the new maximum length of the padded strains.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>padding</strong><span class="classifier">int | tuple | dict</span></dt><dd><p>The padding to apply to each strain.
If padding is an integer, it will be applied at both sides of all strains.
If padding is a tuple, it must be of the form (left_pad, right_pad) in samples.
If padding is a dictionary, it must be of the form {id: (left_pad, right_pad)},
where id is the identifier of each strain.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>If time arrays are present, they are also padded accordingly.</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gwadama.datasets.InjectedCoReWaves.psd">
<span class="sig-name descname"><span class="pre">psd</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">frequencies</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.2)"><span class="pre">ndarray</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.2)"><span class="pre">ndarray</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#gwadama.datasets.InjectedCoReWaves.psd" title="Link to this definition">#</a></dt>
<dd><p>Power spectral density (PSD) of the detector at given frequencies.</p>
<p>Interpolates the PSD at the given frequencies from their array
representation. If during initialization the PSD was given as its
array representation, the interpolant is computed using SciPy’s
quadratic spline interpolant function.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gwadama.datasets.InjectedCoReWaves.resample">
<span class="sig-name descname"><span class="pre">resample</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sample_rate</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#gwadama.datasets.InjectedCoReWaves.resample" title="Link to this definition">#</a></dt>
<dd><p>Resample strain and time arrays to a constant rate.</p>
<p>This assumes time tracking either with time arrays or with the
sampling rate provided during initialization, which will be used to
generate the time arrays previous to the resampling.</p>
<p>This method updates the sample_rate and the max_length.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>sample_rate</strong><span class="classifier">int</span></dt><dd><p>The new sampling rate in Hz.</p>
</dd>
<dt><strong>verbose</strong><span class="classifier">bool</span></dt><dd><p>If True, print information about the resampling.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gwadama.datasets.InjectedCoReWaves.shrink_strains">
<span class="sig-name descname"><span class="pre">shrink_strains</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">limits</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">tuple</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">dict</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#gwadama.datasets.InjectedCoReWaves.shrink_strains" title="Link to this definition">#</a></dt>
<dd><p>Shrink strains to a specific interval.</p>
<p>Shrink strains (and their associated time arrays if present) to the
interval given by ‘limits’.</p>
<p>It also updates the ‘max_length’ attribute.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>limits</strong><span class="classifier">tuple | dict</span></dt><dd><p>The limits of the interval to shrink to.
If limits is a tuple, it must be of the form (start, end) in
samples.
If limits is a dictionary, it must be of the form {id: (start, end)},
where id is the identifier of each strain.</p>
<p>NOTE: If extra layers below ID are present, they will be shrunk
accordingly.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gwadama.datasets.InjectedCoReWaves.stack_by_id">
<span class="sig-name descname"><span class="pre">stack_by_id</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">id_list</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">length</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">snr_included</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'all'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#gwadama.datasets.InjectedCoReWaves.stack_by_id" title="Link to this definition">#</a></dt>
<dd><p>Stack a subset of strains by ID into a zero-padded 2d-array.</p>
<p>This may allow (for example) to group up strains by their original ID
without leaking differnet injections (SNR) of the same strain into
different splits.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>id_list</strong><span class="classifier">array-like</span></dt><dd><p>The IDs of the strains to be stacked.</p>
</dd>
<dt><strong>length</strong><span class="classifier">int, optional</span></dt><dd><p>The target length of the stacked array. If None, the longest signal
determines the length.</p>
</dd>
<dt><strong>snr_included</strong><span class="classifier">int | list[int] | str, optional</span></dt><dd><p>The SNR injections to include in the stack. If more than one are
selected, they are stacked zipped as follows:</p>
<p><a href="#id81"><span class="problematic" id="id82">``</span></a>`
id0 snr0
id0 snr1</p>
<blockquote>
<div><p>…</p>
</div></blockquote>
<p><a href="#id83"><span class="problematic" id="id84">``</span></a><a href="#id85"><span class="problematic" id="id86">`</span></a></p>
<p>All injections are included by default.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>stacked_signals</strong><span class="classifier">np.ndarray</span></dt><dd><p>The array containing the stacked strains.</p>
</dd>
<dt><strong>lengths</strong><span class="classifier">list</span></dt><dd><p>The original lengths of each strain, following the same order as
the first axis of ‘stacked_signals’.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt>ValueError</dt><dd><p>If the value of ‘snr’ is not valid.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>Unlike in ‘get_xtrain_array’ and ‘get_xtest_array’, this method does
not filter by ‘classes’ since it would be redundant, as IDs are
unique.</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gwadama.datasets.InjectedCoReWaves.whiten">
<span class="sig-name descname"><span class="pre">whiten</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gwadama/datasets.html#InjectedCoReWaves.whiten"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gwadama.datasets.InjectedCoReWaves.whiten" title="Link to this definition">#</a></dt>
<dd><p>Whiten injected strains.</p>
<p>Calling this method performs the whitening of all injected strains.
Strains are later cut to their original size before adding the pad,
to remove the vigneting.</p>
<p>NOTE: This is an irreversible action; if the original injections need
to be preserved it is advised to make a copy of the instance before
performing the whitening.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="gwadama.datasets.InjectedSyntheticWaves">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">gwadama.datasets.</span></span><span class="sig-name descname"><span class="pre">InjectedSyntheticWaves</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">clean_dataset</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#gwadama.datasets.SyntheticWaves" title="gwadama.datasets.SyntheticWaves"><span class="pre">SyntheticWaves</span></a></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">psd</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.2)"><span class="pre">ndarray</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Callable</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">detector</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">noise_length</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">freq_cutoff</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">freq_butter_order</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_seed</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gwadama/datasets.html#InjectedSyntheticWaves"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gwadama.datasets.InjectedSyntheticWaves" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#gwadama.datasets.BaseInjected" title="gwadama.datasets.BaseInjected"><code class="xref py py-class docutils literal notranslate"><span class="pre">BaseInjected</span></code></a></p>
<p>TODO</p>
<p class="rubric">Methods</p>
<div class="pst-scrollable-table-container"><table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#gwadama.datasets.InjectedSyntheticWaves.asd" title="gwadama.datasets.InjectedSyntheticWaves.asd"><code class="xref py py-obj docutils literal notranslate"><span class="pre">asd</span></code></a>(frequencies)</p></td>
<td><p>Amplitude spectral density (ASD) of the detector at given frequencies.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#gwadama.datasets.InjectedSyntheticWaves.build_train_test_subsets" title="gwadama.datasets.InjectedSyntheticWaves.build_train_test_subsets"><code class="xref py py-obj docutils literal notranslate"><span class="pre">build_train_test_subsets</span></code></a>(train_size[, ...])</p></td>
<td><p>Generate a random Train and Test subsets.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#gwadama.datasets.InjectedSyntheticWaves.export_strains_to_gwf" title="gwadama.datasets.InjectedSyntheticWaves.export_strains_to_gwf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">export_strains_to_gwf</span></code></a>(path, channel[, ...])</p></td>
<td><p>Export all strains to GWF format, one file per strain.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#gwadama.datasets.InjectedSyntheticWaves.find_class" title="gwadama.datasets.InjectedSyntheticWaves.find_class"><code class="xref py py-obj docutils literal notranslate"><span class="pre">find_class</span></code></a>(id)</p></td>
<td><p>Find which 'class' corresponds the strain 'id'.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#gwadama.datasets.InjectedSyntheticWaves.gen_injections" title="gwadama.datasets.InjectedSyntheticWaves.gen_injections"><code class="xref py py-obj docutils literal notranslate"><span class="pre">gen_injections</span></code></a>(snr[, pad, randomize_noise, ...])</p></td>
<td><p>Inject all strains in simulated noise with the given SNR values.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#gwadama.datasets.InjectedSyntheticWaves.get_strain" title="gwadama.datasets.InjectedSyntheticWaves.get_strain"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_strain</span></code></a>(*indices[, normalize])</p></td>
<td><p>Get a single strain from the complete index coordinates.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#gwadama.datasets.InjectedSyntheticWaves.get_strains_array" title="gwadama.datasets.InjectedSyntheticWaves.get_strains_array"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_strains_array</span></code></a>([length])</p></td>
<td><p>Get all strains stacked in a zero-padded Numpy 2d-array.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#gwadama.datasets.InjectedSyntheticWaves.get_times" title="gwadama.datasets.InjectedSyntheticWaves.get_times"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_times</span></code></a>(*indices)</p></td>
<td><p>Get a single time array from the complete index coordinates.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#gwadama.datasets.InjectedSyntheticWaves.get_xtest_array" title="gwadama.datasets.InjectedSyntheticWaves.get_xtest_array"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_xtest_array</span></code></a>([length, classes, snr, ...])</p></td>
<td><p>Get the test subset stacked in a zero-padded Numpy 2d-array.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#gwadama.datasets.InjectedSyntheticWaves.get_xtrain_array" title="gwadama.datasets.InjectedSyntheticWaves.get_xtrain_array"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_xtrain_array</span></code></a>([length, classes, snr, ...])</p></td>
<td><p>Get the train subset stacked in a zero-padded Numpy 2d-array.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#gwadama.datasets.InjectedSyntheticWaves.get_ytest_array" title="gwadama.datasets.InjectedSyntheticWaves.get_ytest_array"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_ytest_array</span></code></a>([classes, snr, with_id, ...])</p></td>
<td><p>Get the filtered test labels.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#gwadama.datasets.InjectedSyntheticWaves.get_ytrain_array" title="gwadama.datasets.InjectedSyntheticWaves.get_ytrain_array"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_ytrain_array</span></code></a>([classes, snr, with_id, ...])</p></td>
<td><p>Get the filtered training labels.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#gwadama.datasets.InjectedSyntheticWaves.items" title="gwadama.datasets.InjectedSyntheticWaves.items"><code class="xref py py-obj docutils literal notranslate"><span class="pre">items</span></code></a>()</p></td>
<td><p>Return a new view of the dataset's items with unrolled indices.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#gwadama.datasets.InjectedSyntheticWaves.keys" title="gwadama.datasets.InjectedSyntheticWaves.keys"><code class="xref py py-obj docutils literal notranslate"><span class="pre">keys</span></code></a>([max_depth])</p></td>
<td><p>Return the unrolled combinations of all strain identifiers.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#gwadama.datasets.InjectedSyntheticWaves.pad_strains" title="gwadama.datasets.InjectedSyntheticWaves.pad_strains"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pad_strains</span></code></a>(padding)</p></td>
<td><p>Pad strains with zeros on both sides.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#gwadama.datasets.InjectedSyntheticWaves.psd" title="gwadama.datasets.InjectedSyntheticWaves.psd"><code class="xref py py-obj docutils literal notranslate"><span class="pre">psd</span></code></a>(frequencies)</p></td>
<td><p>Power spectral density (PSD) of the detector at given frequencies.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#gwadama.datasets.InjectedSyntheticWaves.resample" title="gwadama.datasets.InjectedSyntheticWaves.resample"><code class="xref py py-obj docutils literal notranslate"><span class="pre">resample</span></code></a>(sample_rate[, verbose])</p></td>
<td><p>Resample strain and time arrays to a constant rate.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#gwadama.datasets.InjectedSyntheticWaves.shrink_strains" title="gwadama.datasets.InjectedSyntheticWaves.shrink_strains"><code class="xref py py-obj docutils literal notranslate"><span class="pre">shrink_strains</span></code></a>(limits)</p></td>
<td><p>Shrink strains to a specific interval.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#gwadama.datasets.InjectedSyntheticWaves.stack_by_id" title="gwadama.datasets.InjectedSyntheticWaves.stack_by_id"><code class="xref py py-obj docutils literal notranslate"><span class="pre">stack_by_id</span></code></a>(id_list[, length, snr_included])</p></td>
<td><p>Stack a subset of strains by ID into a zero-padded 2d-array.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#gwadama.datasets.InjectedSyntheticWaves.whiten" title="gwadama.datasets.InjectedSyntheticWaves.whiten"><code class="xref py py-obj docutils literal notranslate"><span class="pre">whiten</span></code></a>([verbose])</p></td>
<td><p>Whiten injected strains.</p></td>
</tr>
</tbody>
</table>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="gwadama.datasets.InjectedSyntheticWaves.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">clean_dataset</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#gwadama.datasets.SyntheticWaves" title="gwadama.datasets.SyntheticWaves"><span class="pre">SyntheticWaves</span></a></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">psd</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.2)"><span class="pre">ndarray</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Callable</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">detector</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">noise_length</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">freq_cutoff</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">freq_butter_order</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_seed</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gwadama/datasets.html#InjectedSyntheticWaves.__init__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gwadama.datasets.InjectedSyntheticWaves.__init__" title="Link to this definition">#</a></dt>
<dd><p>Base constructor for injected datasets.</p>
<p>TODO: Update docstring.</p>
<p>When inheriting from this class, it is recommended to run this method
first in your __init__ function.</p>
<p>Relevant attributes are inherited from the ‘clean_dataset’ instance,
which can be any inherited from BaseDataset whose strains have not
been injected yet.</p>
<p>If train/test subsets are present, they too are updated when performing
injections or changing units, but only through re-building them from
the main ‘strains’ attribute using the already generated indices.
Original train/test subsets from the clean dataset are not inherited.</p>
<p>WARNING: Initializing this class does not perform the injections! For
that use the method ‘gen_injections’.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>clean_dataset</strong><span class="classifier">Base</span></dt><dd><p>Instance of a Class(Base) with noiseless signals.</p>
</dd>
<dt><strong>psd</strong><span class="classifier">np.ndarray | Callable</span></dt><dd><p>Power Spectral Density of the detector’s sensitivity in the range
of frequencies of interest. Can be given as a callable function
whose argument is expected to be an array of frequencies, or as a
2d-array with shape (2, psd_length) so that</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">psd[0]</span> <span class="pre">=</span> <span class="pre">frequency_samples</span>
<span class="pre">psd[1]</span> <span class="pre">=</span> <span class="pre">psd_samples</span>
<span class="pre">`</span></code>.</p>
<p>NOTE: It is also used to compute the ‘asd’ attribute (ASD).</p>
</dd>
<dt><strong>detector</strong><span class="classifier">str</span></dt><dd><p>GW detector name.
Not used, just for identification.</p>
</dd>
<dt><strong>noise_length</strong><span class="classifier">int</span></dt><dd><p>Length of the background noise array to be generated for later use.
It should be at least longer than the longest signal expected to be
injected.</p>
</dd>
<dt><strong>freq_cutoff</strong><span class="classifier">int | float</span></dt><dd><p>Frequency cutoff below which no noise bins will be generated in the
frequency space, and also used for the high-pass filter applied to
clean signals before injection.</p>
</dd>
<dt><strong>freq_butter_order</strong><span class="classifier">int | float</span></dt><dd><p>Butterworth filter order.
See (<a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.butter.html">https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.butter.html</a>)
for more information.</p>
</dd>
<dt><strong>flength</strong><span class="classifier">int</span></dt><dd><p>Length (in samples) of the time-domain FIR whitening filter.</p>
</dd>
<dt><strong>whiten_params</strong><span class="classifier">dict, optional</span></dt><dd><p>Parameters of the whitening filter, with the following entries:</p>
<ul class="simple">
<li><dl class="simple">
<dt>‘flength’<span class="classifier">int</span></dt><dd><p>Length (in samples) of the time-domain FIR whitening.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>‘highpass’<span class="classifier">float</span></dt><dd><p>Frequency cutoff.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>‘normed’<span class="classifier">bool</span></dt><dd><p>Normalization applied after the whitening filter.</p>
</dd>
</dl>
</li>
</ul>
</dd>
<dt><strong>random_seed</strong><span class="classifier">int, optional</span></dt><dd><p>Value passed to ‘sklearn.model_selection.train_test_split’ to
generate the Train and Test subsets.
Saved for reproducibility purposes, and also used to initialize
Numpy’s default RandomGenerator.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gwadama.datasets.InjectedSyntheticWaves.asd">
<span class="sig-name descname"><span class="pre">asd</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">frequencies</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.2)"><span class="pre">ndarray</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.2)"><span class="pre">ndarray</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#gwadama.datasets.InjectedSyntheticWaves.asd" title="Link to this definition">#</a></dt>
<dd><p>Amplitude spectral density (ASD) of the detector at given frequencies.</p>
<p>Interpolates the ASD at the given frequencies from their array
representation. If during initialization the ASD was given as its
array representation, the interpolant is computed using SciPy’s
quadratic spline interpolant function.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gwadama.datasets.InjectedSyntheticWaves.build_train_test_subsets">
<span class="sig-name descname"><span class="pre">build_train_test_subsets</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">train_size</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_seed</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#gwadama.datasets.InjectedSyntheticWaves.build_train_test_subsets" title="Link to this definition">#</a></dt>
<dd><p>Generate a random Train and Test subsets.</p>
<p>Only entries in the index of ‘metadata’ DataFrame are considered
independent waveforms, any extra key (layer) in the ‘strains’ dict
is treated monolithically during the shuffle.</p>
<p>The strain values are just new views into the ‘strains’ attribute.
The shuffling is performed by Scikit-Learn’s function
‘train_test_split’, with stratification enabled.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>train_size</strong><span class="classifier">int | float</span></dt><dd><p>If float, should be between 0.0 and 1.0 and represent the proportion
of the dataset to include in the train subset.
If int, represents the absolute number of train waves.</p>
<p>Ref: <a class="reference external" href="https://scikit-learn.org/stable/modules/generated/sklearn.model_selection.train_test_split.html">https://scikit-learn.org/stable/modules/generated/sklearn.model_selection.train_test_split.html</a></p>
</dd>
<dt><strong>random_seed</strong><span class="classifier">int, optional</span></dt><dd><p>Passed directly to ‘sklearn.model_selection.train_test_split’.
It is also saved in its homonymous attribute.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gwadama.datasets.InjectedSyntheticWaves.export_strains_to_gwf">
<span class="sig-name descname"><span class="pre">export_strains_to_gwf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">channel</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t0_gps</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#gwadama.datasets.InjectedSyntheticWaves.export_strains_to_gwf" title="Link to this definition">#</a></dt>
<dd><p>Export all strains to GWF format, one file per strain.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gwadama.datasets.InjectedSyntheticWaves.find_class">
<span class="sig-name descname"><span class="pre">find_class</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#gwadama.datasets.InjectedSyntheticWaves.find_class" title="Link to this definition">#</a></dt>
<dd><p>Find which ‘class’ corresponds the strain ‘id’.</p>
<p>Finds the ‘class’ of the strain represented by the unique identifier
‘id’.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>id</strong><span class="classifier">str</span></dt><dd><p>Unique identifier of the string, that which also appears in the
<cite>metadata.index</cite> DataFrame.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>clas</strong><span class="classifier">int | str</span></dt><dd><p>Class key associated to the strain ‘id’.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gwadama.datasets.InjectedSyntheticWaves.gen_injections">
<span class="sig-name descname"><span class="pre">gen_injections</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">snr</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">float</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pad</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">randomize_noise</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_seed</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">injections_per_snr</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#gwadama.datasets.InjectedSyntheticWaves.gen_injections" title="Link to this definition">#</a></dt>
<dd><p>Inject all strains in simulated noise with the given SNR values.</p>
<ul class="simple">
<li><p>The SNR is computed using a matched filter against the noise PSD.</p></li>
<li><p>If <cite>pad &gt; 0</cite>, it also updates the time arrays.</p></li>
<li><p>If strain units are in geometrized, they will be converted first to
IS, injected, and converted back to geometrized.</p></li>
<li><p>After each injection, applies a highpass filter at the low-cut
frequency specified at __init__.</p></li>
<li><p>If the method ‘whiten’ has been already called, all further
injections will automatically be whitened and their pad removed.</p></li>
</ul>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>snr</strong><span class="classifier">int | float | list</span></dt><dd></dd>
<dt><strong>pad</strong><span class="classifier">int</span></dt><dd><p>Number of zeros to pad the signal at both ends before the
injection.</p>
</dd>
<dt><strong>randomize_noise</strong><span class="classifier">bool</span></dt><dd><p>If True, the noise segment is randomly chosen before the injection.
This can be used to avoid having the same noise injected for all
clean strains.
False by default.</p>
<p>NOTE: To avoid the possibility of repeating the same noise section
in different injections, the noise realization must be reasonably
large, e.g:</p>
<blockquote>
<div><p><cite>noise_length &gt; n_clean_strains * self.max_length * len(snr)</cite></p>
</div></blockquote>
</dd>
<dt><strong>random_seed</strong><span class="classifier">int, optional</span></dt><dd><p>Random seed for the noise realization.
Only used when randomize_noise is True.</p>
</dd>
<dt><strong>injections_per_snr</strong><span class="classifier">int</span></dt><dd><p>Number of injections per SNR value. Defaults to 1.</p>
<p>This is useful to minimize the statistical impact of the noise
when performing injections at a sensitive (low) SNR.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>ValueError</dt><dd><p>Once injections have been performed at a certain SNR value, there
cannot be injected again at the same value. Trying it will trigger
this exception.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>If whitening is intended to be applied afterwards it is useful to
pad the signal in order to avoid the window vignetting produced by
the whitening itself. This pad will be cropped afterwards.</p></li>
<li><p>New injections are stored in the ‘strains’ atrribute, with the pad
associated to all the injections performed at once. Even when
whitening is also performed right after the injections.</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gwadama.datasets.InjectedSyntheticWaves.get_strain">
<span class="sig-name descname"><span class="pre">get_strain</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">indices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.2)"><span class="pre">ndarray</span></a></span></span><a class="headerlink" href="#gwadama.datasets.InjectedSyntheticWaves.get_strain" title="Link to this definition">#</a></dt>
<dd><p>Get a single strain from the complete index coordinates.</p>
<p>This is just a shortcut to avoid having to write several squared
brackets.</p>
<p>NOTE: The returned strain is not a copy; if its contents are modified,
the changes will be reflected inside the ‘strains’ attribute.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>*indices</strong><span class="classifier">str | int</span></dt><dd><p>The indices of the strain to retrieve.</p>
</dd>
<dt><strong>normalize</strong><span class="classifier">bool</span></dt><dd><p>If True, the returned strain will be normalized to its maximum
amplitude.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>strain</strong><span class="classifier">np.ndarray</span></dt><dd><p>The requested strain.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gwadama.datasets.InjectedSyntheticWaves.get_strains_array">
<span class="sig-name descname"><span class="pre">get_strains_array</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">length</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.2)"><span class="pre">ndarray</span></a></span></span><a class="headerlink" href="#gwadama.datasets.InjectedSyntheticWaves.get_strains_array" title="Link to this definition">#</a></dt>
<dd><p>Get all strains stacked in a zero-padded Numpy 2d-array.</p>
<p>Stacks all signals into an homogeneous numpy array whose length
(axis=1) is determined by either ‘length’ or, if None, by the longest
strain in the subset.
The remaining space is zeroed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>length</strong><span class="classifier">int, optional</span></dt><dd><p>Target length of the ‘strains_array’. If None, the longest signal
determines the length.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>strains_array</strong><span class="classifier">np.ndarray</span></dt><dd><p>train subset.</p>
</dd>
<dt><strong>lengths</strong><span class="classifier">list</span></dt><dd><p>Original length of each strain, following the same order as the
first axis of ‘train_array’.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gwadama.datasets.InjectedSyntheticWaves.get_times">
<span class="sig-name descname"><span class="pre">get_times</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">indices</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.2)"><span class="pre">ndarray</span></a></span></span><a class="headerlink" href="#gwadama.datasets.InjectedSyntheticWaves.get_times" title="Link to this definition">#</a></dt>
<dd><p>Get a single time array from the complete index coordinates.</p>
<p>This is just a shortcut to avoid having to write several squared
brackets.</p>
<p>NOTE: The returned strain is not a copy; if its contents are modified,
the changes will be reflected inside the ‘times’ attribute.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gwadama.datasets.InjectedSyntheticWaves.get_xtest_array">
<span class="sig-name descname"><span class="pre">get_xtest_array</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">length</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">classes</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">list</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'all'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">snr</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">list</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'all'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_metadata</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#gwadama.datasets.InjectedSyntheticWaves.get_xtest_array" title="Link to this definition">#</a></dt>
<dd><p>Get the test subset stacked in a zero-padded Numpy 2d-array.</p>
<p>Stacks all signals in the test subset into an homogeneous numpy array
whose length (axis=1) is determined by either ‘length’ or, if None, by
the longest strain in the subset. The remaining space is zeroed.</p>
<p>Allows the possibility to filter by class and SNR.</p>
<p>NOTE: Same signals injected at different SNR are stacked continuously.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>length</strong><span class="classifier">int, optional</span></dt><dd><p>Target length of the ‘test_array’. If None, the longest signal
determines the length.</p>
</dd>
<dt><strong>classes</strong><span class="classifier">str | list[str]</span></dt><dd><p>Whitelist of classes to include in the stack.
All classes are included by default.</p>
</dd>
<dt><strong>snr</strong><span class="classifier">int | list[int] | str</span></dt><dd><p>Whitelist of SNR injections to include in the stack. If more than
one are selected, they are stacked zipped as follows:</p>
<p><a href="#id87"><span class="problematic" id="id88">``</span></a>`
eos0 id0 snr0
eos0 id0 snr1</p>
<blockquote>
<div><p>…</p>
</div></blockquote>
<p><a href="#id89"><span class="problematic" id="id90">``</span></a><a href="#id91"><span class="problematic" id="id92">`</span></a></p>
<p>All injections are included by default.</p>
</dd>
<dt><strong>with_metadata</strong><span class="classifier">bool</span></dt><dd><p>If True, the associated metadata is returned in addition to the
test array in a Pandas DataFrame instance.
This metadata is obtained from the original ‘metadata’ attribute,
with the former index inserted as the first column, ‘id’, and with an
additional column for the SNR values.
False by default.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>test_array</strong><span class="classifier">np.ndarray</span></dt><dd><p>Test subset.</p>
</dd>
<dt><strong>lengths</strong><span class="classifier">list</span></dt><dd><p>Original length of each strain, following the same order as the
first axis of ‘test_array’.</p>
</dd>
<dt><strong>metadata</strong><span class="classifier">pd.DataFrame, optional</span></dt><dd><p>If ‘with_metadata’ is True, the associated metadata is returned
with its entries in the same order as the ‘test_array’.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gwadama.datasets.InjectedSyntheticWaves.get_xtrain_array">
<span class="sig-name descname"><span class="pre">get_xtrain_array</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">length</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">classes</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">list</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'all'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">snr</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">list</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'all'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_metadata</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#gwadama.datasets.InjectedSyntheticWaves.get_xtrain_array" title="Link to this definition">#</a></dt>
<dd><p>Get the train subset stacked in a zero-padded Numpy 2d-array.</p>
<p>Stacks all signals in the train subset into an homogeneous numpy array
whose length (axis=1) is determined by either ‘length’ or, if None, by
the longest strain in the subset. The remaining space is zeroed.</p>
<p>Allows the possibility to filter by class and SNR.</p>
<p>NOTE: Same signals injected at different SNR are stacked continuously.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>length</strong><span class="classifier">int, optional</span></dt><dd><p>Target length of the ‘train_array’. If None, the longest signal
determines the length.</p>
</dd>
<dt><strong>classes</strong><span class="classifier">str | list[str]</span></dt><dd><p>Whitelist of classes to include in the stack.
All classes are included by default.</p>
</dd>
<dt><strong>snr</strong><span class="classifier">int | list[int] | str</span></dt><dd><p>Whitelist of SNR injections to include in the stack. If more than
one are selected, they are stacked zipped as follows:</p>
<p><a href="#id93"><span class="problematic" id="id94">``</span></a>`
eos0 id0 snr0
eos0 id0 snr1</p>
<blockquote>
<div><p>…</p>
</div></blockquote>
<p><a href="#id95"><span class="problematic" id="id96">``</span></a><a href="#id97"><span class="problematic" id="id98">`</span></a></p>
<p>All injections are included by default.</p>
</dd>
<dt><strong>with_metadata</strong><span class="classifier">bool</span></dt><dd><p>If True, the associated metadata is returned in addition to the
train array in a Pandas DataFrame instance.
This metadata is obtained from the original ‘metadata’ attribute,
with the former index inserted as the first column, ‘id’, and with an
additional column for the SNR values.
False by default.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>train_array</strong><span class="classifier">np.ndarray</span></dt><dd><p>Train subset.</p>
</dd>
<dt><strong>lengths</strong><span class="classifier">list</span></dt><dd><p>Original length of each strain, following the same order as the
first axis of ‘train_array’.</p>
</dd>
<dt><strong>metadata</strong><span class="classifier">pd.DataFrame, optional</span></dt><dd><p>If ‘with_metadata’ is True, the associated metadata is returned
with its entries in the same order as the ‘train_array’.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gwadama.datasets.InjectedSyntheticWaves.get_ytest_array">
<span class="sig-name descname"><span class="pre">get_ytest_array</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">classes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'all'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">snr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'all'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_id</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_index</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#gwadama.datasets.InjectedSyntheticWaves.get_ytest_array" title="Link to this definition">#</a></dt>
<dd><p>Get the filtered test labels.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>classes</strong><span class="classifier">str | list[str] | ‘all’</span></dt><dd><p>Whitelist of classes to include in the labels.
All classes are included by default.</p>
</dd>
<dt><strong>snr</strong><span class="classifier">int | list[int] | str</span></dt><dd><p>Whitelist of SNR injections to include in the labels.
All injections are included by default.</p>
</dd>
<dt><strong>with_id</strong><span class="classifier">bool</span></dt><dd><p>If True, return also the related IDs.
False by default.</p>
</dd>
<dt><strong>with_index</strong><span class="classifier">bool</span></dt><dd><p>If True, return also the related GLOBAL indices w.r.t. the stacked
arrays returned by ‘get_xtest_array’ WITHOUT filters.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>np.ndarray</dt><dd><p>Filtered test labels.</p>
</dd>
<dt>np.ndarray, optional</dt><dd><p>IDs associated to the filtered test labels.</p>
</dd>
<dt>np.ndarray, optional</dt><dd><p>Indices associated to the filtered test labels.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gwadama.datasets.InjectedSyntheticWaves.get_ytrain_array">
<span class="sig-name descname"><span class="pre">get_ytrain_array</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">classes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'all'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">snr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'all'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_id</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_index</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#gwadama.datasets.InjectedSyntheticWaves.get_ytrain_array" title="Link to this definition">#</a></dt>
<dd><p>Get the filtered training labels.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>classes</strong><span class="classifier">str | list[str] | ‘all’</span></dt><dd><p>Whitelist of classes to include in the labels.
All classes are included by default.</p>
</dd>
<dt><strong>snr</strong><span class="classifier">int | list[int] | str</span></dt><dd><p>Whitelist of SNR injections to include in the labels.
All injections are included by default.</p>
</dd>
<dt><strong>with_id</strong><span class="classifier">bool</span></dt><dd><p>If True, return also the related IDs.
False by default.</p>
</dd>
<dt><strong>with_index</strong><span class="classifier">bool</span></dt><dd><p>If True, return also the related GLOBAL indices w.r.t. the stacked
arrays returned by ‘get_xtrain_array’ WITHOUT filters.
False by default.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>np.ndarray</dt><dd><p>Filtered train labels.</p>
</dd>
<dt>np.ndarray, optional</dt><dd><p>IDs associated to the filtered train labels.</p>
</dd>
<dt>np.ndarray, optional</dt><dd><p>Indices associated to the filtered train labels.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gwadama.datasets.InjectedSyntheticWaves.items">
<span class="sig-name descname"><span class="pre">items</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gwadama.datasets.InjectedSyntheticWaves.items" title="Link to this definition">#</a></dt>
<dd><p>Return a new view of the dataset’s items with unrolled indices.</p>
<p>Each iteration consists on a tuple containing all the nested keys in
‘self.strains’ along with the corresponding strain,
(clas, id, <a href="#id99"><span class="problematic" id="id100">*</span></a>, strain).</p>
<p>It can be thought of as an extension of Python’s <cite>dict.items()</cite>.
Useful to quickly iterate over all items in the dataset.</p>
<p>Example of usage with an arbitrary number of keys in the nested
dictionary of strains:</p>
<p><a href="#id101"><span class="problematic" id="id102">``</span></a>`
for <a href="#id103"><span class="problematic" id="id104">*</span></a>keys, strain in self.items():</p>
<blockquote>
<div><p>print(f”Number of identifiers: {len(keys)}”)
print(f”Length of the strain: {len(strain)}”)
do_something(strain)</p>
</div></blockquote>
<p><a href="#id105"><span class="problematic" id="id106">``</span></a><a href="#id107"><span class="problematic" id="id108">`</span></a></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gwadama.datasets.InjectedSyntheticWaves.keys">
<span class="sig-name descname"><span class="pre">keys</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">max_depth</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span></span></span><a class="headerlink" href="#gwadama.datasets.InjectedSyntheticWaves.keys" title="Link to this definition">#</a></dt>
<dd><p>Return the unrolled combinations of all strain identifiers.</p>
<p>Return the unrolled combinations of all keys  of the nested dictionary
of strains by a hierarchical recursive search.</p>
<p>It can be thought of as the extended version of Python’s
‘dict().keys()’, although this returns a plain list.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>max_depth</strong><span class="classifier">int, optional</span></dt><dd><p>If specified, it is the number of layers to iterate to at most in
the nested ‘strains’ dictionary.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>keys</strong><span class="classifier">list</span></dt><dd><p>The unrolled combination in a Python list.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gwadama.datasets.InjectedSyntheticWaves.pad_strains">
<span class="sig-name descname"><span class="pre">pad_strains</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">padding</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">tuple</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">dict</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#gwadama.datasets.InjectedSyntheticWaves.pad_strains" title="Link to this definition">#</a></dt>
<dd><p>Pad strains with zeros on both sides.</p>
<p>This function pads each strain with a specific number of samples on both sides.
It also updates the ‘max_length’ attribute to reflect the new maximum length of the padded strains.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>padding</strong><span class="classifier">int | tuple | dict</span></dt><dd><p>The padding to apply to each strain.
If padding is an integer, it will be applied at both sides of all strains.
If padding is a tuple, it must be of the form (left_pad, right_pad) in samples.
If padding is a dictionary, it must be of the form {id: (left_pad, right_pad)},
where id is the identifier of each strain.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>If time arrays are present, they are also padded accordingly.</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gwadama.datasets.InjectedSyntheticWaves.psd">
<span class="sig-name descname"><span class="pre">psd</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">frequencies</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.2)"><span class="pre">ndarray</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.2)"><span class="pre">ndarray</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#gwadama.datasets.InjectedSyntheticWaves.psd" title="Link to this definition">#</a></dt>
<dd><p>Power spectral density (PSD) of the detector at given frequencies.</p>
<p>Interpolates the PSD at the given frequencies from their array
representation. If during initialization the PSD was given as its
array representation, the interpolant is computed using SciPy’s
quadratic spline interpolant function.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gwadama.datasets.InjectedSyntheticWaves.resample">
<span class="sig-name descname"><span class="pre">resample</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sample_rate</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#gwadama.datasets.InjectedSyntheticWaves.resample" title="Link to this definition">#</a></dt>
<dd><p>Resample strain and time arrays to a constant rate.</p>
<p>This assumes time tracking either with time arrays or with the
sampling rate provided during initialization, which will be used to
generate the time arrays previous to the resampling.</p>
<p>This method updates the sample_rate and the max_length.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>sample_rate</strong><span class="classifier">int</span></dt><dd><p>The new sampling rate in Hz.</p>
</dd>
<dt><strong>verbose</strong><span class="classifier">bool</span></dt><dd><p>If True, print information about the resampling.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gwadama.datasets.InjectedSyntheticWaves.shrink_strains">
<span class="sig-name descname"><span class="pre">shrink_strains</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">limits</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">tuple</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">dict</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#gwadama.datasets.InjectedSyntheticWaves.shrink_strains" title="Link to this definition">#</a></dt>
<dd><p>Shrink strains to a specific interval.</p>
<p>Shrink strains (and their associated time arrays if present) to the
interval given by ‘limits’.</p>
<p>It also updates the ‘max_length’ attribute.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>limits</strong><span class="classifier">tuple | dict</span></dt><dd><p>The limits of the interval to shrink to.
If limits is a tuple, it must be of the form (start, end) in
samples.
If limits is a dictionary, it must be of the form {id: (start, end)},
where id is the identifier of each strain.</p>
<p>NOTE: If extra layers below ID are present, they will be shrunk
accordingly.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gwadama.datasets.InjectedSyntheticWaves.stack_by_id">
<span class="sig-name descname"><span class="pre">stack_by_id</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">id_list</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">length</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">snr_included</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'all'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#gwadama.datasets.InjectedSyntheticWaves.stack_by_id" title="Link to this definition">#</a></dt>
<dd><p>Stack a subset of strains by ID into a zero-padded 2d-array.</p>
<p>This may allow (for example) to group up strains by their original ID
without leaking differnet injections (SNR) of the same strain into
different splits.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>id_list</strong><span class="classifier">array-like</span></dt><dd><p>The IDs of the strains to be stacked.</p>
</dd>
<dt><strong>length</strong><span class="classifier">int, optional</span></dt><dd><p>The target length of the stacked array. If None, the longest signal
determines the length.</p>
</dd>
<dt><strong>snr_included</strong><span class="classifier">int | list[int] | str, optional</span></dt><dd><p>The SNR injections to include in the stack. If more than one are
selected, they are stacked zipped as follows:</p>
<p><a href="#id109"><span class="problematic" id="id110">``</span></a>`
id0 snr0
id0 snr1</p>
<blockquote>
<div><p>…</p>
</div></blockquote>
<p><a href="#id111"><span class="problematic" id="id112">``</span></a><a href="#id113"><span class="problematic" id="id114">`</span></a></p>
<p>All injections are included by default.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>stacked_signals</strong><span class="classifier">np.ndarray</span></dt><dd><p>The array containing the stacked strains.</p>
</dd>
<dt><strong>lengths</strong><span class="classifier">list</span></dt><dd><p>The original lengths of each strain, following the same order as
the first axis of ‘stacked_signals’.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt>ValueError</dt><dd><p>If the value of ‘snr’ is not valid.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>Unlike in ‘get_xtrain_array’ and ‘get_xtest_array’, this method does
not filter by ‘classes’ since it would be redundant, as IDs are
unique.</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gwadama.datasets.InjectedSyntheticWaves.whiten">
<span class="sig-name descname"><span class="pre">whiten</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#gwadama.datasets.InjectedSyntheticWaves.whiten" title="Link to this definition">#</a></dt>
<dd><p>Whiten injected strains.</p>
<p>Calling this method performs the whitening of all injected strains.
Strains are later cut to their original size before adding the pad,
to remove the vigneting.</p>
<p>NOTE: This is an irreversible action; if the original injections need
to be preserved it is advised to make a copy of the instance before
performing the whitening.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="gwadama.datasets.SyntheticWaves">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">gwadama.datasets.</span></span><span class="sig-name descname"><span class="pre">SyntheticWaves</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">classes</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">dict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_waves_per_class</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">wave_parameters_limits</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">dict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_length</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">peak_time_max_length</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">amp_threshold</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tukey_alpha</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sample_rate</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_seed</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gwadama/datasets.html#SyntheticWaves"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gwadama.datasets.SyntheticWaves" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#gwadama.datasets.Base" title="gwadama.datasets.Base"><code class="xref py py-class docutils literal notranslate"><span class="pre">Base</span></code></a></p>
<p>Class for building synthetically generated wavforms and background noise.</p>
<p>Part of the datasets for the CLAWDIA main paper.</p>
<p>The classes are hardcoded:</p>
<blockquote>
<div><p>SG: Sine Gaussian,</p>
<p>G:  Gaussian,</p>
<p>RD: Ring-Down.</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Attributes<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>classes</strong><span class="classifier">dict</span></dt><dd><p>Dict of strings and their integer labels, one per class (category).</p>
</dd>
<dt><strong>strains</strong><span class="classifier">dict {class: {key: gw_strains} }</span></dt><dd><p>Strains stored as a nested dictionary, with each strain in an
independent array to provide more flexibility with data of a wide
range of lengths.
The class key is the name of the class, a string which must exist in
the ‘classes’ attribute.
The ‘key’ is an identifier of each strain.
In this case it’s just the global index ranging from 0 to ‘self.n_samples’.</p>
</dd>
<dt><strong>labels</strong><span class="classifier">NDArray[int]</span></dt><dd><p>Indices of the classes, one per waveform.
Each one points its respective waveform inside ‘strains’ to its class
in ‘classes’. The order is that of the index of ‘self.metadata’, and
coincides with the order of the strains inside ‘self.strains’ if
unrolled to a flat list of arrays.</p>
</dd>
<dt><strong>metadata</strong><span class="classifier">pandas.DataFrame</span></dt><dd><p>All parameters and data related to the strains.
The order is the same as inside ‘strains’ if unrolled to a flat list
of strains.</p>
</dd>
<dt><strong>train_size</strong><span class="classifier">int | float</span></dt><dd><p>If int, total number of samples to include in the train dataset.
If float, fraction of the total samples to include in the train
dataset.
For more details see ‘sklearn.model_selection.train_test_split’
with the flag <cite>stratified=True</cite>.</p>
</dd>
<dt><strong>units</strong><span class="classifier">str</span></dt><dd><p>Flag indicating whether the data is in ‘geometrized’ or ‘IS’ units.</p>
</dd>
<dt><strong>Xtrain, Xtest</strong><span class="classifier">dict {key: strain}</span></dt><dd><p>Train and test subsets randomly split using SKLearn train_test_split
function with stratified labels.
The key corresponds to the strain’s index at ‘self.metadata’.</p>
</dd>
<dt><strong>Ytrain, Ytest</strong><span class="classifier">NDArray[int]</span></dt><dd><p>1D Array containing the labels in the same order as ‘Xtrain’ and
‘Xtest’ respectively.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<div class="pst-scrollable-table-container"><table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#gwadama.datasets.SyntheticWaves.build_train_test_subsets" title="gwadama.datasets.SyntheticWaves.build_train_test_subsets"><code class="xref py py-obj docutils literal notranslate"><span class="pre">build_train_test_subsets</span></code></a>(train_size[, ...])</p></td>
<td><p>Generate a random Train and Test subsets.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#gwadama.datasets.SyntheticWaves.find_class" title="gwadama.datasets.SyntheticWaves.find_class"><code class="xref py py-obj docutils literal notranslate"><span class="pre">find_class</span></code></a>(id)</p></td>
<td><p>Find which 'class' corresponds the strain 'id'.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#gwadama.datasets.SyntheticWaves.get_strain" title="gwadama.datasets.SyntheticWaves.get_strain"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_strain</span></code></a>(*indices[, normalize])</p></td>
<td><p>Get a single strain from the complete index coordinates.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#gwadama.datasets.SyntheticWaves.get_strains_array" title="gwadama.datasets.SyntheticWaves.get_strains_array"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_strains_array</span></code></a>([length])</p></td>
<td><p>Get all strains stacked in a zero-padded Numpy 2d-array.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#gwadama.datasets.SyntheticWaves.get_times" title="gwadama.datasets.SyntheticWaves.get_times"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_times</span></code></a>(*indices)</p></td>
<td><p>Get a single time array from the complete index coordinates.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#gwadama.datasets.SyntheticWaves.get_xtest_array" title="gwadama.datasets.SyntheticWaves.get_xtest_array"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_xtest_array</span></code></a>([length, classes])</p></td>
<td><p>Get the test subset stacked in a zero-padded Numpy 2d-array.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#gwadama.datasets.SyntheticWaves.get_xtrain_array" title="gwadama.datasets.SyntheticWaves.get_xtrain_array"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_xtrain_array</span></code></a>([length, classes])</p></td>
<td><p>Get the train subset stacked in a zero-padded Numpy 2d-array.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#gwadama.datasets.SyntheticWaves.get_ytest_array" title="gwadama.datasets.SyntheticWaves.get_ytest_array"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_ytest_array</span></code></a>([classes, with_id, with_index])</p></td>
<td><p>Get the filtered test labels.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#gwadama.datasets.SyntheticWaves.get_ytrain_array" title="gwadama.datasets.SyntheticWaves.get_ytrain_array"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_ytrain_array</span></code></a>([classes, with_id, with_index])</p></td>
<td><p>Get the filtered training labels.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#gwadama.datasets.SyntheticWaves.items" title="gwadama.datasets.SyntheticWaves.items"><code class="xref py py-obj docutils literal notranslate"><span class="pre">items</span></code></a>()</p></td>
<td><p>Return a new view of the dataset's items with unrolled indices.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#gwadama.datasets.SyntheticWaves.keys" title="gwadama.datasets.SyntheticWaves.keys"><code class="xref py py-obj docutils literal notranslate"><span class="pre">keys</span></code></a>([max_depth])</p></td>
<td><p>Return the unrolled combinations of all strain identifiers.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#gwadama.datasets.SyntheticWaves.pad_strains" title="gwadama.datasets.SyntheticWaves.pad_strains"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pad_strains</span></code></a>(padding)</p></td>
<td><p>Pad strains with zeros on both sides.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#gwadama.datasets.SyntheticWaves.resample" title="gwadama.datasets.SyntheticWaves.resample"><code class="xref py py-obj docutils literal notranslate"><span class="pre">resample</span></code></a>(sample_rate[, verbose])</p></td>
<td><p>Resample strain and time arrays to a constant rate.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#gwadama.datasets.SyntheticWaves.shrink_strains" title="gwadama.datasets.SyntheticWaves.shrink_strains"><code class="xref py py-obj docutils literal notranslate"><span class="pre">shrink_strains</span></code></a>(limits)</p></td>
<td><p>Shrink strains to a specific interval.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#gwadama.datasets.SyntheticWaves.stack_by_id" title="gwadama.datasets.SyntheticWaves.stack_by_id"><code class="xref py py-obj docutils literal notranslate"><span class="pre">stack_by_id</span></code></a>(id_list[, length])</p></td>
<td><p>Stack an subset of strains by their ID into a Numpy array.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#gwadama.datasets.SyntheticWaves.whiten" title="gwadama.datasets.SyntheticWaves.whiten"><code class="xref py py-obj docutils literal notranslate"><span class="pre">whiten</span></code></a>([asd_array, pad, highpass, flength, ...])</p></td>
<td><p>Whiten the strains.</p></td>
</tr>
</tbody>
</table>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="gwadama.datasets.SyntheticWaves.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">classes</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">dict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_waves_per_class</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">wave_parameters_limits</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">dict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_length</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">peak_time_max_length</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">amp_threshold</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tukey_alpha</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sample_rate</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_seed</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gwadama/datasets.html#SyntheticWaves.__init__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gwadama.datasets.SyntheticWaves.__init__" title="Link to this definition">#</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>n_waves_per_class</strong><span class="classifier">int</span></dt><dd><p>Number of waves per class to produce.</p>
</dd>
<dt><strong>wave_parameters_limits</strong><span class="classifier">dict</span></dt><dd><p>Min/Max limits of the waveforms’ parameters, 9 in total.
Keys:</p>
<ul class="simple">
<li><p>mf0,   Mf0:   min/Max central frequency (SG and RD).</p></li>
<li><p>mQ,    MQ:    min/Max quality factor (SG and RD).</p></li>
<li><p>mhrss, Mhrss: min/Max sum squared amplitude of the wave.</p></li>
<li><p>mT,    MT:    min/Max duration (only G).</p></li>
</ul>
</dd>
<dt><strong>max_length</strong><span class="classifier">int</span></dt><dd><p>Maximum length of the waves. This parameter is used to generate the
initial time array with which the waveforms are computed.</p>
</dd>
<dt><strong>peak_time_max_length</strong><span class="classifier">float</span></dt><dd><p>Time of the peak of the envelope of the waves in the initial time
array (built with ‘max_length’).</p>
</dd>
<dt><strong>amp_threshold</strong><span class="classifier">float</span></dt><dd><p>Fraction w.r.t. the maximum absolute amplitude of the wave envelope
below which to end the wave by shrinking the array and applying a
windowing to the edges.</p>
</dd>
<dt><strong>tukey_alpha</strong><span class="classifier">float</span></dt><dd><p>Alpha parameter (width) of the Tukey window applied to each wave to
make sure their values end at the exact duration determined by either
the duration parameter or the amplitude threshold.</p>
</dd>
<dt><strong>sample_rate</strong><span class="classifier">int</span></dt><dd></dd>
<dt><strong>random_seed</strong><span class="classifier">int, optional.</span></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gwadama.datasets.SyntheticWaves.build_train_test_subsets">
<span class="sig-name descname"><span class="pre">build_train_test_subsets</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">train_size</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_seed</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#gwadama.datasets.SyntheticWaves.build_train_test_subsets" title="Link to this definition">#</a></dt>
<dd><p>Generate a random Train and Test subsets.</p>
<p>Only entries in the index of ‘metadata’ DataFrame are considered
independent waveforms, any extra key (layer) in the ‘strains’ dict
is treated monolithically during the shuffle.</p>
<p>The strain values are just new views into the ‘strains’ attribute.
The shuffling is performed by Scikit-Learn’s function
‘train_test_split’, with stratification enabled.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>train_size</strong><span class="classifier">int | float</span></dt><dd><p>If float, should be between 0.0 and 1.0 and represent the proportion
of the dataset to include in the train subset.
If int, represents the absolute number of train waves.</p>
<p>Ref: <a class="reference external" href="https://scikit-learn.org/stable/modules/generated/sklearn.model_selection.train_test_split.html">https://scikit-learn.org/stable/modules/generated/sklearn.model_selection.train_test_split.html</a></p>
</dd>
<dt><strong>random_seed</strong><span class="classifier">int, optional</span></dt><dd><p>Passed directly to ‘sklearn.model_selection.train_test_split’.
It is also saved in its homonymous attribute.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gwadama.datasets.SyntheticWaves.find_class">
<span class="sig-name descname"><span class="pre">find_class</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#gwadama.datasets.SyntheticWaves.find_class" title="Link to this definition">#</a></dt>
<dd><p>Find which ‘class’ corresponds the strain ‘id’.</p>
<p>Finds the ‘class’ of the strain represented by the unique identifier
‘id’.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>id</strong><span class="classifier">str</span></dt><dd><p>Unique identifier of the string, that which also appears in the
<cite>metadata.index</cite> DataFrame.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>clas</strong><span class="classifier">int | str</span></dt><dd><p>Class key associated to the strain ‘id’.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gwadama.datasets.SyntheticWaves.get_strain">
<span class="sig-name descname"><span class="pre">get_strain</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">indices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.2)"><span class="pre">ndarray</span></a></span></span><a class="headerlink" href="#gwadama.datasets.SyntheticWaves.get_strain" title="Link to this definition">#</a></dt>
<dd><p>Get a single strain from the complete index coordinates.</p>
<p>This is just a shortcut to avoid having to write several squared
brackets.</p>
<p>NOTE: The returned strain is not a copy; if its contents are modified,
the changes will be reflected inside the ‘strains’ attribute.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>*indices</strong><span class="classifier">str | int</span></dt><dd><p>The indices of the strain to retrieve.</p>
</dd>
<dt><strong>normalize</strong><span class="classifier">bool</span></dt><dd><p>If True, the returned strain will be normalized to its maximum
amplitude.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>strain</strong><span class="classifier">np.ndarray</span></dt><dd><p>The requested strain.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gwadama.datasets.SyntheticWaves.get_strains_array">
<span class="sig-name descname"><span class="pre">get_strains_array</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">length</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.2)"><span class="pre">ndarray</span></a></span></span><a class="headerlink" href="#gwadama.datasets.SyntheticWaves.get_strains_array" title="Link to this definition">#</a></dt>
<dd><p>Get all strains stacked in a zero-padded Numpy 2d-array.</p>
<p>Stacks all signals into an homogeneous numpy array whose length
(axis=1) is determined by either ‘length’ or, if None, by the longest
strain in the subset.
The remaining space is zeroed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>length</strong><span class="classifier">int, optional</span></dt><dd><p>Target length of the ‘strains_array’. If None, the longest signal
determines the length.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>strains_array</strong><span class="classifier">np.ndarray</span></dt><dd><p>train subset.</p>
</dd>
<dt><strong>lengths</strong><span class="classifier">list</span></dt><dd><p>Original length of each strain, following the same order as the
first axis of ‘train_array’.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gwadama.datasets.SyntheticWaves.get_times">
<span class="sig-name descname"><span class="pre">get_times</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">indices</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.2)"><span class="pre">ndarray</span></a></span></span><a class="headerlink" href="#gwadama.datasets.SyntheticWaves.get_times" title="Link to this definition">#</a></dt>
<dd><p>Get a single time array from the complete index coordinates.</p>
<p>This is just a shortcut to avoid having to write several squared
brackets.</p>
<p>NOTE: The returned strain is not a copy; if its contents are modified,
the changes will be reflected inside the ‘times’ attribute.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gwadama.datasets.SyntheticWaves.get_xtest_array">
<span class="sig-name descname"><span class="pre">get_xtest_array</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">length</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">classes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'all'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#gwadama.datasets.SyntheticWaves.get_xtest_array" title="Link to this definition">#</a></dt>
<dd><p>Get the test subset stacked in a zero-padded Numpy 2d-array.</p>
<p>Stacks all signals in the test subset into an homogeneous numpy array
whose length (axis=1) is determined by either ‘length’ or, if None, by
the longest strain in the subset. The remaining space is zeroed.</p>
<p>Optionally, classes can be filtered by specifying which to include with
the <cite>classes</cite> parameter.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>length</strong><span class="classifier">int, optional</span></dt><dd></dd>
<dt><strong>classes</strong><span class="classifier">str | List[str], optional</span></dt><dd><p>Specify which classes to include. Include ‘all’ by default.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>test_array</strong><span class="classifier">np.ndarray</span></dt><dd><p>test subset.</p>
</dd>
<dt><strong>lengths</strong><span class="classifier">list</span></dt><dd><p>Original length of each strain, following the same order as the
first axis of ‘test_array’.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gwadama.datasets.SyntheticWaves.get_xtrain_array">
<span class="sig-name descname"><span class="pre">get_xtrain_array</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">length</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">classes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'all'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#gwadama.datasets.SyntheticWaves.get_xtrain_array" title="Link to this definition">#</a></dt>
<dd><p>Get the train subset stacked in a zero-padded Numpy 2d-array.</p>
<p>Stacks all signals in the train subset into an homogeneous numpy array
whose length (axis=1) is determined by either ‘length’ or, if None, by
the longest strain in the subset. The remaining space is zeroed.</p>
<p>Optionally, classes can be filtered by specifying which to include with
the <cite>classes</cite> parameter.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>length</strong><span class="classifier">int, optional</span></dt><dd><p>Target length of the ‘train_array’. If None, the longest signal
determines the length.</p>
</dd>
<dt><strong>classes</strong><span class="classifier">str | List[str], optional</span></dt><dd><p>Specify which classes to include. Include ‘all’ by default.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>train_array</strong><span class="classifier">np.ndarray</span></dt><dd><p>train subset.</p>
</dd>
<dt><strong>lengths</strong><span class="classifier">list</span></dt><dd><p>Original length of each strain, following the same order as the
first axis of ‘train_array’.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gwadama.datasets.SyntheticWaves.get_ytest_array">
<span class="sig-name descname"><span class="pre">get_ytest_array</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">classes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'all'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_id</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_index</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#gwadama.datasets.SyntheticWaves.get_ytest_array" title="Link to this definition">#</a></dt>
<dd><p>Get the filtered test labels.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>classes</strong><span class="classifier">str | list[str] | ‘all’</span></dt><dd><p>The classes to include in the labels.
All classes are included by default.</p>
</dd>
<dt><strong>with_id</strong><span class="classifier">bool</span></dt><dd><p>If True, return also the list of related IDs.</p>
</dd>
<dt><strong>with_index</strong><span class="classifier">bool</span></dt><dd><p>If True, return also the related GLOBAL indices; w.r.t. the stacked
arrays returned by ‘get_xtest_array’ WITHOUT filters.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>np.ndarray</dt><dd><p>Filtered test labels.</p>
</dd>
<dt>np.ndarray, optional</dt><dd><p>IDs associated to the filtered test labels.</p>
</dd>
<dt>np.ndarray, optional</dt><dd><p>Indices associated to the filtered test labels.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gwadama.datasets.SyntheticWaves.get_ytrain_array">
<span class="sig-name descname"><span class="pre">get_ytrain_array</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">classes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'all'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_id</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_index</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#gwadama.datasets.SyntheticWaves.get_ytrain_array" title="Link to this definition">#</a></dt>
<dd><p>Get the filtered training labels.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>classes</strong><span class="classifier">str | list[str] | ‘all’</span></dt><dd><p>The classes to include in the labels.
All classes are included by default.</p>
</dd>
<dt><strong>with_id</strong><span class="classifier">bool</span></dt><dd><p>If True, return also the list of related IDs.</p>
</dd>
<dt><strong>with_index</strong><span class="classifier">bool</span></dt><dd><p>If True, return also the related GLOBAL indices; w.r.t. the stacked
arrays returned by ‘get_xtrain_array’ WITHOUT filters.
False by default.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>np.ndarray</dt><dd><p>Filtered train labels.</p>
</dd>
<dt>np.ndarray, optional</dt><dd><p>IDs associated to the filtered train labels.</p>
</dd>
<dt>np.ndarray, optional</dt><dd><p>Indices associated to the filtered train labels.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gwadama.datasets.SyntheticWaves.items">
<span class="sig-name descname"><span class="pre">items</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gwadama.datasets.SyntheticWaves.items" title="Link to this definition">#</a></dt>
<dd><p>Return a new view of the dataset’s items with unrolled indices.</p>
<p>Each iteration consists on a tuple containing all the nested keys in
‘self.strains’ along with the corresponding strain,
(clas, id, <a href="#id115"><span class="problematic" id="id116">*</span></a>, strain).</p>
<p>It can be thought of as an extension of Python’s <cite>dict.items()</cite>.
Useful to quickly iterate over all items in the dataset.</p>
<p>Example of usage with an arbitrary number of keys in the nested
dictionary of strains:</p>
<p><a href="#id117"><span class="problematic" id="id118">``</span></a>`
for <a href="#id119"><span class="problematic" id="id120">*</span></a>keys, strain in self.items():</p>
<blockquote>
<div><p>print(f”Number of identifiers: {len(keys)}”)
print(f”Length of the strain: {len(strain)}”)
do_something(strain)</p>
</div></blockquote>
<p><a href="#id121"><span class="problematic" id="id122">``</span></a><a href="#id123"><span class="problematic" id="id124">`</span></a></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gwadama.datasets.SyntheticWaves.keys">
<span class="sig-name descname"><span class="pre">keys</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">max_depth</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span></span></span><a class="headerlink" href="#gwadama.datasets.SyntheticWaves.keys" title="Link to this definition">#</a></dt>
<dd><p>Return the unrolled combinations of all strain identifiers.</p>
<p>Return the unrolled combinations of all keys  of the nested dictionary
of strains by a hierarchical recursive search.</p>
<p>It can be thought of as the extended version of Python’s
‘dict().keys()’, although this returns a plain list.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>max_depth</strong><span class="classifier">int, optional</span></dt><dd><p>If specified, it is the number of layers to iterate to at most in
the nested ‘strains’ dictionary.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>keys</strong><span class="classifier">list</span></dt><dd><p>The unrolled combination in a Python list.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gwadama.datasets.SyntheticWaves.pad_strains">
<span class="sig-name descname"><span class="pre">pad_strains</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">padding</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">tuple</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">dict</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#gwadama.datasets.SyntheticWaves.pad_strains" title="Link to this definition">#</a></dt>
<dd><p>Pad strains with zeros on both sides.</p>
<p>This function pads each strain with a specific number of samples on both sides.
It also updates the ‘max_length’ attribute to reflect the new maximum length of the padded strains.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>padding</strong><span class="classifier">int | tuple | dict</span></dt><dd><p>The padding to apply to each strain.
If padding is an integer, it will be applied at both sides of all strains.
If padding is a tuple, it must be of the form (left_pad, right_pad) in samples.
If padding is a dictionary, it must be of the form {id: (left_pad, right_pad)},
where id is the identifier of each strain.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>If time arrays are present, they are also padded accordingly.</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gwadama.datasets.SyntheticWaves.resample">
<span class="sig-name descname"><span class="pre">resample</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sample_rate</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#gwadama.datasets.SyntheticWaves.resample" title="Link to this definition">#</a></dt>
<dd><p>Resample strain and time arrays to a constant rate.</p>
<p>This assumes time tracking either with time arrays or with the
sampling rate provided during initialization, which will be used to
generate the time arrays previous to the resampling.</p>
<p>This method updates the sample_rate and the max_length.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>sample_rate</strong><span class="classifier">int</span></dt><dd><p>The new sampling rate in Hz.</p>
</dd>
<dt><strong>verbose</strong><span class="classifier">bool</span></dt><dd><p>If True, print information about the resampling.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gwadama.datasets.SyntheticWaves.shrink_strains">
<span class="sig-name descname"><span class="pre">shrink_strains</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">limits</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">tuple</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">dict</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#gwadama.datasets.SyntheticWaves.shrink_strains" title="Link to this definition">#</a></dt>
<dd><p>Shrink strains to a specific interval.</p>
<p>Shrink strains (and their associated time arrays if present) to the
interval given by ‘limits’.</p>
<p>It also updates the ‘max_length’ attribute.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>limits</strong><span class="classifier">tuple | dict</span></dt><dd><p>The limits of the interval to shrink to.
If limits is a tuple, it must be of the form (start, end) in
samples.
If limits is a dictionary, it must be of the form {id: (start, end)},
where id is the identifier of each strain.</p>
<p>NOTE: If extra layers below ID are present, they will be shrunk
accordingly.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gwadama.datasets.SyntheticWaves.stack_by_id">
<span class="sig-name descname"><span class="pre">stack_by_id</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">id_list</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">length</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#gwadama.datasets.SyntheticWaves.stack_by_id" title="Link to this definition">#</a></dt>
<dd><p>Stack an subset of strains by their ID into a Numpy array.</p>
<p>Stack an arbitrary selection of strains by their original ID into a
zero-padded 2d-array. The resulting order is the same as the order of
that in ‘id_list’.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>id_list</strong><span class="classifier">list</span></dt><dd><p>The IDs of the strains to be stacked.</p>
</dd>
<dt><strong>length</strong><span class="classifier">int, optional</span></dt><dd><p>The target length of the stacked array. If None, the longest signal
determines the length.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>stacked_signals</strong><span class="classifier">np.ndarray</span></dt><dd><p>The array containing the stacked strains.</p>
</dd>
<dt><strong>lengths</strong><span class="classifier">list</span></dt><dd><p>The original lengths of each strain, following the same order as
the first axis of ‘stacked_signals’.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>Unlike in ‘get_xtrain_array’ and ‘get_xtest_array’, this method does
not filter by ‘classes’ since it would be redundant, as IDs are
unique.</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gwadama.datasets.SyntheticWaves.whiten">
<span class="sig-name descname"><span class="pre">whiten</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">asd_array</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.2)"><span class="pre">ndarray</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pad</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">highpass</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flength</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normed</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#gwadama.datasets.SyntheticWaves.whiten" title="Link to this definition">#</a></dt>
<dd><p>Whiten the strains.</p>
<p>Calling this method performs the whitening of all strains.
Optionally, strains are first zero-padded, whitened and then shrunk to
their initial size. This is useful to remove the vignetting effect.</p>
<p>NOTE: Original (non-whitened) strains will be stored in the
‘nonwhiten_strains’ attribute.</p>
</dd></dl>

</dd></dl>

</section>


                </article>
              
              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
    <a class="left-prev"
       href="modules.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title">API Documentation</p>
      </div>
    </a>
    <a class="right-next"
       href="gwadama.detectors.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">gwadama.detectors</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <dialog id="pst-secondary-sidebar-modal"></dialog>
                <div id="pst-secondary-sidebar" class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
<div
    id="pst-page-navigation-heading-2"
    class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> On this page
  </div>
  <nav class="bd-toc-nav page-toc" aria-labelledby="pst-page-navigation-heading-2">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#gwadama.datasets.Base"><code class="docutils literal notranslate"><span class="pre">Base</span></code></a><ul class="visible nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gwadama.datasets.Base.__init__"><code class="docutils literal notranslate"><span class="pre">Base.__init__()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gwadama.datasets.Base.build_train_test_subsets"><code class="docutils literal notranslate"><span class="pre">Base.build_train_test_subsets()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gwadama.datasets.Base.find_class"><code class="docutils literal notranslate"><span class="pre">Base.find_class()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gwadama.datasets.Base.get_strain"><code class="docutils literal notranslate"><span class="pre">Base.get_strain()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gwadama.datasets.Base.get_strains_array"><code class="docutils literal notranslate"><span class="pre">Base.get_strains_array()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gwadama.datasets.Base.get_times"><code class="docutils literal notranslate"><span class="pre">Base.get_times()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gwadama.datasets.Base.get_xtest_array"><code class="docutils literal notranslate"><span class="pre">Base.get_xtest_array()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gwadama.datasets.Base.get_xtrain_array"><code class="docutils literal notranslate"><span class="pre">Base.get_xtrain_array()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gwadama.datasets.Base.get_ytest_array"><code class="docutils literal notranslate"><span class="pre">Base.get_ytest_array()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gwadama.datasets.Base.get_ytrain_array"><code class="docutils literal notranslate"><span class="pre">Base.get_ytrain_array()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gwadama.datasets.Base.items"><code class="docutils literal notranslate"><span class="pre">Base.items()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gwadama.datasets.Base.keys"><code class="docutils literal notranslate"><span class="pre">Base.keys()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gwadama.datasets.Base.pad_strains"><code class="docutils literal notranslate"><span class="pre">Base.pad_strains()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gwadama.datasets.Base.resample"><code class="docutils literal notranslate"><span class="pre">Base.resample()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gwadama.datasets.Base.shrink_strains"><code class="docutils literal notranslate"><span class="pre">Base.shrink_strains()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gwadama.datasets.Base.stack_by_id"><code class="docutils literal notranslate"><span class="pre">Base.stack_by_id()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gwadama.datasets.Base.whiten"><code class="docutils literal notranslate"><span class="pre">Base.whiten()</span></code></a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#gwadama.datasets.BaseInjected"><code class="docutils literal notranslate"><span class="pre">BaseInjected</span></code></a><ul class="visible nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gwadama.datasets.BaseInjected.__init__"><code class="docutils literal notranslate"><span class="pre">BaseInjected.__init__()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gwadama.datasets.BaseInjected.asd"><code class="docutils literal notranslate"><span class="pre">BaseInjected.asd()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gwadama.datasets.BaseInjected.build_train_test_subsets"><code class="docutils literal notranslate"><span class="pre">BaseInjected.build_train_test_subsets()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gwadama.datasets.BaseInjected.export_strains_to_gwf"><code class="docutils literal notranslate"><span class="pre">BaseInjected.export_strains_to_gwf()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gwadama.datasets.BaseInjected.find_class"><code class="docutils literal notranslate"><span class="pre">BaseInjected.find_class()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gwadama.datasets.BaseInjected.gen_injections"><code class="docutils literal notranslate"><span class="pre">BaseInjected.gen_injections()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gwadama.datasets.BaseInjected.get_strain"><code class="docutils literal notranslate"><span class="pre">BaseInjected.get_strain()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gwadama.datasets.BaseInjected.get_strains_array"><code class="docutils literal notranslate"><span class="pre">BaseInjected.get_strains_array()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gwadama.datasets.BaseInjected.get_times"><code class="docutils literal notranslate"><span class="pre">BaseInjected.get_times()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gwadama.datasets.BaseInjected.get_xtest_array"><code class="docutils literal notranslate"><span class="pre">BaseInjected.get_xtest_array()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gwadama.datasets.BaseInjected.get_xtrain_array"><code class="docutils literal notranslate"><span class="pre">BaseInjected.get_xtrain_array()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gwadama.datasets.BaseInjected.get_ytest_array"><code class="docutils literal notranslate"><span class="pre">BaseInjected.get_ytest_array()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gwadama.datasets.BaseInjected.get_ytrain_array"><code class="docutils literal notranslate"><span class="pre">BaseInjected.get_ytrain_array()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gwadama.datasets.BaseInjected.items"><code class="docutils literal notranslate"><span class="pre">BaseInjected.items()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gwadama.datasets.BaseInjected.keys"><code class="docutils literal notranslate"><span class="pre">BaseInjected.keys()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gwadama.datasets.BaseInjected.pad_strains"><code class="docutils literal notranslate"><span class="pre">BaseInjected.pad_strains()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gwadama.datasets.BaseInjected.psd"><code class="docutils literal notranslate"><span class="pre">BaseInjected.psd()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gwadama.datasets.BaseInjected.resample"><code class="docutils literal notranslate"><span class="pre">BaseInjected.resample()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gwadama.datasets.BaseInjected.shrink_strains"><code class="docutils literal notranslate"><span class="pre">BaseInjected.shrink_strains()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gwadama.datasets.BaseInjected.stack_by_id"><code class="docutils literal notranslate"><span class="pre">BaseInjected.stack_by_id()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gwadama.datasets.BaseInjected.whiten"><code class="docutils literal notranslate"><span class="pre">BaseInjected.whiten()</span></code></a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#gwadama.datasets.CoReWaves"><code class="docutils literal notranslate"><span class="pre">CoReWaves</span></code></a><ul class="visible nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gwadama.datasets.CoReWaves.__init__"><code class="docutils literal notranslate"><span class="pre">CoReWaves.__init__()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gwadama.datasets.CoReWaves.build_train_test_subsets"><code class="docutils literal notranslate"><span class="pre">CoReWaves.build_train_test_subsets()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gwadama.datasets.CoReWaves.convert_to_IS_units"><code class="docutils literal notranslate"><span class="pre">CoReWaves.convert_to_IS_units()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gwadama.datasets.CoReWaves.convert_to_scaled_geometrized_units"><code class="docutils literal notranslate"><span class="pre">CoReWaves.convert_to_scaled_geometrized_units()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gwadama.datasets.CoReWaves.find_class"><code class="docutils literal notranslate"><span class="pre">CoReWaves.find_class()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gwadama.datasets.CoReWaves.find_merger"><code class="docutils literal notranslate"><span class="pre">CoReWaves.find_merger()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gwadama.datasets.CoReWaves.get_strain"><code class="docutils literal notranslate"><span class="pre">CoReWaves.get_strain()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gwadama.datasets.CoReWaves.get_strains_array"><code class="docutils literal notranslate"><span class="pre">CoReWaves.get_strains_array()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gwadama.datasets.CoReWaves.get_times"><code class="docutils literal notranslate"><span class="pre">CoReWaves.get_times()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gwadama.datasets.CoReWaves.get_xtest_array"><code class="docutils literal notranslate"><span class="pre">CoReWaves.get_xtest_array()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gwadama.datasets.CoReWaves.get_xtrain_array"><code class="docutils literal notranslate"><span class="pre">CoReWaves.get_xtrain_array()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gwadama.datasets.CoReWaves.get_ytest_array"><code class="docutils literal notranslate"><span class="pre">CoReWaves.get_ytest_array()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gwadama.datasets.CoReWaves.get_ytrain_array"><code class="docutils literal notranslate"><span class="pre">CoReWaves.get_ytrain_array()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gwadama.datasets.CoReWaves.items"><code class="docutils literal notranslate"><span class="pre">CoReWaves.items()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gwadama.datasets.CoReWaves.keys"><code class="docutils literal notranslate"><span class="pre">CoReWaves.keys()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gwadama.datasets.CoReWaves.pad_strains"><code class="docutils literal notranslate"><span class="pre">CoReWaves.pad_strains()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gwadama.datasets.CoReWaves.project"><code class="docutils literal notranslate"><span class="pre">CoReWaves.project()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gwadama.datasets.CoReWaves.resample"><code class="docutils literal notranslate"><span class="pre">CoReWaves.resample()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gwadama.datasets.CoReWaves.shrink_strains"><code class="docutils literal notranslate"><span class="pre">CoReWaves.shrink_strains()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gwadama.datasets.CoReWaves.shrink_to_merger"><code class="docutils literal notranslate"><span class="pre">CoReWaves.shrink_to_merger()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gwadama.datasets.CoReWaves.stack_by_id"><code class="docutils literal notranslate"><span class="pre">CoReWaves.stack_by_id()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gwadama.datasets.CoReWaves.whiten"><code class="docutils literal notranslate"><span class="pre">CoReWaves.whiten()</span></code></a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#gwadama.datasets.InjectedCoReWaves"><code class="docutils literal notranslate"><span class="pre">InjectedCoReWaves</span></code></a><ul class="visible nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gwadama.datasets.InjectedCoReWaves.__init__"><code class="docutils literal notranslate"><span class="pre">InjectedCoReWaves.__init__()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gwadama.datasets.InjectedCoReWaves.asd"><code class="docutils literal notranslate"><span class="pre">InjectedCoReWaves.asd()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gwadama.datasets.InjectedCoReWaves.build_train_test_subsets"><code class="docutils literal notranslate"><span class="pre">InjectedCoReWaves.build_train_test_subsets()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gwadama.datasets.InjectedCoReWaves.export_strains_to_gwf"><code class="docutils literal notranslate"><span class="pre">InjectedCoReWaves.export_strains_to_gwf()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gwadama.datasets.InjectedCoReWaves.find_class"><code class="docutils literal notranslate"><span class="pre">InjectedCoReWaves.find_class()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gwadama.datasets.InjectedCoReWaves.gen_injections"><code class="docutils literal notranslate"><span class="pre">InjectedCoReWaves.gen_injections()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gwadama.datasets.InjectedCoReWaves.get_strain"><code class="docutils literal notranslate"><span class="pre">InjectedCoReWaves.get_strain()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gwadama.datasets.InjectedCoReWaves.get_strains_array"><code class="docutils literal notranslate"><span class="pre">InjectedCoReWaves.get_strains_array()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gwadama.datasets.InjectedCoReWaves.get_times"><code class="docutils literal notranslate"><span class="pre">InjectedCoReWaves.get_times()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gwadama.datasets.InjectedCoReWaves.get_xtest_array"><code class="docutils literal notranslate"><span class="pre">InjectedCoReWaves.get_xtest_array()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gwadama.datasets.InjectedCoReWaves.get_xtrain_array"><code class="docutils literal notranslate"><span class="pre">InjectedCoReWaves.get_xtrain_array()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gwadama.datasets.InjectedCoReWaves.get_ytest_array"><code class="docutils literal notranslate"><span class="pre">InjectedCoReWaves.get_ytest_array()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gwadama.datasets.InjectedCoReWaves.get_ytrain_array"><code class="docutils literal notranslate"><span class="pre">InjectedCoReWaves.get_ytrain_array()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gwadama.datasets.InjectedCoReWaves.items"><code class="docutils literal notranslate"><span class="pre">InjectedCoReWaves.items()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gwadama.datasets.InjectedCoReWaves.keys"><code class="docutils literal notranslate"><span class="pre">InjectedCoReWaves.keys()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gwadama.datasets.InjectedCoReWaves.pad_strains"><code class="docutils literal notranslate"><span class="pre">InjectedCoReWaves.pad_strains()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gwadama.datasets.InjectedCoReWaves.psd"><code class="docutils literal notranslate"><span class="pre">InjectedCoReWaves.psd()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gwadama.datasets.InjectedCoReWaves.resample"><code class="docutils literal notranslate"><span class="pre">InjectedCoReWaves.resample()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gwadama.datasets.InjectedCoReWaves.shrink_strains"><code class="docutils literal notranslate"><span class="pre">InjectedCoReWaves.shrink_strains()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gwadama.datasets.InjectedCoReWaves.stack_by_id"><code class="docutils literal notranslate"><span class="pre">InjectedCoReWaves.stack_by_id()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gwadama.datasets.InjectedCoReWaves.whiten"><code class="docutils literal notranslate"><span class="pre">InjectedCoReWaves.whiten()</span></code></a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#gwadama.datasets.InjectedSyntheticWaves"><code class="docutils literal notranslate"><span class="pre">InjectedSyntheticWaves</span></code></a><ul class="visible nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gwadama.datasets.InjectedSyntheticWaves.__init__"><code class="docutils literal notranslate"><span class="pre">InjectedSyntheticWaves.__init__()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gwadama.datasets.InjectedSyntheticWaves.asd"><code class="docutils literal notranslate"><span class="pre">InjectedSyntheticWaves.asd()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gwadama.datasets.InjectedSyntheticWaves.build_train_test_subsets"><code class="docutils literal notranslate"><span class="pre">InjectedSyntheticWaves.build_train_test_subsets()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gwadama.datasets.InjectedSyntheticWaves.export_strains_to_gwf"><code class="docutils literal notranslate"><span class="pre">InjectedSyntheticWaves.export_strains_to_gwf()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gwadama.datasets.InjectedSyntheticWaves.find_class"><code class="docutils literal notranslate"><span class="pre">InjectedSyntheticWaves.find_class()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gwadama.datasets.InjectedSyntheticWaves.gen_injections"><code class="docutils literal notranslate"><span class="pre">InjectedSyntheticWaves.gen_injections()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gwadama.datasets.InjectedSyntheticWaves.get_strain"><code class="docutils literal notranslate"><span class="pre">InjectedSyntheticWaves.get_strain()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gwadama.datasets.InjectedSyntheticWaves.get_strains_array"><code class="docutils literal notranslate"><span class="pre">InjectedSyntheticWaves.get_strains_array()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gwadama.datasets.InjectedSyntheticWaves.get_times"><code class="docutils literal notranslate"><span class="pre">InjectedSyntheticWaves.get_times()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gwadama.datasets.InjectedSyntheticWaves.get_xtest_array"><code class="docutils literal notranslate"><span class="pre">InjectedSyntheticWaves.get_xtest_array()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gwadama.datasets.InjectedSyntheticWaves.get_xtrain_array"><code class="docutils literal notranslate"><span class="pre">InjectedSyntheticWaves.get_xtrain_array()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gwadama.datasets.InjectedSyntheticWaves.get_ytest_array"><code class="docutils literal notranslate"><span class="pre">InjectedSyntheticWaves.get_ytest_array()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gwadama.datasets.InjectedSyntheticWaves.get_ytrain_array"><code class="docutils literal notranslate"><span class="pre">InjectedSyntheticWaves.get_ytrain_array()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gwadama.datasets.InjectedSyntheticWaves.items"><code class="docutils literal notranslate"><span class="pre">InjectedSyntheticWaves.items()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gwadama.datasets.InjectedSyntheticWaves.keys"><code class="docutils literal notranslate"><span class="pre">InjectedSyntheticWaves.keys()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gwadama.datasets.InjectedSyntheticWaves.pad_strains"><code class="docutils literal notranslate"><span class="pre">InjectedSyntheticWaves.pad_strains()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gwadama.datasets.InjectedSyntheticWaves.psd"><code class="docutils literal notranslate"><span class="pre">InjectedSyntheticWaves.psd()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gwadama.datasets.InjectedSyntheticWaves.resample"><code class="docutils literal notranslate"><span class="pre">InjectedSyntheticWaves.resample()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gwadama.datasets.InjectedSyntheticWaves.shrink_strains"><code class="docutils literal notranslate"><span class="pre">InjectedSyntheticWaves.shrink_strains()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gwadama.datasets.InjectedSyntheticWaves.stack_by_id"><code class="docutils literal notranslate"><span class="pre">InjectedSyntheticWaves.stack_by_id()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gwadama.datasets.InjectedSyntheticWaves.whiten"><code class="docutils literal notranslate"><span class="pre">InjectedSyntheticWaves.whiten()</span></code></a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#gwadama.datasets.SyntheticWaves"><code class="docutils literal notranslate"><span class="pre">SyntheticWaves</span></code></a><ul class="visible nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gwadama.datasets.SyntheticWaves.__init__"><code class="docutils literal notranslate"><span class="pre">SyntheticWaves.__init__()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gwadama.datasets.SyntheticWaves.build_train_test_subsets"><code class="docutils literal notranslate"><span class="pre">SyntheticWaves.build_train_test_subsets()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gwadama.datasets.SyntheticWaves.find_class"><code class="docutils literal notranslate"><span class="pre">SyntheticWaves.find_class()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gwadama.datasets.SyntheticWaves.get_strain"><code class="docutils literal notranslate"><span class="pre">SyntheticWaves.get_strain()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gwadama.datasets.SyntheticWaves.get_strains_array"><code class="docutils literal notranslate"><span class="pre">SyntheticWaves.get_strains_array()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gwadama.datasets.SyntheticWaves.get_times"><code class="docutils literal notranslate"><span class="pre">SyntheticWaves.get_times()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gwadama.datasets.SyntheticWaves.get_xtest_array"><code class="docutils literal notranslate"><span class="pre">SyntheticWaves.get_xtest_array()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gwadama.datasets.SyntheticWaves.get_xtrain_array"><code class="docutils literal notranslate"><span class="pre">SyntheticWaves.get_xtrain_array()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gwadama.datasets.SyntheticWaves.get_ytest_array"><code class="docutils literal notranslate"><span class="pre">SyntheticWaves.get_ytest_array()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gwadama.datasets.SyntheticWaves.get_ytrain_array"><code class="docutils literal notranslate"><span class="pre">SyntheticWaves.get_ytrain_array()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gwadama.datasets.SyntheticWaves.items"><code class="docutils literal notranslate"><span class="pre">SyntheticWaves.items()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gwadama.datasets.SyntheticWaves.keys"><code class="docutils literal notranslate"><span class="pre">SyntheticWaves.keys()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gwadama.datasets.SyntheticWaves.pad_strains"><code class="docutils literal notranslate"><span class="pre">SyntheticWaves.pad_strains()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gwadama.datasets.SyntheticWaves.resample"><code class="docutils literal notranslate"><span class="pre">SyntheticWaves.resample()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gwadama.datasets.SyntheticWaves.shrink_strains"><code class="docutils literal notranslate"><span class="pre">SyntheticWaves.shrink_strains()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gwadama.datasets.SyntheticWaves.stack_by_id"><code class="docutils literal notranslate"><span class="pre">SyntheticWaves.stack_by_id()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gwadama.datasets.SyntheticWaves.whiten"><code class="docutils literal notranslate"><span class="pre">SyntheticWaves.whiten()</span></code></a></li>
</ul>
</li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
          </footer>
        
      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script defer src="_static/scripts/bootstrap.js?digest=8878045cc6db502f8baf"></script>
<script defer src="_static/scripts/pydata-sphinx-theme.js?digest=8878045cc6db502f8baf"></script>

  <footer class="bd-footer">
<div class="bd-footer__inner bd-page-width">
  
    <div class="footer-items__start">
      
        <div class="footer-item">

  <p class="copyright">
    
      © Copyright 2025, Miquel Lluís Llorens Monteagudo.
      <br/>
    
  </p>
</div>
      
        <div class="footer-item">

  <p class="sphinx-version">
    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.2.6.
    <br/>
  </p>
</div>
      
    </div>
  
  
  
    <div class="footer-items__end">
      
        <div class="footer-item">
<p class="theme-version">
  <!-- # L10n: Setting the PST URL as an argument as this does not need to be localized -->
  Built with the <a href="https://pydata-sphinx-theme.readthedocs.io/en/stable/index.html">PyData Sphinx Theme</a> 0.16.1.
</p></div>
      
    </div>
  
</div>

  </footer>
  </body>
</html>